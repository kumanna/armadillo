<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
  <title>Armadillo: C++ linear algebra library</title>
  <link type="text/css" rel="stylesheet" href="style.css">
  <link rel="icon" href="armadillo_icon.png" type="image/png">
</head>
<body>
<center>
<table style="text-align: left; width: 80%; margin-left: auto; margin-right: auto;" border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td style="vertical-align: top;">

<table style="text-align: left; width: 100%;" border="0" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <td>
        <h2><b>Reference for Armadillo 0.9.52 (Monkey Wrench)</b></h2>
      </td>
      <td style="text-align: right; vertical-align: top;">
        <b><a href="http://arma.sourceforge.net">to Armadillo home page</a></b>
        <br>
        <b><a href="http://nicta.com.au">to NICTA home page</a></b>
      </td>
    </tr>
  </tbody>
</table>
<hr>
<div style="text-align: justify;">
<br>
<br>


<!-- BEGIN CONTENT -->

<b>Preamble</b>
<ul>
<li>
If something needs to be clarified or fixed in this documentation, 
the <a href="http://arma.sourceforge.net/contact.html">developers</a> are interested in hearing about it.
</li>
<br>
<li>
To aid the conversion of Matlab/Octave programs,
there is a <a href="#syntax">syntax conversion table</a>.
</li>
<br>
<li>
First time users may want to have a look at a short <a href="#example_prog">example program</a>.
</li>
<br>
<li>
There is a small but important API change from earlier versions of Armadillo (&lt;&nbsp;0.9.x).
Previously, some multiplication operations directly converted result matrices with a size of 1x1 into scalars.
This is no longer the case.
If you know the result of an expression will be a 1x1 matrix and wish to treat it as a pure scalar,
use the <a href="#as_scalar">as_scalar()</a> wrapping function.
</li>
</ul>
<br>

<a style="display:scroll; position:fixed; bottom:5px; right:5px;" href="#index"><font size=-1>[index]</font></a> 
<a name="index"></a>
<b>Matrix, Vector, Cube and Field Classes</b>
<ul>
<a href="#Mat">Mat&lt;<i>type</i>&gt;, mat and cx_mat</a>&nbsp;&middot;
<a href="#Col">Col&lt;<i>type</i>&gt;, colvec and vec</a>&nbsp;&middot;
<a href="#Row">Row&lt;<i>type</i>&gt;, rowvec</a>&nbsp;&middot;
<a href="#Cube">Cube&lt;<i>type</i>&gt;, cube</a>&nbsp;&middot;
<a href="#field">field&lt;<i>object&nbsp;type</i>&gt;</a>
</ul>
<br>

<b>Member Functions &amp; Variables</b>
<ul>
<a href="#attributes">attributes</a>&nbsp;&middot;
<a href="#copy_size">copy_size</a>&nbsp;&middot;
<a href="#diag">diag</a>&nbsp;&middot;
<a href="#element">element&nbsp;access</a>&nbsp;&middot;
<a href="#fill">fill</a>&nbsp;&middot;
<a href="#is_finite">is_finite</a>&nbsp;&middot;
<a href="#is_square">is_square</a>&nbsp;&middot;
<a href="#is_vec">is_vec</a>&nbsp;&middot;
<a href="#iterators_mat">iterators (matrices)</a>&nbsp;&middot;
<a href="#iterators_cube">iterators (cubes)</a>&nbsp;&middot;
<a href="#memptr">memptr</a>&nbsp;&middot;
<a href="#ones_member">ones</a>&nbsp;&middot;
<a href="#operators">operators</a>&nbsp;&middot;
<a href="#print">print</a>&nbsp;&middot;
<a href="#print_trans">print_trans</a>&nbsp;&middot;
<a href="#raw_print">raw_print</a>&nbsp;&middot;
<a href="#raw_print">raw_print_trans</a>&nbsp;&middot;
<a href="#reset">reset</a>&nbsp;&middot;
<a href="#save_load_mat">save/load (matrices &amp; cubes)</a>&nbsp;&middot;
<a href="#save_load_field">save/load (fields)</a>&nbsp;&middot;
<a href="#set_size">set_size</a>&nbsp;&middot;
<a href="#submat">submatrix&nbsp;views</a>&nbsp;&middot;
<a href="#subcube">subcube&nbsp;views</a>&nbsp;&middot;
<a href="#subfield">subfield&nbsp;views</a>&nbsp;&middot;
<a href="#swap_rows">swap_rows/cols</a>&nbsp;&middot;
<a href="#zeros_member">zeros</a>
</ul>
<br>

<b>Other Classes</b>
<ul>
<a href="#running_stat">running_stat&lt;<i>type</i>&gt;</a>&nbsp;&middot;
<a href="#running_stat_vec">running_stat_vec&lt;<i>type</i>&gt;</a>&nbsp;&middot;
<a href="#wall_clock">wall_clock</a>
</ul>
<br>

<b>Generated Vectors/Matrices/Cubes</b>
<ul>
<a href="#eye">eye</a>&nbsp;&middot;
<a href="#linspace">linspace</a>&nbsp;&middot;
<a href="#ones_standalone">ones</a>&nbsp;&middot;
<a href="#randu_randn">randu/randn</a>&nbsp;&middot;
<a href="#repmat">repmat</a>&nbsp;&middot;
<a href="#toeplitz">toeplitz</a>&nbsp;&middot;
<a href="#zeros_standalone">zeros</a>
</ul>
<br>

<b>Functions Individually Applied to Each Element of a Matrix/Cube</b>
<ul>
<a href="#abs">abs</a>&nbsp;&middot;
<a href="#eps">eps</a>&nbsp;&middot;
<a href="#misc_fns">misc functions (exp, log, log10, pow, sqrt, square)</a>&nbsp;&middot;
<a href="#trig_fns">trigonometric functions (cos, sin, ...)</a>
</ul>
<br>

<b>Scalar Valued Functions of Vectors/Matrices/Cubes</b>
<ul>
<a href="#accu">accu</a>&nbsp;&middot;
<a href="#as_scalar">as_scalar</a>&nbsp;&middot;
<a href="#det">det</a>&nbsp;&middot;
<a href="#dot">dot/norm_dot</a>&nbsp;&middot;
<a href="#log_det">log_det</a>&nbsp;&middot;
<a href="#norm">norm</a>&nbsp;&middot;
<a href="#rank">rank</a>&nbsp;&middot;
<a href="#trace">trace</a>
</ul>
<br>

<b>Scalar/Vector Valued Functions of Vectors/Matrices</b>
<ul>
<a href="#diagvec">diagvec</a>&nbsp;&middot;
<a href="#min_and_max">min/max</a>&nbsp;&middot;
<a href="#prod">prod</a>&nbsp;&middot;
<a href="#sum">sum</a>&nbsp;&middot;
<a href="#stats_fns">statistics (mean, stddev, ...)</a>
</ul>
<br>

<b>Vector/Matrix/Cube Valued Functions of Vectors/Matrices/Cubes</b>
<ul>
<a href="#conv">conv</a>&nbsp;&middot;
<a href="#conv_to">conv_to</a>&nbsp;&middot;
<a href="#conj">conj</a>&nbsp;&middot;
<a href="#cor">cor</a>&nbsp;&middot;
<a href="#cov">cov</a>&nbsp;&middot;
<a href="#cross">cross</a>&nbsp;&middot;
<a href="#diagmat">diagmat</a>&nbsp;&middot;
<a href="#find">find</a>&nbsp;&middot;
<a href="#flip">fliplr/flipud</a>&nbsp;&middot;
<a href="#htrans">htrans</a>&nbsp;&middot;
<a href="#imag_real">imag/real</a>&nbsp;&middot;
<a href="#join">join_rows/join_cols</a>&nbsp;&middot;
<a href="#kron">kron</a>&nbsp;&middot;
<a href="#reshape">reshape</a>&nbsp;&middot;
<a href="#shuffle">shuffle</a>&nbsp;&middot;
<a href="#sort">sort</a>&nbsp;&middot;
<a href="#sort_index">sort_index</a>&nbsp;&middot;
<a href="#trans">trans</a>
</ul>
<br>

<b>Decompositions, Inverse and Related Functions</b>
<ul>
<a href="#chol">chol</a>&nbsp;&middot;
<a href="#eig_sym">eig_sym</a>&nbsp;&middot;
<a href="#eig_gen">eig_gen</a>&nbsp;&middot;
<a href="#inv">inv</a>&nbsp;&middot;
<a href="#lu">lu</a>&nbsp;&middot;
<a href="#pinv">pinv</a>&nbsp;&middot;
<a href="#princomp">princomp</a>&nbsp;&middot;
<a href="#princomp_cov">princomp_cov</a>&nbsp;&middot;
<a href="#qr">qr</a>&nbsp;&middot;
<a href="#solve">solve</a>&nbsp;&middot;
<a href="#svd">svd</a>
</ul>
<br>

<b>Miscellaneous</b>
<ul>
<a href="#math_constants">math constants (pi, ...)</a>&nbsp;&middot;
<a href="#phys_constants">physical constants (speed of light, ...)</a>&nbsp;&middot;
<a href="#log_add">log_add</a>&nbsp;&middot;
<a href="#s32_u32">s32/u32</a>&nbsp;&middot;
<a href="#cx_float_double">cx_float/cx_double</a>&nbsp;&middot;
<a href="#syntax">Matlab/Armadillo syntax differences</a>&nbsp;&middot;
<a href="#example_prog">example program</a>
</ul>
<br>

<br>
<br>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Matrix, Vector, Cube and Field Classes</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="Mat"></a><b>Mat&lt;</b><i>type</i><b>&gt;</b>
<br><b>mat</b>
<br><b>cx_mat</b>
<ul>
<li>
The root template matrix class is <b>Mat&lt;</b><i>type</i><b>&gt;</b>, where <i>type</i> can be one of:
<i>char</i>, <i>int</i>, <i>float</i>, <i>double</i>, <i>std::complex&lt;double&gt;</i>, etc.
</li>
<br>
<li>
For convenience the following typedefs have been defined:
<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      imat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;<a href="#s32_u32">s32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      umat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;<a href="#s32_u32">u32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      fmat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;float&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      mat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;double&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_fmat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;<a href="#cx_float_double">cx_float</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_mat
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Mat&lt;<a href="#cx_float_double">cx_double</a>&gt;
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
In this documentation the <i>mat</i> type is used for convenience.
It is possible to use other types instead, e.g. <i>fmat</i>.
</li>
<br>
<li>
Functions which are wrappers for LAPACK or ATLAS functions (generally matrix decompositions) are only valid for the following types:
<i>fmat</i>, <i>mat</i>, <i>cx_fmat</i>, <i>cx_mat</i>.
</li>
<br>
<li>
Elements are stored with column-major ordering (i.e. column by column).
</li>
<br>
<li>
Constructors:
<ul>
<li>mat()</li>
<li>mat(n_rows, n_cols)</li>
<li>mat(mat)</li>
<li>mat(rowvec)</li>
<li>mat(colvec)</li>
<li>cx_mat(mat,mat) &nbsp; (for constructing a complex matrix out of two real matrices)</li>
</ul>
</li>
<br>

<a name="adv_constructors_mat"></a>
<li>
Advanced constructors:
<ul>
<li>mat(aux_mem*, n_rows, n_cols, copy_aux_mem = true)
<br>
<br>
Create a matrix using data from writeable auxiliary memory.
By default the matrix allocates its own memory and copies data from the auxiliary memory (for safety).
However, if <i>copy_aux_mem</i> is set to <i>false</i>,
the matrix will instead directly use the auxiliary memory (i.e. no copying).
This is faster, but can be dangerous unless you know what you're doing!
</li>
<br>
<li>mat(const aux_mem*, n_rows, n_cols)
<br>
<br>
Create a matrix by copying data from read-only auxiliary memory.
</li>
</ul>
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
double x = A(1,2);
mat B = A + A;
mat C = A * B;
mat D = A % B;
B.zeros();
B.set_size(10,10);
B.zeros(10,10);

cx_mat X(A,B);
</pre>
</ul>
</li>
<br>
<li><b>Caveat:</b>
For mathematical correctness, scalars are treated as 1x1 matrices
during initialisation.
As such, the code below <b>will not</b> generate a 5x5 matrix with
every element equal to 123.0:
<ul>
<pre>
mat A(5,5);
A = 123.0;
</pre>
</ul>
Use the following code instead:
<ul>
<pre>
mat A(5,5);
A.fill(123.0);
</pre>
</ul>
Or:
<ul>
<pre>
mat A = 123.0 * ones&lt;mat&gt;(5,5);
</pre>
</ul>
<br>
<li>
See also:
<ul>
<li><a href="#attributes">matrix attributes</a></li>
<li><a href="#element">accessing elements</a></li>
<li><a href="#operators">math &amp; relational operators</a></li>
<li><a href="#submat">submatrix views</a></li>
<li><a href="#save_load_mat">saving &amp; loading matrices</a></li>
<li><a href="#print">printing matrices</a></li>
<li><a href="#iterators_mat">STL-style element iterators</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="Col"></a><b>Col&lt;</b><i>type</i><b>&gt;</b>
<br><b>colvec</b>
<br><b>vec</b>
<ul>
<li>
Classes for column vectors (matrices with one column).
</li>
<br>
<li>The <b>Col&lt;</b><i>type</i><b>&gt;</b> class is derived from the <b>Mat&lt;</b><i>type</i><b>&gt;</b> class
and inherits most of the member functions.
</li>
<br>
<li>
For convenience the following typedefs have been defined:
<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      ivec, icolvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;<a href="#s32_u32">s32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      uvec, ucolvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;<a href="#s32_u32">u32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      fvec, fcolvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;float&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      vec, colvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;double&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_fvec, cx_fcolvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;<a href="#cx_float_double">cx_float</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_vec, cx_colvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Col&lt;<a href="#cx_float_double">cx_double</a>&gt;
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
In this documentation the <i>colvec</i> type is used for convenience and to accentuate that it is a column vector.
It is possible to use the <u>shorter version</u>, i.e. <u><i>vec</i></u>,
as well as other types, e.g. <i>fvec</i>, <i>fcolvec</i>.
</li>
<br>
<li>
Functions which take <i>Mat</i> as input can generally also take <i>Col</i> as input.
Main exceptions are functions which require square matrices.
</li>
<br>
<li>
Constructors
<ul>
<li>colvec(n_elem=0)</li>
<li>colvec(colvec)</li>
<li>colvec(mat)</li>
</ul>
</li>
<br>
<li>
An exception is thrown if the given matrix has more than one column.<br>
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec x(10);
colvec y = zeros&lt;colvec&gt;(10,1);

mat    A = randu&lt;mat&gt;(10,10);
colvec z = A.col(5); // extract a column vector
</pre>
</ul>
</li>
<br>
<li><b>Caveat:</b>
For mathematical correctness, scalars are treated as 1x1 matrices
during initialisation.
As such, the code below <b>will not</b> generate a column vector with
every element equal to 123.0:
<ul>
<pre>
colvec q(5);
q = 123.0;
</pre>
</ul>
Use the following code instead:
<ul>
<pre>
colvec q(5);
q.fill(123.0);
</pre>
</ul>
Or:
<ul>
<pre>
colvec q = 123.0 * ones&lt;colvec&gt;(5,1);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="Row"></a>
<b>Row&lt;</b><i>type</i><b>&gt;</b>
<br><b>rowvec</b>
<ul>
<li>
Classes for row vectors (matrices with one row)
</li>
<br>
<li>The template <b>Row&lt;</b><i>type</i><b>&gt;</b> class is derived from the <b>Mat&lt;</b><i>type</i><b>&gt;</b> class
and inherits most of the member functions.
</li>
<br>
<li>
For convenience the following typedefs have been defined:
<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      irowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;<a href="#s32_u32">s32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      urowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;<a href="#s32_u32">u32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      frowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;float&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      rowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;double&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_frowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;<a href="#cx_float_double">cx_float</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_rowvec
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Row&lt;<a href="#cx_float_double">cx_double</a>&gt;
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
In this documentation the <i>rowvec</i> type is used for convenience.
It is possible to use other types instead, e.g. <i>frowvec</i>.
</li>
<br>
<li>
Functions which take <i>Mat</i> as input can generally also take <i>Row</i> as input.
Main exceptions are functions which require square matrices.
</li>
<br>
<li>
Constructors
<ul>
rowvec(n_elem=0)
<br>rowvec(rowvec)
<br>rowvec(mat)
</ul>
</li>
<br>
<li>
An exception is thrown if the given matrix has more than one row.
</li>
<br>
<li>
Examples:
<ul>
<pre>
rowvec x(10);
rowvec y = zeros&lt;mat&gt;(1,10);

mat A = randu&lt;mat&gt;(10,10);
rowvec z = A.row(5); // extract a row vector
</pre>
</ul>
</li>
<br>
<li>
<b>Caveat:</b>
For mathematical correctness, scalars are treated as 1x1 matrices
during initialisation.
As such, the code below <b>will not</b> generate a row vector with
every element equal to 123.0:
<ul>
<pre>
rowvec r(5);
r = 123.0;
</pre>
</ul>
Use the following code instead:
<ul>
<pre>
rowvec r(5);
r.fill(123.0);
</pre>
</ul>
Or:
<ul>
<pre>
rowvec r = 123.0 * ones&lt;rowvec&gt;(1,5);
</pre>
</ul>
</ul>
<br>
<hr class="greyline">
<br>

<a name="Cube"></a>
<b>Cube&lt;</b><i>type</i><b>&gt;</b>
<br><b>cube</b>
<br><b>cx_cube</b>
<ul>
<li>
Classes for cubes, also known as "3D matrices".
</li>
<br>
<li>
The root template cube class is <b>Cube&lt;</b><i>type</i><b>&gt;</b>, where <i>type</i> can be one of:
<i>char</i>, <i>int</i>, <i>float</i>, <i>double</i>, <i>std::complex&lt;double&gt;</i>, etc.
</li>
<br>
<li>
For convenience the following typedefs have been defined:
<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      icube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;<a href="#s32_u32">s32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      ucube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;<a href="#s32_u32">u32</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      fcube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;float&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;double&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_fcube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;<a href="#cx_float_double">cx_float</a>&gt;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      cx_cube
      </td>
      <td style="vertical-align: top;">
      &nbsp;=&nbsp;
      </td>
      <td style="vertical-align: top;">
      Cube&lt;<a href="#cx_float_double">cx_double</a>&gt;
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
In this documentation the <i>cube</i> type is used for convenience.
It is possible to use other types instead, e.g. <i>fcube</i>.
</li>
<br>
<li>
Cube data is stored as a set of slices (matrices) stored contiguously within memory.
Within each slice, elements are stored with column-major ordering (i.e. column by column). 
</li>
<br>
<li>
Each slice can be interpreted as a matrix, hence functions which take <i>Mat</i> as input can generally also take cube slices as input.
</li>
<br>
<li>
Constructors:
<ul>
cube()
<br>cube(cube)
<br>cube(n_rows, n_cols, n_slices)
<br>cx_cube(cube, cube) (for constructing a complex cube out of two real cubes)
</ul>
</li>
<br>

<a name="adv_constructors_cube"></a>
<li>
Advanced constructors:
<ul>
<li>cube(aux_mem*, n_rows, n_cols, n_slices, copy_aux_mem = true)
<br>
<br>
Create a cube using data from writeable auxiliary memory.
By default the cube allocates its own memory and copies data from the auxiliary memory (for safety).
However, if <i>copy_aux_mem</i> is set to <i>false</i>,
the cube will instead directly use the auxiliary memory (i.e. no copying).
This is faster, but can be dangerous unless you know what you're doing!
</li>
<br>
<li>cube(const aux_mem*, n_rows, n_cols, n_slices)
<br>
<br>
Create a cube by copying data from read-only auxiliary memory.
</li>
</ul>
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
cube x(1,2,3);
cube y = randu&lt;cube&gt;(4,5,6);

mat A = y.slice(1);  // extract a slice from the cube
                     // (each slice is a matrix)

mat B = randu&lt;mat&gt;(4,5);
y.slice(2) = B;     // set a slice in the cube

cube q = y + y;     // cube addition
cube r = y % y;     // element-wise cube multiplication
</pre>
</ul>
</li>
<br>
<li>
<b>Caveats</b>
<br>
<br>
<ul>
<li>
The size of individual slices can't be changed.
For example, the following <b>will not</b> work:
<ul>
<pre>
cube c(5,6,7);
c.slice(0) = randu&lt;mat&gt;(10,20); // wrong size
</pre>
</ul>
</li>
<li>
For mathematical correctness, scalars are treated as 1x1x1 cubes
during initialisation.
As such, the code below <b>will not</b> generate a cube with
every element equal to 123.0:
<ul>
<pre>
cube c(5,6,7);
c = 123.0;
</pre>
</ul>
Use the following code instead:
<ul>
<pre>
cube c(5,6,7);
c.fill(123.0);
</pre>
</ul>
Or:
<ul>
<pre>
cube c = 123.0 * ones&lt;cube&gt;(5,6,7);
</pre>
</ul>
</li>
</ul>
<br>
<li>
See also:
<ul>
<li><a href="#attributes">cube attributes</a></li>
<li><a href="#element">accessing elements</a></li>
<li><a href="#operators">math &amp; relational operators</a></li>
<li><a href="#subcube">subcube views and slices</a></li>
<li><a href="#save_load_mat">saving &amp; loading cubes</a></li>
<li><a href="#iterators_cube">STL-style element iterators</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="field"></a>
<b>field&lt;</b><i>object type</i><b>&gt;</b>
<ul>
<li>
Class for one and two dimensional fields of arbitrary objects
</li>
<br>
<li>
Constructors (where <i>object type</i> is another class, e.g. <i>std::string</i>, <i>mat</i>, <i>colvec</i>, <i>rowvec</i>, etc):
<ul>
field&lt;<i>object type</i>&gt;(n_elem=0)
<br>field&lt;<i>object type</i>&gt;(n_rows, n_cols)
<br>field&lt;<i>object type</i>&gt;(field&lt;<i>object type</i>&gt;)
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
// create a field of strings
field&lt;std::string&gt; S(3,2);

S(0,0) = "hello";
S(1,0) = "there";

// string fields can be saved as plain text files
S.save("string_field");

// create a colvec field with 3 rows and 2 columns
field&lt;colvec&gt; F(3,2);

// access components of the field
F(0,0) = colvec(5);
F(1,1) = randu&lt;colvec&gt;(6);
F(2,0).set_size(7);

// access element 1 of the colvec stored at 2,0
double x = F(2,0)(1);

// copy rows
F.row(0) = F.row(2);

// extract a row of colvecs from F
field&lt;colvec&gt; G = F.row(1);

// print the field to the standard output
G.print("G =");

// save the field to a binary file
G.save("colvec_field");
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#attributes">field attributes</a></li>
<li><a href="#subfield">subfield views</a></li>
<li><a href="#save_load_field">saving/loading fields</a></li>
<li><a href="http://cplusplus.com/reference/string/string/">string class in the standard C++ library</a> (cplusplus.com)</li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<hr class="greyline">
<br>
<br>
<font size=+1><b>Member Functions &amp; Variables</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="attributes"></a>

<b>attributes</b>
<ul>
<table style="text-align: left;" border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td>
<b>.n_rows</b>
</td>
<td>&nbsp;</td>
<td>
(number of rows)
</td>
</tr>
<tr>
<td>
<b>.n_cols</b>
</td>
<td>&nbsp;</td>
<td>
(number of columns)
</td>
</tr>
<tr>
<td>
<b>.n_elem</b>
</td>
<td>&nbsp;</td>
<td>
(total number of elements)
</td>
</tr>
<tr>
<td>
<b>.n_slices</b>
</td>
<td>&nbsp;</td>
<td>
(number of slices)
</td>
</tr>
<tr>
<td>
<b>.n_elem_slice</b>
</td>
<td>&nbsp;</td>
<td>
(number of elements per slice)
</td>
</tr>
</tbody>
</table>
</ul>
<br>
<ul>
<li>
Member variables which are read-only.
To change the size, use
<a href="#set_size">.set_size()</a>,
<a href="#copy_size">.copy_size()</a>,
<a href="#zeros_member">.zeros()</a>,
<a href="#ones_member">.ones()</a>,
or
<a href="#reset">.reset()</a>.
</li>
<br>
<li><i>n_rows</i>, <i>n_cols</i> and <i>n_elem</i> are applicable to <i>Mat</i>, <i>Col</i>, <i>Row</i>, <i>Cube</i> and <i>field</i> classes.</li>
<br>
<li><i>n_slices</i> and <i>n_elem_slice</i> are applicable only to the <i>Cube</i> class.</li>
<br>
<li>
For the <i>Col</i> and <i>Row</i> classes, <i>n_elem</i> also indicates vector length.</li>
<br>
<li>The variables are of type <a href="#s32_u32">u32</a> (unsigned integer).</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X(4,5);
cout &lt;&lt; "X has " &lt;&lt; X.n_cols &lt;&lt; " columns" &lt;&lt; endl;
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#set_size">.set_size()</a></li>
<li><a href="#copy_size">.copy_size()</a></li>
<li><a href="#zeros_member">.zeros()</a></li>
<li><a href="#ones_member">.ones()</a></li>
<li><a href="#reset">.reset()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="copy_size"></a>
<b>.copy_size(A)</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i>, <i>Cube</i> and <i>field</i>.
</li>
<br>
<li>
Set the size to be the same as object A.
</li>
<br>
<li>
Object A must be of the same root type as the object being modified
(e.g. you can't set the size of a matrix by providing a cube).
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,6);
mat B;
B.copy_size(A);

cout &lt;&lt; B.n_rows &lt;&lt; endl;
cout &lt;&lt; B.n_cols &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="diag"></a>
<b>.diag(k=0)</b>
<ul>
<li>
Member function of <i>Mat</i>.
</li>
<br>
<li>
Read/write access to the <i>k</i>-th diagonal in a matrix.
</li>
<br>
<li>The argument <i>k</i> is optional -- by default the main diagonal is accessed (<i>k=0</i>).</li>
<br>
<li>
For <i>k &gt; 0</i>, the <i>k</i>-th super-diagonal is accessed (top-right corner).
For <i>k &lt; 0</i>, the <i>k</i>-th sub-diagonal is accessed (bottom-left corner).
</li>
<br>
<li>
An extracted a diagonal is interpreted as a column vector.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat    X = randu&lt;mat&gt;(5,5);

colvec a = X.diag();
colvec b = X.diag(1);
colvec c = X.diag(-2);

X.diag() = randu&lt;colvec&gt;(5);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#diagvec">diagvec()</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="element"></a>
<b>element/object access via (), [] and .at()</b>
<ul>
<li>
Provide access to individual elements or objects stored in a container object
(i.e., <i>Mat</i>, <i>Col</i>, <i>Row</i>, <i>Cube</i>, <i>field</i>).<br>
                    <br>
<ul>
                    <table style="text-align: left; width: 100%;"
 border="0" cellpadding="2" cellspacing="2">
                      <tbody>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>(n)</pre>
                          </td>
                          <td style="vertical-align: top;">&nbsp;<br>
                          </td>
                          <td style="vertical-align: top;">
For colvec and rowvec, access the n-th element.
For mat, cube and field, access the n-th element/object under the assumption of a flat layout,
with column-major ordering of data (i.e. column by column).
An exception is thrown if the requested element is out of bounds.
The bounds check can be optionally disabled if the ARMA_NO_DEBUG or NDEBUG macro is defined.
                          </td>
                        </tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>[n]</pre>
                          </td>
                          <td style="vertical-align: top;"><br>
                          </td>
                          <td style="vertical-align: top;">
As for (n), but without a bounds check.
Not recommended for use unless your code has been thoroughly debugged.
                          </td>
                        </tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>(i,j)</pre>
                          </td>
                          <td style="vertical-align: top;"><br>
                          </td>
                          <td style="vertical-align: top;">
For mat and field classes, access the element/object stored at the i-th row and j-th column.
An exception is thrown if the requested element is out of bounds.
The bounds check can be optionally disabled if the ARMA_NO_DEBUG or NDEBUG macro is defined.
                          </td>
                        </tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>.at(i,j)</pre>
                          </td>
                          <td style="vertical-align: top;"><br>
                          </td>
                          <td style="vertical-align: top;">
As for (i,j), but without a bounds check.
Not recommended for use unless your code has been thoroughly debugged.
</td>
                          <td style="vertical-align: top;"><br>
                          </td>
                        </tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>(i,j,k)</pre>
                          </td>
                          <td style="vertical-align: top;"><br>
                          </td>
                          <td style="vertical-align: top;">
Cube only: access the element stored at the i-th row, j-th column and k-th slice.
An exception is thrown if the requested element is out of bounds.
The bounds check can be optionally disabled if the ARMA_NO_DEBUG or NDEBUG macro is defined.
                          </td>
                        </tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
                        <tr>
                          <td style="vertical-align: top;">
                          <pre>.at(i,j,k)</pre>
                          </td>
                          <td style="vertical-align: top;"><br>
                          </td>
                          <td style="vertical-align: top;">
As for (i,j,k), but without a bounds check.
Not recommended for use unless your code has been thoroughly debugged.</td>
                        </tr>
                      </tbody>
                    </table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);
A(9,9) = 123.0;
double x = A.at(9,9);
double y = A[99];

colvec p = randu&lt;colvec&gt;(10,1);
p(9) = 123.0;
double z = p[9];
</pre>
</ul>
</li>                  
</ul>
<br>
<hr class="greyline"><br>

<a name="fill"></a>
<b>.fill(value)</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i> classes.
</li>
<br>
<li>Sets the elements to a specified value.
The type of value must match the type of elements used by the container object
(e.g. for <i>mat</i> the type is double).
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A(5,5);
A.fill(123.0);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#ones_member">.ones()</a></li>
<li><a href="#zeros_member">.zeros()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="is_finite"></a>
<b>.is_finite()</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i> classes.
</li>
<br>
<li>Returns true if all elements of the object are finite.
</li>
<br>
<li>Returns false if at least one of the elements of the object is non-finite.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = randu&lt;mat&gt;(5,5);

B(1,1) = 0.0 / 0.0;  // create a NaN

cout &lt;&lt; A.is_finite() &lt;&lt; endl;
cout &lt;&lt; B.is_finite() &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="is_square"></a>
<b>.is_square()</b>
<ul>
<li>
Member function of the <i>Mat</i> class.
</li>
<br>
<li>Returns true if the matrix is square, i.e., number of rows is equal to the number of columns.
</li>
<br>
<li>Returns false if the matrix is not square, or the matrix has no elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = randu&lt;mat&gt;(6,7);

cout &lt;&lt; A.is_square() &lt;&lt; endl;
cout &lt;&lt; B.is_square() &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="is_vec"></a>
<b>.is_vec()</b>
<ul>
<li>
Member function of the <i>Mat</i> class.
</li>
<br>
<li>Returns true if the matrix can be interpreted as a vector (either column or row vector).
</li>
<br>
<li>Returns false if the matrix can't be interpreted as a vector, or the matrix has no elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(1,5);
mat B = randu&lt;mat&gt;(5,1);
mat C = randu&lt;mat&gt;(5,5);

cout &lt;&lt; A.is_vec() &lt;&lt; endl;
cout &lt;&lt; B.is_vec() &lt;&lt; endl;
cout &lt;&lt; C.is_vec() &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="iterators_mat"></a>
<b>iterators (matrices &amp; vectors)</b>
<ul>
<li>
STL-style iterators and associated member functions of the <i>Mat</i>, <i>Col</i> and <i>Row</i> classes.
</li>
<br>
<li>
iterator types:
<br>
<br>
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::iterator</b>
      <br>
      <b>colvec::iterator</b>
      <br>
      <b>rowvec::iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read/write access to elements;
        the elements are ordered column by column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::const_iterator</b>
      <br>
      <b>colvec::const_iterator</b>
      <br>
      <b>rowvec::const_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read-only access to elements;
        the elements are ordered column by column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::col_iterator</b>
      <br>
      <b>colvec::col_iterator</b>
      <br>
      <b>rowvec::col_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read/write access to the elements of a specific column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::const_col_iterator</b>
      <br>
      <b>colvec::const_col_iterator</b>
      <br>
      <b>rowvec::const_col_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read-only access to the elements of a specific column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::row_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        rudimentary forward iterator, for read/write access to the elements of a specific row
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>mat::const_row_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        rudimentary forward iterator, for read-only access to the elements of a specific row
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>colvec::row_iterator</b>
      <br>
      <b>rowvec::row_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read/write access to the elements of a specific row
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>colvec::const_row_iterator</b>
      <br>
      <b>rowvec::const_row_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read-only access to the elements of a specific row
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<br>
<li>
Member functions:
<br>
<br>
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>.begin()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the first element
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.end()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the <i>past-the-end</i> element
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.begin_row(</b><i>row_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the first element of the specified row
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.end_row(</b><i>row_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the <i>past-the-end</i> element of the specified row
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.begin_col(</b><i>column_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the first element of the specified column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.end_col(</b><i>column_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the <i>past-the-end</i> element of the specified column
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);


mat::iterator a = X.begin();
mat::iterator b = X.end();

for(mat::iterator i=a; i!=b; ++i)
  {
  cout &lt;&lt; *i &lt;&lt; endl;
  }


mat::col_iterator c = X.begin_col(1);  // start of column 1
mat::col_iterator d = X.end_col(3);    // end of column 3

for(mat::col_iterator i=c; i!=d; ++i)
  {
  cout &lt;&lt; *i &lt;&lt; endl;
  (*i) = 123.0;
  }
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://cplusplus.com/reference/std/iterator/">iterator at cplusplus.com</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="iterators_cube"></a>
<b>iterators (cubes)</b>
<ul>
<li>
STL-style iterators and associated member functions of the <i>Cube</i> class.
</li>
<br>
<li>
iterator types:
<br>
<br>
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>cube::iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterator, for read/write access to elements;
        the elements are ordered slice by slice;
        the elements within each slice are ordered column by column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>cube::const_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read-only access to elements
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>cube::slice_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterator, for read/write access to the elements of a particular slice;
        the elements are ordered column by column
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      &nbsp;
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>cube::const_slice_iterator</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        random access iterators, for read-only access to the elements of a particular slice
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<br>
<li>
Member functions:
<br>
<br>
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>.begin()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the first element
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.end()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the <i>past-the-end</i> element
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.begin_slice(</b><i>slice_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the first element of the specified slice
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.end_slice(</b><i>slice_number</i><b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
        provide an iterator referring to the <i>past-the-end</i> element of the specified slice
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
cube X = randu&lt;cube&gt;(2,3,4);


cube::iterator a = X.begin();
cube::iterator b = X.end();

for(cube::iterator i=a; i!=b; ++i)
  {
  cout &lt;&lt; *i &lt;&lt; endl;
  }


cube::slice_iterator c = X.begin_slice(1);  // start of slice 1
cube::slice_iterator d = X.end_slice(2);    // end of slice 2

for(cube::slice_iterator i=c; i!=d; ++i)
  {
  cout &lt;&lt; *i &lt;&lt; endl;
  (*i) = 123.0;
  }
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://cplusplus.com/reference/std/iterator/">iterator at cplusplus.com</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="memptr"></a>
<b>.memptr()</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i> classes.
</li>
<br>
<li>
Obtain a raw pointer to the memory used for storing elements. Not recommended for use unless you know what you're doing!
</li>
<br>
<li>
As soon as the size of the matrix/vector/cube is changed, the pointer is no longer valid.
</li>
<br>
<li>
Data for matrices is stored in a column-by-column order.
</li>
<br>
<li>
Data for cubes is stored in a slice-by-slice (matrix-by-matrix) order.
</li>
<br>
<li>
Examples:
<ul>
<pre>
      mat A = randu&lt;mat&gt;(5,5);
const mat B = randu&lt;mat&gt;(5,5);

      double* A_mem = A.memptr();
const double* B_mem = B.memptr();
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#iterators_mat">iterators (matrices)</a>
<li><a href="#iterators_cube">iterators (cubes)</a>
<li><a href="#adv_constructors_mat">advanced constructors (matrices)</a>
<li><a href="#adv_constructors_cube">advanced constructors (cubes)</a>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="ones_member"></a>
<b>.ones()</b>
<br><b>.ones(n_elem)</b>
<br><b>.ones(n_rows, n_cols)</b>
<br><b>.ones(n_rows, n_cols, n_slices)</b>
<ul>
<li>
Set the elements of an object to one, optionally first resizing to specified dimensions
</li>
<br>
<li>
<i>.ones()</i> and <i>.ones(n_elem)</i> are member functions of <i>Col</i> and <i>Row</i>.
</li>
<br>
<li>
<i>.ones()</i> and <i>.ones(n_rows, n_cols)</i> are member functions of <i>Mat</i>.
</li>
<br>
<li>
<i>.ones()</i> and <i>.ones(n_rows, n_cols, n_slices)</i> are member functions of <i>Cube</i>.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,10);
A.ones();      // sets all elements to one
A.ones(10,20); // sets the size to 10 rows and 20 columns
               // followed by setting all elements to one
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#ones_standalone">ones()</a> (stand alone function)</li>
<li><a href="#zeros_member">.zeros()</a></li>
<li><a href="#fill">.fill()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="operators"></a>
<b>operators: &nbsp; + &nbsp; - &nbsp; * &nbsp; / &nbsp; % &nbsp; == &nbsp; != &nbsp; &lt;= &nbsp; &gt;= &nbsp; &lt; &nbsp; &gt;</b>
<ul>
<li>
Overloaded operators for <i>mat</i>, <i>colvec</i>, <i>rowvec</i> and <i>cube</i> classes.
</li>
<br>
<li>
Meanings:
<br>
<br>
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><b>+</b></td>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp;<br>
      </td>
      <td style="vertical-align: top;">Addition of two objects.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>-</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Subtraction of one object from another or negation of an object.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>/</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Element-wise division of an object by another object or a scalar.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>*</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Matrix multiplication of two objects. Not applicable to the <i>cube</i> class unless multiplying a cube by a scalar.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>%</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><a name="schur_product"></a>Schur product: element-wise multiplication of two objects.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>==</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Element-wise equality evaluation of two objects. Generates a matrix of type <i>umat</i> with entries that indicate whether at a given position the two elements from the two objects are equal (1) or not equal (0).</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>!=</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">Element-wise non-equality evaluation of two objects.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>&gt;=</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">As for ==, but the check is for "greater than or equal to".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>&lt;=</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">As for ==, but the check is for "less than or equal to".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>&gt;</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">As for ==, but the check is for "greater than".</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>&lt;</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">As for ==, but the check is for "less than".</td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
An exception is thrown if incompatible object sizes are used.
</li>
<br>
<li>
If the +, - and % operators are chained, Armadillo will try to avoid
the generation of temporaries. No temporaries are
generated if all given objects are of the same type and size.
</li>
<br>
<li>
If the * operator is chained, Armadillo will try to find an
efficient ordering of the matrix multiplications.
</li>
<br>
<li>
<b>Caveat:</b> operators involving an equality comparison (i.e., ==, !=, &gt;=, &lt;=)
may not work as expected for floating point element types (i.e., <i>float</i>, <i>double</i>)
due to the necessarily limited precision of these types.
In other words, these operators are (in general) not recommended for matrices of type <i>mat</i> or <i>fmat</i>.
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,10);
mat B = randu&lt;mat&gt;(5,10);
mat C = randu&lt;mat&gt;(10,5);

mat P = A + B;
mat Q = A - B;
mat R = -B;
mat S = A / 123.0;
mat T = A % B;
mat U = A * C;

// V is constructed without temporaries
mat V = A + B + A + B;

imat AA = "1 2 3; 4 5 6; 7 8 9;";
imat BB = "3 2 1; 6 5 4; 9 8 7;";

// compare elements
umat ZZ = (AA >= BB);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#accu">accu()</a></li>
<li><a href="#find">find()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="print"></a>
<b>.print(header="")</b>
<br><b>.print(stream, header="")</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i>, <i>Cube</i> and <i>field</i>.
</li>
<br>
<li>
The first form prints the contents of an object to the <i>cout</i> stream, with an optional header line.
The second form prints to a user specified stream.
</li>
<br>
<li>
It's also possible print objects using the &lt;&lt; stream operator.
</li>
<br>
<li>
Elements of a field can only be printed if there is an associated <i>operator&lt;&lt;</i> function defined.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = randu&lt;mat&gt;(6,6);

A.print();

// "B =" is the optional header line
B.print("B =");

cout &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; "B =" &lt;&lt; endl &lt;&lt; B &lt;&lt; endl;
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#save_load_mat">saving &amp; loading matrices</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="print_trans"></a>
<b>.print_trans(header="")</b>
<br><b>.print_trans(stream, header="")</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i> and <i>Row</i>.
</li>
<br>
<li>
Similar to <a href="#print">.print()</a>, with the difference being that a transposed version of the object is printed.
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="raw_print"></a>
<b>.raw_print(header="")</b>
<br><b>.raw_print(stream, header="")</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i>.
</li>
<br>
<li>
Similar to the <a href="#print">.print()</a> member function.
The difference is that no formatting of the output is done -- i.e. the user can set the stream's parameters
such as precision, cell width, etc.
</li>
<br>
<li>
If the cell width is set to zero, a space is printed between the elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);

cout.precision(11);
cout.setf(ios::fixed);

A.raw_print(cout, "A =");
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="raw_print_trans"></a>
<b>.raw_print_trans(header="")</b>
<br><b>.raw_print_trans(stream, header="")</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i> and <i>Row</i>.
</li>
<br>
<li>
Similar to <a href="#raw_print">.raw_print()</a>, with the difference being that a transposed version of the object is printed.
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="reset"></a>
<b>
.reset()
</b>
<ul>
<li>
Member function of <i>Mat</i>, <i>Col</i>, <i>Row</i>, <i>Cube</i> and <i>field</i>.
</li>
<br>
<li>
Causes an object to have no elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5, 5);
A.reset();
</pre>
</ul>
</li>
<br>
<li>See also: <a href="#set_size">.set_size()</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="save_load_mat"></a>
<b>
.save(name, file_type = arma_binary)
<br>
.save(stream, file_type = arma_binary)
<br>
<br>
.load(name, file_type = auto_detect)
<br>
.load(stream, file_type = auto_detect)
<br>
<br>
.quiet_save(name, file_type = arma_binary)
<br>
.quiet_save(stream, file_type = arma_binary)
<br>
<br>
.quiet_load(name, file_type = auto_detect)
<br>
.quiet_load(stream, file_type = auto_detect)
</b>
<ul>
<li>Member functions of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i> classes.</li>
<br>
<li>Store/retrieve data in files or streams.</li>
<br>
<li>On success, save(), load(), quiet_save(), and quite_load() will return a <i>bool</i> set to <i>true</i>.</li>
<br>
<li>save() and quiet_save() will return a <i>bool</i> set to <i>false</i> if the saving process fails.</li>
<br>
<li>
load() and quiet_load() will return a <i>bool</i> set to <i>false</i> if the loading process fails.
Additionaly, the object will be reset so it has no elements.
</li>
<br>
<li>load() and save() will print error messages to the standard output if any problems are encountered.</li>
<br>
<li>quiet_load() and quiet_save() do not print any error messages.</li>
<br>
<li>
The following file formats are supported:
<br>
<br>
<ul>
                  <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
                    <tbody>
                      <tr>
                        <td style="vertical-align: top;"><b>auto_detect</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
for load() and quiet_load(): try to automatically detect the file type as one of the formats described below.
This is the default operation.
<br>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>raw_ascii</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
Numerical data stored in raw ASCII format (no header),
with the numbers separated by whitespace.
The number of columns must be the same in each row.
Data which was saved in Matlab/Octave using the <i>-ascii</i> option can be read in Armadillo, except for complex numbers.
Complex numbers are stored in standard C++ notation (a tuple surrounded by brackets: e.g. (1.23,4.56) indicates 1.24&nbsp;+&nbsp;4.56i).
Cubes are loaded as one slice.
<br>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>arma_ascii</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
Numerical data stored in human readable text format, with a simple header to speed up loading.
The header indicates the type of matrix as well as the number of rows and columns.
For cubes, the header additionally specifies the number of slices.
<br>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>arma_binary</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
Numerical data stored in machine dependent binary format, with a simple header to speed up loading.
The header indicates the type of matrix as well as the number of rows and columns.
For cubes, the header additionally specifies the number of slices.
<br>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>pgm_binary</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
Image data stored in Portable Gray Map (PGM) format.
Applicable to <i>Mat</i> only.
Saving <i>int</i>, <i>float</i> or <i>double</i> matrices is a lossy operation, as each element is copied and converted to an 8 bit representation.
As such the matrix should have values in the [0,255] interval, otherwise the resulting image may not display correctly.
<br>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>ppm_binary</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
Image data stored in Portable Pixel Map (PPM) format.
Applicable to <i>Cube</i> only.
Saving <i>int</i>, <i>float</i> or <i>double</i> matrices is a lossy operation, as each element is copied and converted to an 8 bit representation.
As such the cube/field should have values in the [0,255] interval, otherwise the resulting image may not display correctly.
                        </td>
                      </tr>
                    </tbody>
                  </table>
</ul>
</li>
<br>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);

A.save("A1.mat");  // default save format is arma_binary
A.save("A2.mat", arma_ascii);

mat B;
// automatically detect format type
B.load("A1.mat");

mat C;
// force loading in the arma_ascii format
C.load("A2.mat", arma_ascii);


// example of saving/loading using a stream
std::stringstream s;
A.save(s);

mat D;
D.load(s);


// example of testing for success
mat E;
bool status = E.load("A2.mat");

if(status == true)
  {
  cout &lt;&lt; "loaded okay" &lt;&lt; endl;
  }
else
  {
  cout &lt;&lt; "problem with loading" &lt;&lt; endl;
  }
</pre>
</ul>
</li>
<br>
<li>See also: <a href="#save_load_field">saving/loading fields</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="save_load_field"></a>
<b>
.save(name, file_type = arma_binary)
<br>
.save(stream, file_type = arma_binary)
<br>
<br>
.load(name, file_type = auto_detect)
<br>
.load(stream, file_type = auto_detect)
<br>
<br>
.quiet_save(name, file_type = arma_binary)
<br>
.quiet_save(stream, file_type = arma_binary)
<br>
<br>
.quiet_load(name, file_type = auto_detect)
<br>
.quiet_load(stream, file_type = auto_detect)
</b>
<ul>
<li>Member functions of the <i>field</i> class.</li>
<br>
<li>Store/retrieve fields in files or stream.</li>
<br>
<li>On success, save(), load(), quiet_save(), and quite_load() will return a <i>bool</i> set to <i>true</i>.</li>
<br>
<li>save() and quiet_save() will return a <i>bool</i> set to <i>false</i> if the saving process fails.</li>
<br>
<li>
load() and quiet_load() will return a <i>bool</i> set to <i>false</i> if the loading process fails.
Additionaly, the field will be reset so it has no elements.
</li>
<br>
<li>load() and save() will print error messages to the standard output if any problems are encountered.</li>
<br>
<li>quiet_load() and quiet_save() do not print any error messages.</li>
<br>
<li>
Fields with objects of type <i>std::string</i> are saved and loaded as raw text files.
The text files do not have a header.
Each string is separated by a whitespace.
load() and quiet_load() will only accept text files that have the same number of strings on each line.
The strings can have variable lengths.
</li>
<br>
<li>
Other than storing string fields as text files, the following file formats are supported:
<br>
<br>
<ul>
                  <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
                    <tbody>
                      <tr>
                        <td style="vertical-align: top;"><b>auto_detect</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
<br>
<li>
load(): try to automatically detect the field format type as one of the formats described below.
This is the default operation.
</li>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>arma_binary</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
<br>
<li>
Objects are stored in machine dependent binary format.
<li>
Default type for fields of type <i>Mat</i>, <i>Col</i> or <i>Row</i>.
</li>
<li>
Only applicable to fields of type <i>Mat</i>, <i>Col</i> or <i>Row</i>.
</li>
<br>
                        </td>
                      </tr>
                      <tr>
                        <td style="vertical-align: top;"><b>ppm_binary</b></td>
                        <td style="vertical-align: top;"><br>
                        </td>
                        <td style="vertical-align: top;">
<br>
<li>
Image data stored in Portable Pixmap Map (PPM) format.
</li>
<li>
Only applicable to fields of type <i>Mat</i>, <i>Col</i> or <i>Row</i>.
</li>
<li>
.load(): Loads the specified image and stores the red, green and blue components as three separate matrices.
The resulting field is comprised of the three matrices,
with the red, green and blue components in the first, second and third matrix, respectively.
</li>
<li>
.save(): Saves a field with exactly three matrices of equal size as an image.
It is assumed that the red, green and blue components are stored in the first, second and third matrix, respectively.
Saving <i>int</i>, <i>float</i> or <i>double</i> matrices is a lossy operation,
as each matrix element is copied and converted to an 8 bit representation.
</li>

                        </td>
                      </tr>
                    </tbody>
                  </table>
</ul>
</li>
<br>
<li>See also: <a href="#save_load_mat">saving/loading matrices and cubes</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="set_size"></a>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><b>.set_size(n_elem)</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">(member function of <i>Col</i>, <i>Row</i>, and <i>field</i>)
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>.set_size(n_rows, n_cols)</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">(member function of <i>Mat</i> and <i>field</i>)
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><b>.set_size(n_rows, n_cols, n_slices)</b></td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">(member function of <i>Cube</i>)
      </td>
    </tr>
  </tbody>
</table>
<br>  
<ul>
<li>Changes the size of an object.</li>
<br>
<li>
If the old number of elements is equal to the requested number of elements, old memory is reused.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A;
A.set_size(5,10);

colvec q;
q.set_size(100);
</pre>
</ul>
</li>
<br>
<li>See also: <a href="#reset">.reset()</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="submat"></a>
<b>submatrix views</b>
<ul>
<li>A collection of member functions of <i>Mat</i>, <i>Col</i> and <i>Row</i> classes that provide submatrix views.<br>
<br>
<ul>
.<b>row(&nbsp;</b>row_number<b>&nbsp;)</b><br>
.<b>col(&nbsp;</b>column_number<b>&nbsp;)</b><br>
.<b>rows(&nbsp;</b>first_row<b>,</b> last_row<b>&nbsp;)</b><br>
.<b>cols(&nbsp;</b>first_column<b>,</b> last_column<b>&nbsp;)</b><br>
.<b>submat(&nbsp;</b>first_row<b>,</b> first_column<b>,</b> last_row<b>,</b> last_column<b>&nbsp;)</b><br>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = zeros&lt;mat&gt;(5,10);
mat B = A.submat(0,1,2,3);
A.submat(0,1,2,3) = randu&lt;mat&gt;(3,3);
A.row(1) = randu&lt;mat&gt;(1,10);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#join">join_rows() &amp; join_cols()</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="subcube"></a>
<b>subcube views and slices</b>
<ul>
<li>A collection of member functions of the <i>Cube</i> class that provide subcube views.<br>
<br>
<ul>
.<b>slice(&nbsp;</b>slice_number&nbsp;<b>)</b><br>
.<b>slices(&nbsp;</b>first_slice<b>,</b> last_slice&nbsp;<b>)</b><br>
.<b>subcube(&nbsp;</b>first_row<b>,</b> first_column<b>,</b> first_slice<b>, </b>last_row<b>,</b> last_column<b>, </b>last_slice&nbsp;<b>)</b><br>
</ul>
</li>
<br>
<li>
An individual slice can be interpreted as a matrix (i.e. an instance of the <i>Mat</i> class).
</li>
<br>
<li>
The size of individual slices can't be changed.
</li>
<br>
<li>
Examples:
<ul>
<pre>
cube A = randu&lt;cube&gt;(2,3,4);
mat B = A.slice(1);
A.slice(0) = randu&lt;mat&gt;(2,3);
A.subcube(0,0,1,  1,1,2) = randu&lt;cube&gt;(2,2,2);
A.slice(0)(1,2) = 99.0;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="subfield"></a>
<b>subfield views</b>
<ul>
<li>A collection of member functions of the <i>field</i> class that provide subfield views.<br>
<br>
<ul>
.<b>row(&nbsp;</b>row_number&nbsp;<b>)</b><br>
.<b>col(&nbsp;</b>column_number&nbsp;<b>)</b><br>
.<b>rows(&nbsp;</b>first_row<b>,</b> last_row&nbsp;<b>)</b><br>
.<b>cols(&nbsp;</b>first_column<b>,</b> last_column&nbsp;<b>)</b><br>
.<b>subfield(&nbsp;</b>first_row<b>,</b> first_column<b>,</b> last_row<b>,</b> last_column&nbsp;<b>)</b><br>
</ul>
</li>
<br>
</ul>
<br>
<hr class="greyline"><br>

<a name="swap_rows"></a>
<b>
.swap_rows(row1, row2)
<br>.swap_cols(col1, col2)
</b>
<ul>
<li>
Member functions of <i>Mat</i>, <i>Col</i> and <i>Row</i> classes.
</li>
<br>
<li>
Swap the contents of specified rows or columns.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);
X.swap_rows(0,4);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#flip">fliplr() &amp; flipud()</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="zeros_member"></a>
<b>.zeros()</b>
<br><b>.zeros(n_elem)</b>
<br><b>.zeros(n_rows, n_cols)</b>
<br><b>.zeros(n_rows, n_cols, n_slices)</b>
<ul>
<li>
Set the elements of an object to zero, optionally first resizing to specified dimensions
</li>
<br>
<li>
<i>.zeros()</i> and <i>.zeros(n_elem)</i> are member function of <i>Col</i> and <i>Row</i>
</li>
<br>
<li>
<i>.zeros()</i> and <i>.zeros(n_rows, n_cols)</i> are member functions of <i>Mat</i>
</li>
<br>
<li>
<i>.zeros()</i> and <i>.zeros(n_rows, n_cols, n_slices)</i> are member functions of <i>Cube</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,10);
A.zeros();      // sets all elements to zero
A.zeros(10,20); // sets the size to 10 rows and 20 columns
                // followed by setting all elements to zero
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#zeros_standalone">zeros()</a> (stand alone function)</li>
<li><a href="#ones_member">.ones()</a></li>
<li><a href="#fill">.fill()</a></li>
<li><a href="#reset">.reset()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">


<hr class="greyline">
<br>
<br>
<font size=+1><b>Other Classes</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="running_stat"></a>
<b>running_stat&lt;</b><i>type</i><b>&gt;</b>
<ul>
<li>
Class for keeping statistics of a continuously sampled one dimensional process/signal.
Useful if the storage of individual samples (scalars) is not necessary or desired.
Also useful if the number of samples is not known beforehand or exceeds 
available memory.
</li>
<br>
<li>
<i>type</i> should be one of: <i>float</i>, <i>double</i>, <i><a href="#cx_float_double">cx_float</a></i>, <i><a href="#cx_float_double">cx_double</a></i>
</li>
<br>
<li>
Member functions:
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>.operator()(</b>scalar<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      update the statistics so far using the given scalar
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.mean()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the mean or average value so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.var(</b>norm_type=0<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the variance so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.stddev(</b>norm_type=0<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the standard deviation so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.min()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the minimum value so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.max()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the maximum value so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.reset()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      reset all statistics and set the number of samples to zero
      </td>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
For the .var() and .stddev() functions, the default <i>norm_type=0</i> performs normalisation using N-1
(where N is the number of samples so far),
providing the best unbiased estimator.
Using <i>norm_type=1</i> causes normalisation to be done using N, which provides the second moment around the mean.
</li>
<br>
<li>
Examples:
<ul>
<pre>
running_stat&lt;double&gt; stats;

for(u32 i=0; i&lt;10000; ++i)
  {
  double sample = double(rand())/RAND_MAX;
  stats(sample);
  }

cout &lt;&lt; "mean = " &lt;&lt; stats.mean() &lt;&lt; endl;
cout &lt;&lt; "var  = " &lt;&lt; stats.var()  &lt;&lt; endl;
cout &lt;&lt; "min  = " &lt;&lt; stats.min()  &lt;&lt; endl;
cout &lt;&lt; "max  = " &lt;&lt; stats.max()  &lt;&lt; endl;
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#stats_fns">statistics functions</a></li>
<li><a href="#running_stat_vec">running_stat_vec</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="running_stat_vec"></a>
<b>running_stat_vec&lt;</b><i>type</i><b>&gt;(calc_cov = false)</b>
<ul>
<li>
Class for keeping statistics of a continuously sampled multi-dimensional process/signal.
Useful if the storage of individual samples is not necessary or desired.
Also useful if the number of samples is not known beforehand or exceeds 
available memory.
</li>
<br>
<li>
This class is similar to <i>running_stat</i>, with the difference being that vectors are processed instead of single values.
</li>
<br>
<li>
<i>type</i> must match the element type used by the sample vectors
(i.e. it must be one of <i>float</i>, <i>double</i>, <i><a href="#cx_float_double">cx_float</a></i>, <i><a href="#cx_float_double">cx_double</a></i>)
</li>
<br>
<li>
<i>type</i> can be inferred via the use of the <i>elem_type</i> member typedef of a vector class.
For example, <i>fcolvec::elem_type</i> will be interpreted as <i>float</i>,
while <i>cx_colvec::elem_type</i> will be interpreted as <i><a href="#cx_float_double">cx_double</a></i>.
</li>
<br>
<li>
Member functions:
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">
      <b>.operator()(</b>vector<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      update the statistics so far using the given vector
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.mean()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the mean vector so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.var(</b>norm_type=0<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the vector of variances so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.stddev(</b>norm_type=0<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the vector of standard deviations so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.min()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the vector of minimum values so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.max()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the vector of maximum values so far
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">
      <b>.cov(</b>norm_type=0<b>)</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      get the covariance matrix so far
      <br>NOTE: this only works if <i>calc_cov</i> is set to <i>true</i> during the construction of the class
      </td>
    <tr>
      <td style="vertical-align: top;">
      <b>.reset()</b>
      </td>
      <td style="vertical-align: top;">&nbsp;<br>
      </td>
      <td style="vertical-align: top;">
      reset all statistics and set the number of samples to zero
      </td>
    </tr>
    </tr>
  </tbody>
</table>
</ul>
</li>
<br>
<li>
For the .var() and .stddev() functions, the default <i>norm_type=0</i> performs normalisation using N-1
(where N is the number of samples so far),
providing the best unbiased estimator.
Using <i>norm_type=1</i> causes normalisation to be done using N, which provides the second moment around the mean.
</li>
<br>
<li>
Examples:
<ul>
<pre>
running_stat_vec&lt;rowvec::elem_type&gt; stats;

rowvec sample;

for(u32 i=0; i&lt;10000; ++i)
  {
  sample = randu&lt;rowvec&gt;(5);
  stats(sample);
  }

cout &lt;&lt; "mean = " &lt;&lt; stats.mean() &lt;&lt; endl;
cout &lt;&lt; "var  = " &lt;&lt; stats.var()  &lt;&lt; endl;
cout &lt;&lt; "min  = " &lt;&lt; stats.min()  &lt;&lt; endl;
cout &lt;&lt; "max  = " &lt;&lt; stats.max()  &lt;&lt; endl;

//
//

running_stat_vec&lt;rowvec::elem_type&gt; more_stats(true);

for(u32 i=0; i&lt;20; ++i)
  {
  sample = randu&lt;rowvec&gt;(3);
  
  sample(1) -= sample(0);
  sample(2) += sample(1);
  
  more_stats(sample);
  }

cout &lt;&lt; "covariance matrix = " &lt;&lt; endl;
cout &lt;&lt; more_stats.cov() &lt;&lt; endl;

rowvec sd = more_stats.stddev();

cout &lt;&lt; "correlations = " &lt;&lt; endl;
cout &lt;&lt; more_stats.cov() / (trans(sd) * sd);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#cov">cov()</a></li>
<li><a href="#cor">cor()</a></li>
<li><a href="#running_stat">running_stat</a></li>
<li><a href="#stats_fns">statistics functions</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="wall_clock"></a>
<b>wall_clock</b>
<ul>
<li>
Simple wall clock timer class, for measuring the number of elapsed seconds between two intervals.
</li>
<br>
<li>
Examples:
<ul>
<pre>
wall_clock timer;

mat A = randu&lt;mat&gt;(4,4);
mat B = randu&lt;mat&gt;(4,4);
mat C;

timer.tic();
for(u32 i=0; i&lt;100000; ++i)
  C = A + B + A + B;

double n_secs = timer.toc();
cout &lt;&lt; "took " &lt;&lt; n_secs &lt;&lt; " seconds" &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline">

<hr class="greyline">
<br>
<br>
<font size=+1><b>Generated Vectors/Matrices</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="eye"></a>
<b>eye(n_rows, n_cols)</b>
<ul>
<li>
Generate the identity matrix (diagonal elements set to one and off-diagonal elements set to zero).
</li>
<br>
<li>
Usage:
<ul>
<li><i>matrix_type</i> X = eye&lt;<i>matrix_type</i>&gt;(n_rows, n_cols)
</li>
<li><i>n_rows</i> must be equal to <i>n_cols</i>
</li>
<li>Two arguments are used to make it explicitly clear that a square matrix is generated
</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = eye&lt;mat&gt;(5,5);
mat B = 123.0 * eye&lt;mat&gt;(5,5);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#ones_standalone">ones()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
<li><a href="#diagvec">diagvec()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="linspace"></a>
<b>linspace(start, end, N)</b>
<ul>
<li>
Generate a vector with <i>N</i> elements;
the values of the elements linearly increase from <i>start</i> upto (and including) <i>end</i>.
<br>
</li>
<br>
<li>
Usage:
<ul>
<li><i>vector_type</i> v = linspace&lt;<i>vector_type</i>&gt;(start, end, N)</li>
<li><i>matrix_type</i> X = linspace&lt;<i>matrix_type</i>&gt;(start, end, N)</li>
</ul>
</li>
<br>
<li>
If a <i>matrix_type</i> is specified, the resultant matrix will have one column.
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = linspace&lt;colvec&gt;(10, 20, 5);
rowvec r = linspace&lt;rowvec&gt;(10, 20, 5);

mat X = linspace&lt;mat&gt;(10, 20, 5);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="ones_standalone"></a>
<b>
ones(n_elem)
<br>ones(n_rows, n_cols)
<br>ones(n_rows, n_cols, n_slices)
</b>
<ul>
<li>
Generate a vector, matrix or cube with all elements set to one.
</li>
<br>
<li>
Usage:
<ul>
<li><i>vector_type</i> v = ones&lt;<i>vector_type</i>&gt;(n_elem)</li>
<li><i>matrix_type</i> X = ones&lt;<i>matrix_type</i>&gt;(n_rows, n_cols)</li>
<li><i>cube_type</i> X = ones&lt;<i>cube_type</i>&gt;(n_rows, n_cols, n_slices)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = ones&lt;mat&gt;(5,6);
mat B = 123.0 * ones&lt;mat&gt;(5,6);
cube C = 123.0 * ones&lt;cube&gt;(5,6,7);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#ones_member">.ones()</a> (member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i>)</li>
<li><a href="#eye">eye()</a>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="randu_randn"></a>
<b>randu(n_elem)</b> 
<br><b>randu(n_rows, n_cols)</b>
<br><b>randu(n_rows, n_cols, n_slices)</b>
<br>
<br><b>randn(n_elem)</b>
<br><b>randn(n_rows, n_cols)</b>
<br><b>randn(n_rows, n_cols, n_slices)</b>
<ul>
<li>
Generate a vector, matrix or cube with the elements set to random values.
</li>
<br>
<li><i>randu()</i> uses a uniform distribution in the [0,1] interval.
</li>
<br>
<li><i>randn()</i> uses a normal/Gaussian distribution with zero mean and unit variance.
</li>
<br>
<li>
Usage:
<ul>
<li><i>vector_type</i> v = randu&lt;<i>vector_type</i>&gt;(n_elem)</li>
<li><i>matrix_type</i> X = randu&lt;<i>matrix_type</i>&gt;(n_rows, n_cols)</li>
<li><i>cube_type</i> C = randu&lt;<i>cube_type</i>&gt;(n_rows, n_cols, n_slices)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = randu&lt;colvec&gt;(5);
rowvec r = randu&lt;rowvec&gt;(5);
mat    A = randu&lt;mat&gt;(5,6);
cube   C = randu&lt;cube&gt;(5,6,7);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="repmat"></a>
<b>repmat(mat A, num_copies_per_row, num_copies_per_col)</b>
<ul>
<li>Generate a matrix by replicating matrix A in a block-like fashion.</li>
<br>
<li>The generated matrix has the following size:
<ul>
rows = num_copies_per_row * A.n_rows
<br>
cols = num_copies_per_col * A.n_cols
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(2, 3);
mat B = repmat(A, 4, 5);
</pre>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="toeplitz"></a>
<b>toeplitz(A)
<br>
toeplitz(A,B)</b>
<ul>
<li>Generate a Toeplitz matrix, with the first column specified by A, and (optionally) the first row specified by B.</li>
<br>
<li>
A and B must be vectors.
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec A = randu&lt;vec&gt;(5);
mat X = toeplitz(A);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="http://mathworld.wolfram.com/ToeplitzMatrix.html">Toeplitz matrix in MathWorld</a>
<li><a href="http://en.wikipedia.org/wiki/Toeplitz_matrix">Toeplitz matrix in Wikipedia</a>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="zeros_standalone"></a>
<b>zeros(n_elem)</b>
<br><b>zeros(n_rows, n_cols)</b>
<br><b>zeros(n_rows, n_cols, n_slices)</b>
<ul>
<li>
Generate a vector, matrix or cube with the elements set to zero.
</li>
<br>
<li>
Usage:
<ul>
<li><i>vector_type</i> v = zeros&lt;<i>vector_type</i>&gt;(n_elem)</li>
<li><i>matrix_type</i> X = zeros&lt;<i>matrix_type</i>&gt;(n_rows, n_cols)</li>
<li><i>cube_type</i> X = zeros&lt;<i>cube_type</i>&gt;(n_rows, n_cols, n_slices)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = zeros&lt;colvec&gt;(5);
rowvec r = zeros&lt;rowvec&gt;(5);
mat A = zeros&lt;mat&gt;(5,6);
cube C = zeros&lt;cube&gt;(5,6,7);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#zeros_member">.zeros()</a> (member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i>)</li>
<li><a href="#ones_member">.ones()</a> (member function of <i>Mat</i>, <i>Col</i>, <i>Row</i> and <i>Cube</i>)</li>
<li><a href="#ones_standalone">ones()</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline">

<hr class="greyline">
<br>
<br>
<font size=+1><b>Functions Individually Applied to Each Element of a Matrix/Cube</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="abs"></a>
<b>abs(mat)</b>
<br><b>abs(cube)</b>
<br><b>abs(cx_mat)</b>
<br><b>abs(cx_cube)</b>
<ul>
<li>
Obtain the magnitude of each element.
</li>
<br>
<li>
Usage for non-complex matrices:
<ul>
<li><i>matrix_type</i> Y = abs(X)</li>
<li>X and Y must have the same <i>matrix_type</i></li>
</ul>
</li>
<br>
<li>
Usage for non-complex cubes:
<ul>
<li><i>cube_type</i> Y = abs(X)</li>
<li>X and Y must have the same <i>cube_type</i></li>
</ul>
</li>
<br>
<li>
Usage for complex matrices:
<ul>
<li><i>non_complex_matrix_type</i> Y = abs(X)</li>
<li>X must be a have complex matrix type, e.g., <i>cx_mat</i> or <i>cx_fmat</i></li>
<li>The type of Y must be related to the type of X,
e.g., if X has the type <i>cx_mat</i>, then the type of Y must be <i>mat</i>
</ul>
</li>
<br>
<li>
Usage for complex cubes:
<ul>
<li><i>non_complex_cube_type</i> Y = abs(X)</li>
<li>X must be a have complex cube type, e.g., <i>cx_cube</i> or <i>cx_fcube</i></li>
<li>The type of Y must be related to the type of X,
e.g., if X has the type <i>cx_cube</i>, then the type of Y must be <i>cube</i>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = abs(A); 

cx_mat X = randu&lt;cx_mat&gt;(5,5);
mat    Y = abs(X);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="eps"></a>
<b>eps(mat)</b>
<br><b>eps(cx_mat)</b>
<br><b>eps(float)</b>
<br><b>eps(double)</b>
<br><b>eps(cx_float)</b>
<br><b>eps(cx_double)</b>

<ul>
<li>
Obtain the positive distance of the absolute value of each element to the next largest representable floating point number.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);

mat X = eps(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#math_constants">math::eps()</a></li>
<li><a href="http://mathworld.wolfram.com/Floating-PointArithmetic.html">Floating-Point Arithmetic in MathWorld</a></li>
<li><a href="http://en.wikipedia.org/wiki/IEEE_754-2008">IEEE Standard for Floating-Point Arithmetic in Wikipedia</a></li>

</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="misc_fns"></a>
<b>misc functions (exp, log, log10, pow, sqrt, square, trunc_exp, trunc_log)</b>
<br>
<ul>
<li>
Apply a function to each element.
</li>
<br>
<li>
Usage:
<ul>
<li>
<i>matrix_type</i> Y = misc_fn(X)
</li>
<li>
<i>cube_type</i> Y = misc_fn(X)
</li>
<li>
X and Y must have the same <i>matrix_type/cube_type</i>
</li>
<li>
misc_fn(X) is one of:
<ul>

<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr>
    <td style="vertical-align: top;">
       exp(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-e exponential of each element
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       log(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      natural log of each element
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       log10(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-10 log of each element
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       pow(X, p)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      raise each element to the power of p
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       sqrt(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      square root of each element
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      square(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      square of each element
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      trunc_exp(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base-e exponential of each element,
      truncated to avoid infinity
      (only for elements with type <i>float</i> or <i>double</i>)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      trunc_log(X)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      natural log of each element,
      truncated to avoid &plusmn;infinity
      (only for elements with type <i>float</i> or <i>double</i>)
    </td>
  </tr>
</tbody>
</table>


</ul>
</li>

</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);
mat Y = exp(X);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="trig_fns"></a>
<b>trigonometric functions (cos, sin, tan, ...)</b>
<ul>
<li>
Apply a trigonometric function to each element.
</li>
<br>
<li>
Usage:
<ul>
<li>
<i>matrix_type</i> Y = trig_fn(X)
</li>
<li>
<i>cube_type</i> Y = trig_fn(X)
</li>
<li>
X and Y must have the same <i>matrix_type/cube_type</i>
</li>
<li>
trig_fn is one of:
<ul>
<li>
cos family: <i>cos</i>, <i>acos</i>, <i>cosh</i>, <i>acosh</i>
</li>
<li>
sin family: <i>sin</i>, <i>asin</i>, <i>sinh</i>, <i>asinh</i>
</li>
<li>
tan family: <i>tan</i>, <i>atan</i>, <i>tanh</i>, <i>atanh</i>
</li>
</ul>
</li>

</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);
mat Y = cos(X);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline">

<hr class="greyline">
<br>
<br>
<font size=+1><b>Scalar Valued Functions of Vectors/Matrices/Cubes</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="accu"></a>
<b>accu(mat)</b>
<br><b>accu(cube)</b>
<ul>
<li>
Accumulate (sum) all elements
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
double x = accu(A);

mat B = randu&lt;mat&gt;(5,5);
double y = accu(A % B);

// operator % performs element-wise multiplication,
// hence accu(A % B) is a "multiply-and-accumulate"
// operation
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#sum">sum()</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="as_scalar"></a>
<b>as_scalar(expression)</b>
<ul>
<li>
Evaluate an expression that results in a 1x1 matrix,
followed by converting the 1x1 matrix to a pure scalar.
</li>
<br>
<li>
If a binary or trinary expression is given (i.e. 2 or 3 terms),
the function will try to exploit the fact that the result is a 1x1 matrix
by using optimised expression evaluations.
</li>
<br>
<li>
Examples:
<ul>
<pre>
rowvec r = randu&lt;rowvec&gt;(5);
colvec q = randu&lt;colvec&gt;(5);
mat    X = randu&lt;mat&gt;(5,5);

// examples of some expressions
// for which optimised implementations exist

double a = as_scalar(r*q);
double b = as_scalar(r*X*q);
double c = as_scalar(r*diagmat(X)*q);
double d = as_scalar(r*inv(diagmat(X))*q);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#accu">accu()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
<li><a href="#dot">dot()</a></li>
<li><a href="#norm">norm()</a></li>
<li><a href="#reshape">reshape()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>
                  
<a name="det"></a>
<b>det(mat)</b>
<ul>
<li>
Determinant of a square matrix.
</li>
<br>
<li>
An exception is thrown if the given matrix is not square.
</li>
<br>
<li>
<b>Caveat</b>: for large matrices you may want to use <a href="#log_det">log_det()</a> instead.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
double x = det(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="http://mathworld.wolfram.com/Determinant.html">determinant in MathWorld</a></li>
<li><a href="#log_det">log_det()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="dot"></a>
<b>dot(A, B)</b>
<br><b>norm_dot(A, B)</b>
<ul>
<li>
<i>dot(A,B):</i> dot product of A and B, under the assumption that A and B are vectors with the same number of elements
</li>
<br>
<li>
<i>norm_dot(A,B)</i>: normalised version of <i>dot(A,B)</i>
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec a = randu&lt;colvec&gt;(10);
colvec b = randu&lt;colvec&gt;(10);

double x = dot(a,b);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#cross">cross()</a></li>
<li><a href="#norm">norm()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="log_det"></a>
<b>log_det(val, sign, mat)</b>
<ul>
<li>
Log determinant of a square matrix, such that the determinant is equal to exp(val)*sign.
</li>
<br>
<li>
An exception is thrown if the given matrix is not square.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);

double val;
double sign;

log_det(val, sign, A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="http://mathworld.wolfram.com/Determinant.html">determinant in MathWorld</a></li>
<li><a href="#det">det()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="norm"></a>
<b>
norm(X, p)
</b>
<ul>
<li>
Compute the <i>p</i>-norm of X, under the assumption that X is a vector.
</li>
<br>
<li>
<i>p</i> is an integer &gt;= 1, or one of: "inf", "-inf".
</li>
<br>
<li>
For <i>p</i> = "inf", the maximum norm is computed, while for <i>p</i> = "-inf", the minimum norm is calculated.
</li>
<br>
<li>
To obtain the zero norm or Hamming norm (i.e. the number of non-zero elements),
you may want to use this expression: <a href="#accu">accu</a>(X != 0).
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = randu&lt;colvec&gt;(5);
double x = norm(q, 2);
double y = norm(q, "inf");
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#dot">dot()</a></li>
<li><a href="http://en.wikipedia.org/wiki/Norm_(mathematics)">Norm in Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/VectorNorm.html">Vector Norm in MathWorld</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="rank"></a>
<b>rank(mat)</b>
<br><b>rank(cx_mat)</b>

<ul>
<li>Returns the rank of a matrix.</li><br>
<li>The computation is based on singular value decomposition.</li><br>
<li>Any singular values less than default tolerance are treated as zero.</li><br>
<li>For a matrix A with m rows and n columns the default tolerance is max(m,n)*norm(A)*math::eps().</li><br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);

u32 r = rank(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#math_constants">math::eps()</a></li>
<li><a href="http://mathworld.wolfram.com/MatrixRank.html">Matrix Rank in MathWorld</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="trace"></a>
<b>trace(mat)</b>
<ul>
<li>
Sum of the diagonal elements of a square matrix.
</li>
<br>
<li>
An exception is thrown if the given matrix is not square.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
double x = trace(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#diag">.diag()</a></li>
<li><a href="#diagvec">diagvec()</a></li>
<li><a href="#sum">sum()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">

<hr class="greyline">
<br>
<br>
<font size=+1><b>Scalar/Vector Valued Functions of Vectors/Matrices</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="diagvec"></a>
<b>diagvec(mat, k=0)</b>
<ul>
<li>
Extract the <i>k</i>-th diagonal from a matrix.
</li>
<br>
<li>
The argument <i>k</i> is optional -- by default the main diagonal is extracted (<i>k=0</i>).
</li>
<br>
<li>
For <i>k &gt; 0</i>, the <i>k</i>-th super-diagonal is extracted (top-right corner).
For <i>k &lt; 0</i>, the <i>k</i>-th sub-diagonal is extracted (bottom-left corner).
</li>
<br>
<li>
An extracted a diagonal is interpreted as a column vector.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);

colvec d = diagvec(A);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#diag">.diag()</a></li>
<li><a href="#diagmat">diagmat()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="min_and_max"></a>
<b>min(mat, dim=0)</b>
<br><b>min(rowvec)</b>
<br><b>min(colvec)</b>
<br>
<br><b>max(mat, dim=0)</b>
<br><b>max(rowvec)</b>
<br><b>max(colvec)</b>
<ul>
<li>
For a matrix argument, return the minimum/maximum value for each column (dim=0), or each row (dim=1).
</li>
<br>
<li>
For a vector argument, return the minimum/maximum value.
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = randu&lt;colvec&gt;(10,1);
double x = max(q);

mat A = randu&lt;mat&gt;(10,10);
rowvec b = max(A);

// same result as max(A)
// the 0 explicitly indicates
// "traverse across rows"
rowvec c = max(A,0); 

// the 1 explicitly indicates
// "traverse across columns"
colvec d = max(A,1);

// find the overall maximum value
double y = max(max(A));
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="prod"></a>
<b>prod(mat, dim=0)</b>
<br><b>prod(rowvec)</b>
<br><b>prod(colvec)</b>
<ul>
<li>
For a matrix argument, return the product of elements in each column (dim=0), or each row (dim=1).
</li>
<br>
<li>
For a vector argument, return the product of all elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = randu&lt;colvec&gt;(10,1);
double x = prod(q);

mat A = randu&lt;mat&gt;(10,10);
rowvec b = prod(A);

// same result as prod(A)
// the 0 explicitly indicates
// "traverse across rows"
rowvec c = prod(A,0);

// the 1 explicitly indicates
// "traverse across columns"
colvec d = prod(A,1);

// find the overall product
double y = prod(prod(A));
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#schur_product">Schur product</a>
</li>
</ul>
<br>
<hr class="greyline"><br>


<a name="sum"></a>
<b>sum(mat, dim=0)</b>
<br><b>sum(rowvec)</b>
<br><b>sum(colvec)</b>
<ul>
<li>
For a matrix argument, return the sum of elements in each column (dim=0), or each row (dim=1).
</li>
<br>
<li>
For a vector argument, return the sum of all elements.
</li>
<br>
<li>
To get a sum of all the elements regardless of the argument type (i.e. matrix or vector),
you may wish to use <a href="#accu">accu()</a> instead.
</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec q = randu&lt;colvec&gt;(10,1);
double x = sum(q);

mat A = randu&lt;mat&gt;(10,10);
rowvec b = sum(A);

// same result as sum(A)
// the 0 explicitly indicates
// "traverse across rows"
rowvec c = sum(A,0);

// the 1 explicitly indicates
// "traverse across columns"
colvec d = sum(A,1);

// find the overall sum
double y = sum(sum(A));
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#accu">accu()</a></li>
<li><a href="#trace">trace()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>


<a name="stats_fns"></a>
<b>statistics: mean, median, stddev, var</b>

<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr>
    <td style="vertical-align: top;">
       <b>mean(mat, dim=0)</b>
       <br><b>mean(colvec)</b>
       <br><b>mean(rowvec)</b>
       <br>
       <br>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      mean (average value)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       <b>median(mat, dim=0)</b>
       <br><b>median(colvec)</b>
       <br><b>median(rowvec)</b>
       <br>
       <br>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      median
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       <b>stddev(mat, norm_type=0, dim=0)</b>
       <br><b>stddev(colvec, norm_type=0)</b>
       <br><b>stddev(rowvec, norm_type=0)</b>
       <br>
       <br>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      standard deviation
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
       <b>var(mat, norm_type=0, dim=0)</b>
       <br><b>var(colvec, norm_type=0)</b>
       <br><b>var(rowvec, norm_type=0)</b>
       <br>
       <br>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      variance
    </td>
  </tr>
</tbody>
</table>
<br>
<li>
For a matrix argument, find a particular statistic for each column (<i>dim=0</i>), or each row (<i>dim=1</i>)
</li>
<br>
<li>
For a vector argument, return a particular statistic calculated using all the elements of the vector.
</li>
<br>
<li>
For the var() and stddev() functions, the default <i>norm_type=0</i> performs normalisation using N-1 (where N is the number of samples),
providing the best unbiased estimator.
Using <i>norm_type=1</i> causes normalisation to be done using N, which provides the second moment around the mean.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A    = randu&lt;mat&gt;(5,5);
mat B    = mean(A);
mat C    = var(A);
double m = mean(mean(A));

colvec q = randu&lt;colvec&gt;(5);
double v = var(q);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#cov">cov()</a></li>
<li><a href="#cor">cor()</a></li>
<li><a href="#running_stat">running_stat</a></li>
<li><a href="#running_stat_vec">running_stat_vec</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline">

<hr class="greyline">
<br>
<br>
<font size=+1><b>Vector/Matrix/Cube Valued Functions of Vectors/Matrices/Cubes</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="conv"></a>
<b>
C = conv(A, B)
</b>
<ul>
<li>
Convolution of vectors A and B.
</li>
<br>
<li>
If A and B are polynomial coefficient vectors, convolving them is equivalent to multiplying the two polynomials.
</li>
<br>
<li>
The convolution operation is also equivalent to FIR filtering.
</li>
<br>
<li>
The orientation of the result vector is the same as the orientation of A (i.e. column or row vector).
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec A = randu&lt;vec&gt;(128) - 0.5;
vec B = randu&lt;vec&gt;(128) - 0.5;

vec C = conv(A,B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="http://mathworld.wolfram.com/Convolution.html">Convolution in MathWorld</a></li>
<li><a href="http://en.wikipedia.org/wiki/Convolution">Convolution in Wikipedia</a></li>
<li><a href="http://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter in Wikipedia</a></li>
<li><a href="#cor">cor()</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="conv_to"></a>
<b>
conv_to&lt;<i>type</i>&gt;::from(X)
</b>
<ul>
<li>
A form of casting
</li>
<br>
<li>
Convert between matrix/vector types (e.g. <i>mat</i> to <i>fmat</i>), as well as cube types (e.g. <i>cube</i> to <i>fcube</i>).
</li>
<br>
<li>
Conversion between <i>std::vector</i> and Armadillo matrices/vectors is also possible.
</li>
<br>
<li>
Conversion of a <i>mat</i> object into <i>colvec</i>, <i>rowvec</i> or <i>std::vector</i> is possible if the object can be interpreted as a vector.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat  A = randu&lt;mat&gt;(5,5);
fmat B = conv_to&lt;fmat&gt;::from(A);

typedef std::vector&lt;double&gt; stdvec;

stdvec x(3);
x[0] = 0.0; x[1] = 1.0;  x[2] = 2.0;

colvec y = conv_to&lt; colvec &gt;::from(x);
stdvec z = conv_to&lt; stdvec &gt;::from(y); 
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#reshape">reshape()</a></li>
<li><a href="#adv_constructors_mat">advanced constructors (matrices)</a></li>
<li><a href="#adv_constructors_cube">advanced constructors (cubes)</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="conj"></a>
<b>conj(cx_mat)</b>
<br><b>conj(cx_cube)</b>
<ul>
<li>
Obtain the complex conjugate of each element in a complex matrix/cube.
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat X = randu&lt;cx_mat&gt;(5,5);
cx_mat Y = conj(X);
</pre>
</ul>
</li>
<br>
<li>See also: <a href="#htrans">htrans()</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="cor"></a>
<b>cor(mat, mat, norm_type=0)</b>
<br><b>cor(rowvec, rowvec, norm_type=0)</b>
<br><b>cor(colvec, colvec, norm_type=0)</b>
<br><b>cor(colvec, rowvec, norm_type=0)</b>
<br><b>cor(rowvec, colvec, norm_type=0)</b>
<br>
<br><b>cor(mat, norm_type=0)</b>
<br><b>cor(rowvec, norm_type=0)</b>
<br><b>cor(colvec, norm_type=0)</b>
<ul>
<li>
For two matrix arguments <i>X</i> and <i>Y</i>,
if each row of <i>X</i> and <i>Y</i>  is an observation and each column is a variable,
the <i>(i,j)</i>-th entry of <i>cor(X,Y)</i> is the correlation coefficient between the <i>i</i>-th variable in <i>X</i> and the <i>j</i>-th variable in <i>Y</i>.
</li>
<br>
<li>
For vector arguments, the type of vector is ignored and each element in the vector is treated as an observation. 
</li>
<br>
<li>
For matrices, <i>X</i> and <i>Y</i> must have the same dimensions.
</li>
<br>
<li>
For vectors, <i>X</i> and <i>Y</i> must have the same number of elements.
</li>
<br>
<li>
<i>cor(X)</i> is equivalent to <i>cor(X, X)</i>, also called autocorrelation.
</li>
<br>
<li>
The default <i>norm_type=0</i> performs normalisation of the correlation matrix using N-1 (where N is the number of observations).
Using <i>norm_type=1</i> causes normalisation to be done using N.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(4,5);
mat Y = randu&lt;mat&gt;(4,5);

mat R = cor(X,Y);
</pre>
</ul>
</li>
<br>
<li>
See also: 
<ul>
<li><a href="http://mathworld.wolfram.com/Correlation.html">Correlation in MathWorld</a></li>
<li><a href="http://mathworld.wolfram.com/Autocorrelation.html">Autocorrelation in MathWorld</a></li>
<li><a href="#cov">cov()</a></li>
<li><a href="#conv">conv()</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="cov"></a>
<b>cov(mat, mat, norm_type=0)</b>
<br><b>cov(rowvec, rowvec, norm_type=0)</b>
<br><b>cov(colvec, colvec, norm_type=0)</b>
<br><b>cov(colvec, rowvec, norm_type=0)</b>
<br><b>cov(rowvec, colvec, norm_type=0)</b>
<br>
<br><b>cov(mat, norm_type=0)</b>
<br><b>cov(rowvec, norm_type=0)</b>
<br><b>cov(colvec, norm_type=0)</b>
<ul>
<li>
For two matrix arguments <i>X</i> and <i>Y</i>,
if each row of <i>X</i> and <i>Y</i>  is an observation and each column is a variable,
the <i>(i,j)</i>-th entry of <i>cov(X,Y)</i> is the covariance between the <i>i</i>-th variable in <i>X</i> and the <i>j</i>-th variable in <i>Y</i>.
</li>
<br>
<li>
For vector arguments, the type of vector is ignored and each element in the vector is treated as an observation. 
</li>
<br>
<li>
For matrices, <i>X</i> and <i>Y</i> must have the same dimensions.
</li>
<br>
<li>
For vectors, <i>X</i> and <i>Y</i> must have the same number of elements.
</li>
<br>
<li>
<i>cov(X)</i> is equivalent to <i>cov(X, X)</i>.
</li>
<br>
<li>
The default <i>norm_type=0</i> performs normalisation using N-1 (where N is the number of observations),
providing the best unbiased estimation of the covariance matrix (if the observations are from a normal distribution).
Using <i>norm_type=1</i> causes normalisation to be done using N, which provides the second moment matrix of the observations about their mean.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(4,5);
mat Y = randu&lt;mat&gt;(4,5);

mat C = cov(X,Y);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#running_stat_vec">running_stat_vec</a></li>
<li><a href="#stats_fns">statistics functions</a></li>
<li><a href="http://mathworld.wolfram.com/Covariance.html">Covariance in MathWorld</a></li>
<li><a href="#cor">cor()</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="cross"></a>
<b>cross(A, B)</b>
<ul>
<li>
Calculate the cross product between A and B, under the assumption that A and B are 3 dimensional vectors.
</li>
<br>
<li>
Examples:
<ul>
<pre>
vec a = randu&lt;vec&gt;(3);
vec b = randu&lt;vec&gt;(3);

vec c = cross(a,b);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#dot">dot()</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cross_product">Cross product in Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/CrossProduct.html">Cross product in MathWorld</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="diagmat"></a>
<b>diagmat(mat)</b>
<br><b>diagmat(rowvec)</b>
<br><b>diagmat(colvec)</b>
<ul>
<li>
Interpret a matrix or vector as a diagonal matrix.
</li>
<br>
<li>
For <i>mat</i>, given matrix must be square.  The main diagonal is copied and all other elements in the generated matrix are set to zero.
</li>
<br>
<li>
For <i>colvec</i> and <i>rowvec</i>, elements of the vector are placed on the main diagonal in the generated matrix and all other elements are set to zero.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = diagmat(A);
mat C = A*diagmat(A);

rowvec q = randu&lt;rowvec&gt;(5);
colvec r = randu&lt;colvec&gt;(5);
mat X = diagmat(q)*diagmat(r);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#diagvec">diagvec()</a>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="find"></a>
<b>find(X, k=0, s="first")</b>
<ul>
<li>
Return a column vector (with elements of type u32) of the indices of non-zero elements of <i>X</i>.
</li>
<br>
<li>
<i>X</i> is intepreted as a vector, with column-by-column ordering of the elements of <i>X</i>.
</li>
<br>
<li>Relational operators can be used instead of <i>X</i>, e.g.&nbsp;<i>A&nbsp;&gt;&nbsp;0.5</i>
</li>
<br>
<li>If <i>k=0</i> (default), return the indices of all non-zero elements, otherwise return at most <i>k</i> of their indices.</li>
<br>
<li>If <i>s="first"</i> (default), return at most the first <i>k</i> indices of the non-zero elements. 
</li>
<br>
<li>If <i>s="last"</i>, return at most the last <i>k</i> indices of the non-zero elements. 
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat  A  = randu&lt;mat&gt;(5,5);
mat  B  = randu&lt;mat&gt;(5,5);
uvec q1 = find(A &gt; B);
uvec q2 = find(A &gt; 0.5);
uvec q3 = find(A &gt; 0.5, 3, "last");
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#sort_index">sort_index()</a>
</li>
<br>
</ul>
<hr class="greyline">
<br>

<a name="flip"></a>
<b>fliplr(mat)</b>
<br><b>flipud(mat)</b>
<ul>
<li>
fliplr: generate a copy of the input matrix, with the order of the columns reversed
</li>
<br>
<li>
flipud: generate a copy of the input matrix, with the order of the rows reversed
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);

mat B = fliplr(A);
mat C = flipud(A);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#swap_rows">.swap_rows() &amp; .swap_cols()</a> (member functions of <i>Mat</i>, <i>Col</i> and <i>Row</i> classes)
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="htrans"></a>
<b>htrans(cx_mat)</b>
<br><b>htrans(cx_colvec)</b>
<br><b>htrans(cx_rowvec)</b>
<ul>
<li>
Hermitian transpose.
</li>
<br>
<li>
This operation is equivalent to taking the transpose and then taking the complex conjugate of each element.
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat A = randu&lt;cx_mat&gt;(5,10);
cx_mat B = htrans(A);
</pre>
</ul>
</li>
<br>
<li>See also:
<ul>
<li><a href="#trans">trans()</a></li>
<li><a href="#conj">conj()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="imag_real"></a>
<b>imag(cx_mat)</b>
<br><b>imag(cx_cube)</b>
<br>
<br><b>real(cx_mat)</b>
<br><b>real(cx_cube)</b>
<ul>
<li>
Extract the imaginary/real part of a complex matrix/cube.
</li>
<br>
<li>
Examples:
<ul>
<pre>
cx_mat A = randu&lt;cx_mat&gt;(5,5);

mat B = imag(A);
mat C = real(A);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="join"></a>
<b>join_rows(A,B)</b>
<br><b>join_cols(A,B)</b>
<ul>
<li>
join_rows:
for two input matrices A and B, append each row of B to its respective row of A, provided that A and B have the same number of rows.
</li>
<br>
<li>
join_cols: for two input matrices A and B, append each column of B to its respective column of A, provided that A and B have the same number of columns.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);
mat B = randu&lt;mat&gt;(4,6);
mat C = randu&lt;mat&gt;(6,5);

mat X = join_rows(A,B);
mat Y = join_cols(A,C);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#submat">submatrix views</a>
</li>
</br>
</ul>
<hr class="greyline"><br>

<a name="kron"></a>
<b>kron(mat,mat)</b>
<br><b>kron(cx_mat,cx_mat)</b>
<br><b>kron(mat,cx_mat)</b>
<br><b>kron(cx_mat,mat)</b>

<ul>
<li>Kronecker tensor product.</li>
<br>
<li>Using matrix A (with n rows and p columns) and matrix B (with m rows and q columns),
kron(A,B) returns a matrix (with nm rows and pq columns) which denotes the tensor product of A and B.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);
mat B = randu&lt;mat&gt;(5,4);

mat K = kron(A,B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="http://mathworld.wolfram.com/KroneckerProduct.html">Kronecker Product in MathWorld</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="reshape"></a>
<b>reshape(mat, n_rows, n_cols, dim=0)</b>
<br><b>reshape(cube, n_rows, n_cols, n_slices, dim=0)</b>
<ul>
<li>
Return a matrix/cube sized according to given size specifications,
whose elements are taken from the given matrix/cube, either column-wise (dim=0) or row-wise (dim=1).
</li>
<br>
<li>
For matrices, the number of elements in the given matrix must be equal to <i>n_rows * n_cols</i>.
</li>
<br>
<li>
For cubes, the number of elements in the given cube must be equal to <i>n_rows * n_cols * n_slices</i>.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10, 5);
mat B = reshape(A, 5, 10);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#as_scalar">as_scalar()</a></li>
<li><a href="#conv_to">conv_to()</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="shuffle"></a>
<b>shuffle(mat, dim=0)</b>
<br><b>shuffle(rowvec, dim=0)</b>
<br><b>shuffle(colvec, dim=0)</b>
<ul>
<br>
<li>
Shuffle the rows (dim=0) or columns (dim=1) of a matrix or vector.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);
mat B = shuffle(A);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="sort"></a>
<b>sort(mat, sort_type=0, dim=0)</b>
<br><b>sort(rowvec, sort_type=0)</b>
<br><b>sort(colvec, sort_type=0)</b>
<ul>
<li>For a matrix argument, return a matrix with the elements of the input matrix sorted in each column (<i>dim=0</i>), or each row (<i>dim=1</i>)</li>
<br>
<li><i>sort_type=0</i> (default) indicates an ascending sort</li>
<br>
<li><i>sort_type=1</i> indicates a descending sort</li>
<br>
<li>For a vector argument, return a vector which is a sorted version of the input vector</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);
mat B = sort(A);
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="sort_index"></a>
<b>sort_index(colvec, sort_type=0)</b>
<br><b>sort_index(rowvec, sort_type=0)</b>
<ul>
<li>Sort the given vector and return a vector (with elements of type u32) which describes the sorted order
(i.e. it contains the indices of the given vector's elements).
</li>
<br>
<li><i>sort_type=0</i> (default) indicates an ascending sort</li>
<br>
<li><i>sort_type=1</i> indicates a descending sort</li>
<br>
<li>
Examples:
<ul>
<pre>
colvec  q       = randu&lt;colvec&gt;(10);
ucolvec indices = sort_index(q);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="#find">find()</a>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="trans"></a>
<b>trans(mat)</b>
<br><b>trans(colvec)</b>
<br><b>trans(rowvec)</b>
<ul>
<li>
Matrix transpose.
</li>
<br>
<li>
<b>Caveat</b>: for complex matrices this function does not take the conjugate of the elements -- you may wish to use <a href="#htrans">htrans()</a> instead.
</li>
<br>
<li>
Examples:
<ul>
<pre>mat A = randu&lt;mat&gt;(5,10);
mat B = trans(A);
</pre>
</ul>
</li>
<br>
<li>See also: <a href="#htrans">htrans()</a></li>
</ul>
<br>
<hr class="greyline">


<hr class="greyline">
<br>
<br>
<font size=+1><b>Decompositions and Related Functions</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="chol"></a>
<b>R = chol(X)</b>
<br><b>chol(R, X)</b>
<ul>
<li>
Cholesky decomposition of <i>X</i>, such that <i>trans(R)*R = X</i>.
</li>
<br>
<li>
X must be a symmetric, positive-definite matrix.
</li>
<br>
<li>
If the decomposition fails:
<ul>
<li>the single argument version will output a matrix with no elements</li>
<li>the two argument version sets <i>R</i> to have no elements and outputs a bool set to <i>false</i></li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);
mat Y = trans(X)*X;

mat R = chol(Y);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://mathworld.wolfram.com/CholeskyDecomposition.html">Cholesky decomposition in MathWorld</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="eig_sym"></a>
<b>eig_sym(colvec eigval, mat X)</b>
<br><b>eig_sym(colvec eigval, cx_mat X)</b>
<br>
<br><b>colvec eigval = eig_sym(mat X)</b>
<br><b>colvec eigval = eig_sym(cx_mat X)</b>
<br>
<br><b>eig_sym(colvec eigval, mat eigvec, mat X)</b>
<br><b>eig_sym(colvec eigval, cx_mat eigvec, cx_mat X)</b>
<ul>
<li>
Eigen decomposition of symmetric/hermitian matrix <i>X</i>.</li>
<br>
<li>The eigenvalues and corresponding eigenvectors are stored in <i>eigval</i> and <i>eigvec</i>, respectively.</li>
<br>
<li>
The eigenvalues are not guaranteed to be ordered.
</li>
<br>
<li>
An exception is thrown if <i>X</i> is not square.
</li>
<br>
<li>
There is currently no check whether <i>X</i> is symmetric.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);
mat B = trans(A)*A;  // generate a symmetric matrix

vec eigval;
mat eigvec;

eig_sym(eigval, eigvec, B);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#princomp_cov">princomp_cov()</a></li>
<li><a href="http://mathworld.wolfram.com/EigenDecomposition.html">eigen decomposition in MathWorld</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="eig_gen"></a>
<b>eig_gen(cx_colvec eigval, cx_mat eigvec, mat X, side='r')</b>
<br>
<b>eig_gen(cx_colvec eigval, cx_mat eigvec, cx_mat X, side='r')</b>
<br>
<br>
<b>eig_gen(cx_colvec eigval, mat l_eigvec, mat r_eigvec, mat X)</b>
<br>
<b>eig_gen(cx_colvec eigval, cx_mat l_eigvec, cx_mat r_eigvec, cx_mat X)</b>
<ul>
<li>
Eigen decomposition of general (non-symmetric/non-hermitian) square matrix <i>X</i>.</li>
<br>
<li>The eigenvalues and corresponding eigenvectors are stored in <i>eigval</i> and <i>eigvec</i>, respectively.</li>
<br>
<li>For the first two forms, <i>side='r'</i> (default) specifies that right eigenvectors are computed, while <i>side='l'</i> specifies that left eigenvectors are computed.</li>
<br>
<li>For the last two forms, both left and right eigenvectors are computed.</li>
<br>
<li>
The eigenvalues are not guaranteed to be ordered.
</li>
<br>
<li>
An exception is thrown if <i>X</i> is not square.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);

cx_vec eigval;
cx_mat eigvec;

eig_gen(eigval, eigvec, A);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://mathworld.wolfram.com/EigenDecomposition.html">eigen decomposition in MathWorld</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="inv"></a>
<b>inv(mat)</b>
<ul>
<li>
Inverse of a square matrix.
</li>
<br>
<li>
An exception is thrown if the given matrix is not square.
</li>
<br>
<li>
If the matrix appears to be singular, a warning message is printed and the output matrix has no elements.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
mat B = inv(A);

// Diagonal elements in C are set to the
// reciprocal of the corresponding elements in A.
// Off-diagonal elements in C are set to zero.
mat C = inv(diagmat(A));
</pre>
</ul>
</li>
<br>
<li>
See also: 
<ul>
<li><a href="#pinv">pinv()</a>
<li><a href="#solve">solve()</a></li>
<li><a href="http://mathworld.wolfram.com/MatrixInverse.html">matrix inverse in MathWorld</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>



<a name="lu"></a>
<b>lu(mat L, mat U, mat X)</b>
<br>
<b>lu(mat L, mat U, mat P, mat X)</b>
<ul>
<li>
Lower-upper decomposition (with partial pivoting) of matrix <i>X</i>.
</li>
<br>
<li>
<i>L</i> is a lower-triangular matrix, <i>U</i> is an upper-triangular matrix and <i>P</i> is an optional permutation matrix.
</li>
<br>
<li>
The second form provides the permutation matrix <i>P</i>, such that <i>P*X = L*U</i> and <i>X = trans(P)*L*U</i>.
</li>
<br>
<li>
The second form is currently considerably slower than the first form.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);

mat L;
mat U;
mat P;

lu(L, U, P, A);

mat B = trans(P)*L*U;
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://en.wikipedia.org/wiki/LU_decomposition">LU decomposition in Wikipedia</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="pinv"></a>
<b>pinv(mat A, tol = 0)</b>
<br><b>pinv(cx_mat A, tol = 0)</b>

<ul>
<li>Moore-Penrose pseudo-inverse of matrix <i>A</i>.</li><br>
<li>The computation is based on singular value decomposition (SVD).
If the SVD fails, an error message is printed and the output matrix has no elements.</li><br>
<li>Any singular values less than tol are treated as zero.</li><br>
<li>For matrix A with m rows and n columns, the default tolerance is max(m,n)*norm(A)*math::eps(),
where math::eps() denotes the difference between 1 and the least value greater than 1 that is representable.</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(4,5);
mat B = pinv(A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#inv">inv()</a></li>
<li><a href="#math_constants">math::eps()</a></li>
<li><a href="http://mathworld.wolfram.com/Pseudoinverse.html">Pseudoinverse in MathWorld</a></li>
<li><a href="http://mathworld.wolfram.com/Moore-PenroseMatrixInverse.html">Moore-Penrose Matrix Inverse in MathWorld</a></li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="princomp"></a>
<b>mat coeff = princomp(mat X)</b>
<br><b>cx_mat coeff = princomp(cx_mat X)</b><br>

<br><b>princomp(mat coeff, mat score, mat X)</b>
<br><b>princomp(cx_mat coeff, cx_mat score, cx_mat X)</b><br>

<br><b>princomp(mat coeff, mat score, colvec latent, mat X)</b>
<br><b>princomp(cx_mat coeff, cx_mat score, colvec latent, cx_mat X)</b><br>

<br><b>princomp(mat coeff, mat score, colvec latent, colvec tsquared, mat X)</b>
<br><b>princomp(cx_mat coeff, cx_mat score, colvec latent, cx_colvec tsquared, cx_mat X)</b><br>
<br>
<ul>
<li>Principal component analysis of matrix <i>X</i>.</li><br>
<li>Each row of <i>X</i> is an observation and each column is a variable.</li><br>
<li><i>coeff</i>: principal component coefficients.</li><br>
<li><i>score</i>: projected data.</li><br>
<li><i>latent</i>: eigenvalues of the covariance matrix of <i>X</i>.</li><br>
<li><i>tsquared</i>: Hotteling's statistic for each sample.</li><br>
<li>The computation is based on singular value decomposition (SVD).
If the SVD fails, an error message is printed and the output matrices &amp; vectors have no elements.</li><br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,4);

mat coeff;
mat score;
vec latent;
vec tsquared;

princomp(coeff, score, latent, tsquared, A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#princomp_cov">princomp_cov()</a></li>
<li><a href="http://en.wikipedia.org/wiki/Principal_component_analysis">principal components analysis in Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/PrincipalComponentAnalysis.html">principal components analysis in MathWorld</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="princomp_cov"></a>
<b>mat coeff = princomp_cov(mat X)</b>
<br><b>cx_mat coeff = princomp_cov(cx_mat X)</b><br>

<br><b>princomp_cov(mat coeff, colvec latent, mat X)</b>
<br><b>princomp_cov(cx_mat coeff, colvec latent, cx_mat X)</b><br>

<br><b>princomp_cov(mat coeff, colvec latent, colvec explained, mat X)</b>
<br><b>princomp_cov(cx_mat coeff, colvec latent, colvec explained, cx_mat X)</b><br>

<ul>
<li>Principal component analysis of the covariance matrix of the input matrix <i>X</i>.</li><br>
<li><i>coeff</i>: principal component coefficients.</li><br>
<li><i>latent</i>: principal component variances.</li><br>
<li><i>explained</i>: percentage of the total variance explained by each principal component.</li><br>
<li>The computation is based on singular value decomposition (SVD).
If the SVD fails, an error message is printed and the output matrices &amp; vectors have no elements.</li><br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,4);

mat coeff;
vec latent;
vec explained; 
princomp_cov(coeff, latent, explained, A);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#princomp">princomp()</a></li>
<li><a href="#cov">cov()</a></li>
<li><a href="http://en.wikipedia.org/wiki/Principal_component_analysis">principal components analysis in Wikipedia</a></li>
<li><a href="http://mathworld.wolfram.com/PrincipalComponentAnalysis.html">principal components analysis in MathWorld</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>

<a name="qr"></a>
<b>qr(Q,R,X)</b>
<ul>
<li>
Decomposition of matrix <i>X</i> into an orthogonal (<i>Q</i>) and a right triangular matrix (<i>R</i>), such that <i>Q*R = X</i>.
</li>
<br>
<li>
If the decomposition fails, <i>Q</i> and <i>R</i> are set to have no elements and an error message is printed.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);
mat Q, R;

qr(Q,R,X);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://mathworld.wolfram.com/QRDecomposition.html">QR decomposition in MathWorld</a>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="solve"></a>
<b>solve(colvec x, mat A, colvec b)</b> 
<br><b>solve(mat X, mat A, mat B)</b>
<br>
<br><b>colvec x = solve(mat A, colvec b)</b>
<br><b>mat X = solve(mat A, mat B)</b>
<ul>
<li>Solve a system of linear equations, i.e., <i>A*X = B</i>, where <i>X</i> is unknown.</li>
<br>
<li>For a square matrix <i>A</i>, this function is conceptually the same as <i>X = inv(A)*B</i>, but is more efficient.</li>
<br>
<li>Similar functionality to the "\" (left division operator) operator in Matlab/Octave, i.e., <i>X&nbsp;=&nbsp;A&nbsp;\&nbsp;B</i>.</li>
<br>
<li>The number of rows in <i>A</i> and <i>B</i> must be the same.</li>
<br>
<li>This function will also try to provide approximate solutions to under-determined
as well as over-determined systems (where matrix <i>A</i> is non-square).</li>
<br>
<li>
If no solution is found:
<ul>
<li>the two argument version will output a zero length vector/matrix</li>
<li>the three argument versions will set <i>X</i> to have no elements and output a bool set to <i>false</i></li>
</ul>
</li>
<br>
<li>
<b>NOTE:</b> Old versions of the ATLAS library (e.g.&nbsp;3.6) have a bug which can corrupt memory and crash your program
-- later versions of ATLAS (e.g.&nbsp;3.8) should work.
Using the standard LAPACK library works without problems.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(5,5);
vec b = randu&lt;vec&gt;(5);
mat B = randu&lt;mat&gt;(5,5);

vec x = solve(A,b);
mat X = solve(A,B);

vec x2;
bool status = solve(x2, A, b);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#inv">inv()</a>
<li><a href="http://mathworld.wolfram.com/LinearSystemofEquations.html">linear system of equations in MathWorld</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>


<a name="svd"></a>
<b>svd(colvec s, mat X)</b>, 
<br><b>svd(colvec s, cx_mat X)</b> 
<br>
<br><b>colvec s = svd(mat X)</b>
<br><b>colvec s = svd(cx_mat X)</b>
<br>
<br><b>svd(mat U, colvec s, mat V, mat X)</b>
<br><b>svd(cx_mat U, colvec s, cx_mat V, cx_mat X)</b>
<ul>
<li>
The single and two argument versions compute the singular values of <i>X</i>
</li>
<br>
<li>
The four argument version computes the singular value decomposition of <i>X</i>, such that:
<ul>
<li><i>X = U*diagmat(s)*trans(V)</i>, if <i>X</i> has real numbers</li>
<li><i>X = U*diagmat(s)*htrans(V)</i>, if <i>X</i> has complex numbers</li>
</ul>
</li>
<br>
<li>
If the decomposition fails:
<ul>
<li>the single argument version will output a zero length vector</li>
<li>the two and four argument versions output a bool set to <i>false</i></li>
</ul>
</li>
<br>
<li>
<b>NOTE:</b> Old versions of the ATLAS library (e.g.&nbsp;3.6) have a bug which can corrupt memory and crash your program
-- later versions of ATLAS (e.g.&nbsp;3.8) should work.
Using the standard LAPACK library works without problems.
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat X = randu&lt;mat&gt;(5,5);

mat U;
vec s;
mat V;
bool status = svd(U,s,V,X);
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://mathworld.wolfram.com/SingularValueDecomposition.html">singular value decomposition in MathWorld</a>
</li>
</ul>
<br>
<hr class="greyline">



<hr class="greyline">
<br>
<br>
<font size=+1><b>Miscellaneous</b></font>
<br>
<br>
<hr class="greyline">
<br>

<a name="math_constants"></a>
<b>math constants (pi, e, euler, gratio, sqrt2, eps, log_min, log_max)</b>
<br>
<br>
<ul>
<li>
Collection of constants, with their precision and/or value dependant on the numerical type and/or machine used.
</li>
<br>
<li>
The constants are stored as static functions in the <i>Math&lt;type&gt;</i> class,
where <i>type</i> is either <i>float</i> or <i>double</i>.
</li>
<br>
<li>
For convenience, <i>Math&lt;float&gt;</i> has been typedefed as <i>fmath</i>,
while <i>Math&lt;double&gt;</i> has been typedefed as <i>math</i>.
</li>
<br>
<li>
Meaning of the constants:
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr>
    <td style="vertical-align: top;">
      math::pi()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &pi;, the ratio of any circle's circumference to its diameter
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::e()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      base of the natural logarithm
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::euler()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Euler's constant, aka Euler-Mascheroni constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::gratio()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      golden ratio
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::sqrt2()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      square root of 2
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::eps()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      the difference between 1 and the least value greater than 1 that is representable
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::log_min()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      log of minimum non-zero value
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      math::log_max()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      log of maximum value
    </td>
  </tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
cout &lt;&lt; "2.0 * pi = " &lt;&lt; 2.0 * math::pi() &lt;&lt; endl;

cout &lt;&lt; "log_max for floats = ";
cout &lt;&lt; fmath::log_max() &lt;&lt; endl;

cout &lt;&lt; "log_max for doubles = ";
cout &lt;&lt; math::log_max() &lt;&lt; endl;
</pre>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="phys_constants"></a>
<b>physical constants (speed of light, etc)</b>
<br>
<br>
<ul>
<li>
Collection of fundamental physical constants,
mainly taken from
<a href="http://physics.nist.gov/cuu/Constants">NIST</a>
and some from
<a href="http://www.wolframalpha.com">WolframAlpha</a>
on 2009-06-23.
</li>
<br>
<li>
Constants from NIST are in turn sourced from the <a href="http://physics.nist.gov/cuu/Constants/papers.html">2006 CODATA values</a>.
</li>
<br>
<li>
The constants are stored as static functions in the <i>Phy&lt;type&gt;</i> class,
where <i>type</i> is either <i>float</i> or <i>double</i>.
</li>
<br>
<li>
For convenience, <i>Phy&lt;float&gt;</i> has been typedefed as <i>fphy</i>,
while <i>Phy&lt;double&gt;</i> has been typedefed as <i>phy</i>.
</li>
<br>
<li>
Meaning of the constants:
<ul>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr>
    <td style="vertical-align: top;">
      phy::m_u()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      atomic mass constant (in kg)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::N_A()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Avogadro constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::k()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Boltzmann constant (in joules per kelvin)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::k_evk()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Boltzmann constant (in eV/K)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::a_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Bohr radius (in meters)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::mu_B()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Bohr magneton
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::Z_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      characteristic impedance of vacuum (in ohms)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::G_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      conductance quantum (in siemens)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::k_e()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Coulomb's constant (in meters per farad)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::eps_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      electric constant (in farads per meter)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::m_e()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      electron mass (in kg)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::eV()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      electron volt (in joules)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::e()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      elementary charge (in coulombs)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::F()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Faraday constant (in coulombs)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::alpha()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      fine-structure constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::alpha_inv()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      inverse fine-structure constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::K_J()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Josephson constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::mu_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      magnetic constant (in henries per meter)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::phi_0() 
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      magnetic flux quantum (in webers)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::R()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      molar gas constant (in joules per mole kelvin)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::G()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Newtonian constant of gravitation (in newton square meters per kilogram squared)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::h() 
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Planck constant (in joule seconds)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::h_bar()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Planck constant over 2 pi, aka reduced Planck constant (in joule seconds)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::m_p()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      proton mass (in kg)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::R_inf()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Rydberg constant (in reciprocal meters)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::c_0()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      speed of light in vacuum (in meters per second)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::sigma()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Stefan-Boltzmann constant
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::R_k()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      von Klitzing constant (in ohms)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      phy::b()
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Wien wavelength displacement law constant
    </td>
  </tr>
</tbody>
</table>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
cout &lt;&lt; "speed of light = " &lt;&lt; phy::c_0() &lt;&lt; endl;
</pre>
</ul>
</li>
<br>
<li>
See also: <a href="http://en.wikipedia.org/wiki/Physical_constant">physical constant</a> entry in Wikipedia.
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="log_add"></a>
<b>log_add(log_a, log_b)</b>
<ul>
<li>
Safe replacement for log(exp(log_a) + exp(log_b))
</li>
<br>
<li>
Usage:
<ul>
<li>
<i>scalar_type</i> log_c = log_add(log_a, log_b)
</li>
<li>
<i>scalar_type</i> is either <i>float</i> or <i>double</i>
</li>
<li>
log_a, log_b and log_c must have the same type
</li>
</ul>
</li>
</ul>
<br>
<hr class="greyline"><br>

<a name="s32_u32"></a>
<b>s32</b>, <b>u32</b>
<ul>
<li>
s32 is a typedef for a 32 bit wide signed int
</li>
<br>
<li>
u32 is a typedef for a 32 bit wide unsigned int
</li>
<br>
<li>See also: <a href="http://cplusplus.com/doc/tutorial/variables/">C++ variable types</a></li>
<br>
</ul>
<hr class="greyline"><br>

<a name="cx_float_double"></a>
<b>cx_float</b>, <b>cx_double</b>
<ul>
<li>
cx_float is a typedef for std::complex&lt;float&gt;
</li>
<br>
<li>
cx_double is a typedef for std::complex&lt;double&gt;
</li>
<br>
<li>See also: <a href="http://cplusplus.com/reference/std/complex/">complex numbers in the standard C++ library</a></li>
<br>
</ul>

<a name="syntax"></a>
<hr class="greyline">
<br>
<b>conversion table between Matlab/Octave and Armadillo syntax</b>
<br>
<br>
<ul>
<table style="text-align: left;" border="0" cellpadding="2" cellspacing="2">
<tbody>
  <tr>
    <td style="vertical-align: top;">
      <b>Matlab/Octave</b>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <b>Armadillo</b>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <b>Notes</b>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(1, 1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A(0, 0)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      indexing in Armadillo starts at 0
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(k, k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A(k-1, k-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      size(A,1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#attributes">.n_rows</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      read only
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      size(A,2)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#attributes">.n_cols</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      size(Q,3)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Q<a href="#attributes">.n_slices</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Q is a <a href="#Cube">cube</a> (3D array)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      numel(A)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#attributes">.n_elem</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(:,k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#submat">.col</a>(k-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(k, :)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#submat">.row</a>(k-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(:, p:q)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#submat">.cols</a>(p-1, q-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(p:q, :)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#submat">.rows</a>(p-1, q-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A(p:q, r:s)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <font size=-1>
      A<a href="#submat">.submat</a>(p-1, r-1, q-1, s-1)
      </font>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <font size=-1>
      A.submat(first_row, first_col, last_row, last_col)
      </font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      Q(:, :, k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Q<a href="#subcube">.slice</a>(k-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Q is a <a href="#Cube">cube</a> (3D array)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      Q(:, :, t:u)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Q<a href="#subcube">.slices</a>(t-1, u-1)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      Q(p:q, r:s, t:u)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <font size=-1>
      Q<a href="#subcube">.subcube</a>(p-1,&nbsp;r-1,&nbsp;t-1,&nbsp;q-1,&nbsp;s-1,&nbsp;u-1)
      </font>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <font size=-1>
      .subcube(first_row, first_column, first_slice, last_row, last_column, last_slice)
      </font>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A.'
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#trans">trans</a>(A)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      simple transpose
      <br>
      (the conjugate of each element is not taken)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A'
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#htrans">htrans</a>(A)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Hermitian transpose
      <br>
      (for complex matrices, the conjugate of each element is taken)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = zeros(size(A))
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#zeros_member">.zeros()</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = ones(size(A))
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A.<a href="#ones_member">ones()</a>
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = zeros(k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A = <a href="#zeros_standalone">zeros</a>&lt;mat&gt;(k,k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = ones(k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A = <a href="#ones_standalone">ones</a>&lt;mat&gt;(k,k)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      C = complex(A,B)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      cx_mat C = <a href="#Mat">cx_mat</a>(A,B)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A .* B
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A % B
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#operators">element-wise multiplication</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A ./ B
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A / B
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#operators">element-wise division</a>
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A \ B
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#solve">solve</a>(A,B)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = A + 1;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A++
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = A - 1;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A--
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A = [ 1 2; 3 4; ]
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A = "1 2; 3 4;"
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      X = [&nbsp;A&nbsp;&nbsp;B&nbsp;]
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      X = <a href="#join">join_rows</a>(A,B)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      X = [&nbsp;A;&nbsp;B&nbsp;]
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      X = <a href="#join">join_cols</a>(A,B)
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      A
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      cout &lt;&lt; A &lt;&lt; endl;
      <br>or
      <br>A<a href="#print">.print</a>("A =");
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      save&nbsp;-ascii&nbsp;'A.dat'&nbsp;A
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#save_load_mat">.save</a>("A.dat",&nbsp;raw_ascii);
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      Matlab/Octave matrices saved as ascii are readable by Armadillo (and vice-versa)
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      load&nbsp;-ascii&nbsp;'A.dat'
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      A<a href="#save_load_mat">.load</a>("A.dat",&nbsp;raw_ascii);
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
  </tr>
  <tr>
    <td style="vertical-align: top;">
      S&nbsp;=&nbsp;{&nbsp;'abc';&nbsp;'def'&nbsp;}
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#field">field</a>&lt;std::string&gt; S(2);
      <br>S(0) = "abc";
      <br>S(1) = "def";
    </td>
    <td style="vertical-align: top;">
      &nbsp;
    </td>
    <td style="vertical-align: top;">
      <a href="#field">fields</a> can store arbitrary objects
    </td>
  </tr>
</tbody>
</table>
</ul>
<br>

<a name="example_prog"></a>
<hr class="greyline">
<br>
<b>example program</b>
<br>
<br>
<ul>
<li>
If you save the program below as <i>arma_prog.cpp</i>,
under Linux you can compile it using:
<br>
g++ arma_prog.cpp -o arma_prog -O1 -larmadillo
</li>
<br>
<li>
You may also want to have a look at the example programs that come with the Armadillo archive.
</li>
<br>
<pre>
#include &lt;iostream&gt;
#include &lt;armadillo&gt;

using namespace std;
using namespace arma;

int main(int argc, char** argv)
  {
  mat A = randu&lt;mat&gt;(4,5);
  mat B = randu&lt;mat&gt;(4,5);
  
  cout &lt;&lt; "A*trans(B) =" &lt;&lt; endl;
  cout &lt;&lt; A*trans(B) &lt;&lt; endl;
  
  return 0;
  }
</pre>
</ul>
<br>


<!-- END CONTENT -->


<hr>
<br>
<br>
</div>

</td>
</tr>
</tbody>
</table>
</center>
</body>
</html>
