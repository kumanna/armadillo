<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Operator_div</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Operator_div</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00094.html">eOp</a>&lt; T1, <br class="typebreak"/>
<a class="el" href="a00158.html">eop_scalar_div_post</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#gad2574ea5505d8fe2309ec34e19a8a3fb">operator/</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const typename T1::elem_type k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> / scalar.  <a href="#gad2574ea5505d8fe2309ec34e19a8a3fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00094.html">eOp</a>&lt; T1, <br class="typebreak"/>
<a class="el" href="a00159.html">eop_scalar_div_pre</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#ga954d3575c07a7e9c18e6555cdb36f704">operator/</a> (const typename T1::elem_type k, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">scalar / <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a>  <a href="#ga954d3575c07a7e9c18e6555cdb36f704"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00308.html">Mat</a>&lt; typename <br class="typebreak"/>
std::complex&lt; typename <br class="typebreak"/>
T1::pod_type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#ga954fc1e01a9f079b5f4910b09ca67c26">operator/</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::pod_type, T1 &gt; &amp;X, const std::complex&lt; typename T1::pod_type &gt; &amp;k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">non-complex <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> / complex scalar (experimental)  <a href="#ga954fc1e01a9f079b5f4910b09ca67c26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00308.html">Mat</a>&lt; typename <br class="typebreak"/>
std::complex&lt; typename <br class="typebreak"/>
T1::pod_type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#ga4da486f401ff390415621ada4b044218">operator/</a> (const std::complex&lt; typename T1::pod_type &gt; &amp;k, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::pod_type, T1 &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">complex scalar / non-complex <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> (experimental)  <a href="#ga4da486f401ff390415621ada4b044218"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00082.html">eGlue</a>&lt; T1, <br class="typebreak"/>
T2, <a class="el" href="a00089.html">eglue_div</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#gad3b8ce34d6b5bca93e7e61efabe36369">operator/</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element-wise division of <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> objects with same element type  <a href="#gad3b8ce34d6b5bca93e7e61efabe36369"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00308.html">Mat</a>&lt; typename <br class="typebreak"/>
<a class="el" href="a00376.html">promote_type</a>&lt; typename <br class="typebreak"/>
T1::elem_type, typename <br class="typebreak"/>
T2::elem_type &gt;::result &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00861.html#gac01ee535141c2c01dc3e2a7bff34f636">operator/</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename <a class="el" href="a00176.html">force_different_type</a>&lt; typename T1::elem_type, typename T2::elem_type &gt;::T1_result, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename <a class="el" href="a00176.html">force_different_type</a>&lt; typename T1::elem_type, typename T2::elem_type &gt;::T2_result, T2 &gt; &amp;Y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element-wise division of <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> objects with different element types  <a href="#gac01ee535141c2c01dc3e2a7bff34f636"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad2574ea5505d8fe2309ec34e19a8a3fb"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="gad2574ea5505d8fe2309ec34e19a8a3fb" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const typename T1::elem_type k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00094.html">eOp</a>&lt;T1, <a class="el" href="a00158.html">eop_scalar_div_post</a>&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T1::elem_type&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> / scalar. </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00027">27</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031   {
<a name="l00032"></a>00032   arma_extra_debug_sigprint();
<a name="l00033"></a>00033   
<a name="l00034"></a>00034   <span class="keywordflow">return</span> <a class="code" href="a00094.html">eOp&lt;T1, eop_scalar_div_post&gt;</a>(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>(), k);
<a name="l00035"></a>00035   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga954d3575c07a7e9c18e6555cdb36f704"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="ga954d3575c07a7e9c18e6555cdb36f704" args="(const typename T1::elem_type k, const Base&lt; typename T1::elem_type, T1 &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00094.html">eOp</a>&lt;T1, <a class="el" href="a00159.html">eop_scalar_div_pre</a>&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const typename T1::elem_type&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>scalar / <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00044">44</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00048"></a>00048   {
<a name="l00049"></a>00049   arma_extra_debug_sigprint();
<a name="l00050"></a>00050   
<a name="l00051"></a>00051   <span class="keywordflow">return</span> <a class="code" href="a00094.html">eOp&lt;T1, eop_scalar_div_pre&gt;</a>(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>(), k);
<a name="l00052"></a>00052   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga954fc1e01a9f079b5f4910b09ca67c26"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="ga954fc1e01a9f079b5f4910b09ca67c26" args="(const Base&lt; typename T1::pod_type, T1 &gt; &amp;X, const std::complex&lt; typename T1::pod_type &gt; &amp;k)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00308.html">Mat</a>&lt;typename std::complex&lt;typename T1::pod_type&gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::pod_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; typename T1::pod_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>non-complex <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> / complex scalar (experimental) </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00061">61</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00065"></a>00065   {
<a name="l00066"></a>00066   arma_extra_debug_sigprint();
<a name="l00067"></a>00067   
<a name="l00068"></a>00068   <span class="keyword">typedef</span> <span class="keyword">typename</span> std::complex&lt;typename T1::pod_type&gt; eT;
<a name="l00069"></a>00069   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::pod_type                         T;
<a name="l00070"></a>00070   
<a name="l00071"></a>00071   <span class="keyword">const</span> <a class="code" href="a00455.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00072"></a>00072   
<a name="l00073"></a>00073   <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a> out(A.n_rows, A.n_cols);
<a name="l00074"></a>00074   
<a name="l00075"></a>00075   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem  = A.n_elem;
<a name="l00076"></a>00076         eT* out_mem = out.memptr();
<a name="l00077"></a>00077   
<a name="l00078"></a>00078   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00079"></a>00079     {
<a name="l00080"></a>00080     out_mem[i] = A[i] / k;
<a name="l00081"></a>00081     }
<a name="l00082"></a>00082   
<a name="l00083"></a>00083   <span class="keywordflow">return</span> out;
<a name="l00084"></a>00084   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4da486f401ff390415621ada4b044218"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="ga4da486f401ff390415621ada4b044218" args="(const std::complex&lt; typename T1::pod_type &gt; &amp;k, const Base&lt; typename T1::pod_type, T1 &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00308.html">Mat</a>&lt;typename std::complex&lt;typename T1::pod_type&gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; typename T1::pod_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::pod_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>complex scalar / non-complex <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> (experimental) </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00093">93</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00097"></a>00097   {
<a name="l00098"></a>00098   arma_extra_debug_sigprint();
<a name="l00099"></a>00099   
<a name="l00100"></a>00100   <span class="keyword">typedef</span> <span class="keyword">typename</span> std::complex&lt;typename T1::pod_type&gt; eT;
<a name="l00101"></a>00101   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::pod_type                         T;
<a name="l00102"></a>00102   
<a name="l00103"></a>00103   <span class="keyword">const</span> <a class="code" href="a00455.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00104"></a>00104   
<a name="l00105"></a>00105   <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a> out(A.n_rows, A.n_cols);
<a name="l00106"></a>00106   
<a name="l00107"></a>00107   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem  = A.n_elem;
<a name="l00108"></a>00108         eT* out_mem = out.memptr();
<a name="l00109"></a>00109   
<a name="l00110"></a>00110   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112     out_mem[i] = k / A[i];
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114   
<a name="l00115"></a>00115   <span class="keywordflow">return</span> out;
<a name="l00116"></a>00116   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad3b8ce34d6b5bca93e7e61efabe36369"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="gad3b8ce34d6b5bca93e7e61efabe36369" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00082.html">eGlue</a>&lt;T1, T2, <a class="el" href="a00089.html">eglue_div</a>&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element-wise division of <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> objects with same element type </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00125">125</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00129"></a>00129   {
<a name="l00130"></a>00130   arma_extra_debug_sigprint();
<a name="l00131"></a>00131   
<a name="l00132"></a>00132   <span class="keywordflow">return</span> <a class="code" href="a00082.html">eGlue&lt;T1, T2, eglue_div&gt;</a>(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>(), Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00133"></a>00133   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac01ee535141c2c01dc3e2a7bff34f636"></a><!-- doxytag: member="operator_div.hpp::operator/" ref="gac01ee535141c2c01dc3e2a7bff34f636" args="(const Base&lt; typename force_different_type&lt; typename T1::elem_type, typename T2::elem_type &gt;::T1_result, T1 &gt; &amp;X, const Base&lt; typename force_different_type&lt; typename T1::elem_type, typename T2::elem_type &gt;::T2_result, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00308.html">Mat</a>&lt;typename <a class="el" href="a00376.html">promote_type</a>&lt;typename T1::elem_type, typename T2::elem_type&gt;::result&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename <a class="el" href="a00176.html">force_different_type</a>&lt; typename T1::elem_type, typename T2::elem_type &gt;::T1_result, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename <a class="el" href="a00176.html">force_different_type</a>&lt; typename T1::elem_type, typename T2::elem_type &gt;::T2_result, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element-wise division of <a class="el" href="a00054.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> objects with different element types </p>

<p>Definition at line <a class="el" href="a00694_source.html#l00142">142</a> of file <a class="el" href="a00694_source.html">operator_div.hpp</a>.</p>

<p>References <a class="el" href="a00726_source.html#l00034">upgrade_val&lt; T1, T2 &gt;::apply()</a>, <a class="el" href="a00703_source.html#l00025">promote_type&lt; T1, T2 &gt;::check()</a>, <a class="el" href="a00520_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, <a class="el" href="a00632_source.html#l02069">Mat&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00146"></a>00146   {
<a name="l00147"></a>00147   arma_extra_debug_sigprint();
<a name="l00148"></a>00148   
<a name="l00149"></a>00149   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT1;
<a name="l00150"></a>00150   <span class="keyword">typedef</span> <span class="keyword">typename</span> T2::elem_type eT2;
<a name="l00151"></a>00151   
<a name="l00152"></a>00152   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00376.html">promote_type&lt;eT1,eT2&gt;::result</a> out_eT;
<a name="l00153"></a>00153   
<a name="l00154"></a>00154   <a class="code" href="a00376.html#af84f38f42cfb0d891487c3273c521f2d">promote_type&lt;eT1,eT2&gt;::check</a>();
<a name="l00155"></a>00155   
<a name="l00156"></a>00156   <span class="keyword">const</span> <a class="code" href="a00455.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00157"></a>00157   <span class="keyword">const</span> <a class="code" href="a00455.html">Proxy&lt;T2&gt;</a> B(Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00158"></a>00158   
<a name="l00159"></a>00159   arma_debug_assert_same_size(A, B, <span class="stringliteral">&quot;element-wise matrix division&quot;</span>);
<a name="l00160"></a>00160   
<a name="l00161"></a>00161   <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;out_eT&gt;</a> out(A.n_rows, A.n_cols);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         out_eT* out_mem = out.memptr();
<a name="l00164"></a>00164   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>     n_elem  = out.n_elem;
<a name="l00165"></a>00165   
<a name="l00166"></a>00166   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00167"></a>00167     {
<a name="l00168"></a>00168     out_mem[i] = <a class="code" href="a00500.html#a690e536c7b488b4db54bb0e751309ac7">upgrade_val&lt;eT1,eT2&gt;::apply</a>(A[i]) / <a class="code" href="a00500.html#a690e536c7b488b4db54bb0e751309ac7">upgrade_val&lt;eT1,eT2&gt;::apply</a>(B[i]);
<a name="l00169"></a>00169     }
<a name="l00170"></a>00170   
<a name="l00171"></a>00171   <span class="keywordflow">return</span> out;
<a name="l00172"></a>00172   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
