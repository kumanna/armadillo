<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Mat&lt; eT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Mat&lt; eT &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00807.html">Mat</a>]</small>
</h1><!-- doxytag: class="Mat" --><!-- doxytag: inherits="Base&lt; eT, Mat&lt; eT &gt; &gt;" -->
<p>Dense matrix class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00621_source.html">Mat_proto.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Mat&lt; eT &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="a00303.gif" usemap="#Mat&lt; eT &gt;_map" alt=""/>
  <map id="Mat&lt; eT &gt;_map" name="Mat&lt; eT &gt;_map">
<area href="a00054.html" alt="Base&lt; eT, Mat&lt; eT &gt; &gt;" shape="rect" coords="78,0,224,24"/>
<area href="a00058.html" alt="Col&lt; eT &gt;" shape="rect" coords="0,112,146,136"/>
<area href="a00466.html" alt="Row&lt; eT &gt;" shape="rect" coords="156,112,302,136"/>
</map>
 </div>
</div>

<p><a href="a01159.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of elements stored in the matrix  <a href="#a3b7c1109cca98fb4bf493b8be33c4299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00187.html">get_pod_type</a><br class="typebreak"/>
&lt; <a class="el" href="a00303.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a> &gt;::result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a364ff14c17bd94689ca7284aea2af5c9">pod_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex  <a href="#a364ff14c17bd94689ca7284aea2af5c9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga3b82e7c8bced32cad06a0d3353d86a0e">~Mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gae6672df794f7ec95a2ef60165b296e14">Mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga017548674d56b5400940606bfe3caa6e">Mat</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct the matrix to have user specified dimensions  <a href="a00807.html#ga017548674d56b5400940606bfe3caa6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga3a2b6f33180c63af39433d6e59594e46">Mat</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00807.html#ga3a2b6f33180c63af39433d6e59594e46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga0d1d28a725ef1232c8d7b404cc0dd302">operator=</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00807.html#ga0d1d28a725ef1232c8d7b404cc0dd302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga08056e3a5f18347bbc0edd1aefef8870">Mat</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00807.html#ga08056e3a5f18347bbc0edd1aefef8870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga395ddf62b79a1ab93f54c7f5859deb40">operator=</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00807.html#ga395ddf62b79a1ab93f54c7f5859deb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gac401a31e52150d0a6291bd0bc1d4c91d">Mat</a> (eT *aux_mem, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols, const bool copy_aux_mem=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). the default is to copy the array.  <a href="a00807.html#gac401a31e52150d0a6291bd0bc1d4c91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga0ab642c6dc44b0b2f09dd5c2045d7071">Mat</a> (const eT *aux_mem, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given auxiliary read-only array of eTs. the array is copied.  <a href="a00807.html#ga0ab642c6dc44b0b2f09dd5c2045d7071"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga029ee5fd254cd7829ea033a75622d37d">operator=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix to be equal to the specified scalar. NOTE: the size of the matrix will be 1x1.  <a href="a00807.html#ga029ee5fd254cd7829ea033a75622d37d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gafd3c0fff0616fbef5094f8a1eaf78bea">operator+=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place addition of a scalar to all elements of the matrix.  <a href="a00807.html#gafd3c0fff0616fbef5094f8a1eaf78bea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga26320df042acc259335164ca00f11407">operator-=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place subtraction of a scalar from all elements of the matrix.  <a href="a00807.html#ga26320df042acc259335164ca00f11407"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaad8308865d373b5dbcc5517fd73ef4ba">operator*=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place multiplication of all elements of the matrix with a scalar.  <a href="a00807.html#gaad8308865d373b5dbcc5517fd73ef4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga3ffd336aafb355efd5a8ef6076d10d74">operator/=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place division of all elements of the matrix with a scalar.  <a href="a00807.html#ga3ffd336aafb355efd5a8ef6076d10d74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga824d20ed95764e288d00ec70f3efd23f">Mat</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00807.html#ga824d20ed95764e288d00ec70f3efd23f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga37163b5ece683f63c7e0c0fcf9f089fe">operator=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00807.html#ga37163b5ece683f63c7e0c0fcf9f089fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga2cdc8ab31ab8112f8598d2aa23485f65">operator+=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition  <a href="a00807.html#ga2cdc8ab31ab8112f8598d2aa23485f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga674700f7c76ea0fafbd0812cdcfba0ff">operator-=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction  <a href="a00807.html#ga674700f7c76ea0fafbd0812cdcfba0ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga02175c61f90586cbb998d5ae62e3d81e">operator*=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication  <a href="a00807.html#ga02175c61f90586cbb998d5ae62e3d81e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga5b8b28c6064027ba31b0b46fc3966dc3">operator%=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix multiplication  <a href="a00807.html#ga5b8b28c6064027ba31b0b46fc3966dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga1205480b81872f46694b7352b8c08539">operator/=</a> (const <a class="el" href="a00303.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division  <a href="a00807.html#ga1205480b81872f46694b7352b8c08539"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga0688744b9c1bb22395353af1180df2a7">Mat</a> (const <a class="el" href="a00054.html">Base</a>&lt; <a class="el" href="a00303.html#a364ff14c17bd94689ca7284aea2af5c9">pod_type</a>, T1 &gt; &amp;A, const <a class="el" href="a00054.html">Base</a>&lt; <a class="el" href="a00303.html#a364ff14c17bd94689ca7284aea2af5c9">pod_type</a>, T2 &gt; &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for constructing a complex matrix out of two non-complex matrices  <a href="a00807.html#ga0688744b9c1bb22395353af1180df2a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaa7536044eb0982fb537008d4e170e92a">Mat</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (e.g. construct a matrix from a delayed submatrix operation)  <a href="a00807.html#gaa7536044eb0982fb537008d4e170e92a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga842026269a093a0cdc6241c557ea4062">operator=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (e.g. construct a matrix from a delayed submatrix operation)  <a href="a00807.html#ga842026269a093a0cdc6241c557ea4062"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga67e01e0e65c8913215930b55578c8e12">operator+=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a submatrix on the right-hand-side)  <a href="a00807.html#ga67e01e0e65c8913215930b55578c8e12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6d87684c219899d2ec4ff940db83ae87">operator-=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a submatrix on the right-hand-side)  <a href="a00807.html#ga6d87684c219899d2ec4ff940db83ae87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga9ec63518d1ca07f49eb874dd0e655805">operator*=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00807.html#ga9ec63518d1ca07f49eb874dd0e655805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gae91414c6103d9f0a9632170a6eeac1e3">operator%=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00807.html#gae91414c6103d9f0a9632170a6eeac1e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gab593128f6f762f345871c7c1c07a45df">operator/=</a> (const <a class="el" href="a00478.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a submatrix on the right-hand-side)  <a href="a00807.html#gab593128f6f762f345871c7c1c07a45df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaed510503c0a577bce94c037ab698e5fe">Mat</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a <a class="el" href="a00480.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance  <a href="a00807.html#gaed510503c0a577bce94c037ab698e5fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6507409953ec3e6f336086282074b9c6">operator=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a <a class="el" href="a00480.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance  <a href="a00807.html#ga6507409953ec3e6f336086282074b9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gac6112a83b4ceed466c33fff1eda50842">operator+=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a single-slice subcube on the right-hand-side)  <a href="a00807.html#gac6112a83b4ceed466c33fff1eda50842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga9ddd3c6be1330c870f54c527a03b0101">operator-=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a single-slice subcube on the right-hand-side)  <a href="a00807.html#ga9ddd3c6be1330c870f54c527a03b0101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga58d436053dd07591edb9dad539988ed5">operator*=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a single-slice subcube on the right-hand-side)  <a href="a00807.html#ga58d436053dd07591edb9dad539988ed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga4e277b4f0cd936dcbfe9c7bcc4ba0bc4">operator%=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a single-slice subcube on the right-hand-side)  <a href="a00807.html#ga4e277b4f0cd936dcbfe9c7bcc4ba0bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga7043bbf21a6e45a3f3a2f842ab5b262f">operator/=</a> (const <a class="el" href="a00480.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a single-slice subcube on the right-hand-side)  <a href="a00807.html#ga7043bbf21a6e45a3f3a2f842ab5b262f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga7b1d9112781e7432ce4a897a39b3d7bd">Mat</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (e.g. construct a matrix from a delayed diag operation)  <a href="a00807.html#ga7b1d9112781e7432ce4a897a39b3d7bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga59a2458fe1b064aafade061f51772196">operator=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (e.g. construct a matrix from a delayed diag operation)  <a href="a00807.html#ga59a2458fe1b064aafade061f51772196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga5136977ee4bdf5445a260cbcaa619ea3">operator+=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00807.html#ga5136977ee4bdf5445a260cbcaa619ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga0d0812bd9eef6facd7dd2135a3138432">operator-=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00807.html#ga0d0812bd9eef6facd7dd2135a3138432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gabc62b37b158967b7fd24e4139e412184">operator*=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00807.html#gabc62b37b158967b7fd24e4139e412184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga7e9686e94a6f5907606eec81da3a9f4b">operator%=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00807.html#ga7e9686e94a6f5907606eec81da3a9f4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga119374661fa15e69e9bde297e8e72cc2">operator/=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00807.html#ga119374661fa15e69e9bde297e8e72cc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00482.html">subview_row</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6c635601a53805f94ae700cd3f5e1ee2">row</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00807.html#ga6c635601a53805f94ae700cd3f5e1ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00482.html">subview_row</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga8d8c592f5a4d25f1e49e4eb606966787">row</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00807.html#ga8d8c592f5a4d25f1e49e4eb606966787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00479.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga2375909127f177e73b26b9f64db8e371">col</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (column vector)  <a href="a00807.html#ga2375909127f177e73b26b9f64db8e371"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00479.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga472c837fe6f0fcf4abf17bc4f4f9dfe0">col</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (column vector)  <a href="a00807.html#ga472c837fe6f0fcf4abf17bc4f4f9dfe0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga8d1124a9e4dca72171f1eb33a5fbc0eb">rows</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00807.html#ga8d1124a9e4dca72171f1eb33a5fbc0eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga09b4d721feee58f88c6baf951d8d42c5">rows</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00807.html#ga09b4d721feee58f88c6baf951d8d42c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga7041aca9876cdd664656e1d9c0b66ed4">cols</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified column vectors)  <a href="a00807.html#ga7041aca9876cdd664656e1d9c0b66ed4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga5986cc7d055bc9811bc800586659c4a8">cols</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified column vectors)  <a href="a00807.html#ga5986cc7d055bc9811bc800586659c4a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6cbc37f46d31a6e5e75ae82a90f6015f">submat</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix)  <a href="a00807.html#ga6cbc37f46d31a6e5e75ae82a90f6015f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00478.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga61cfe2cb1b1315b5feaffcadda98ad7f">submat</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00478.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (generic submatrix)  <a href="a00807.html#ga61cfe2cb1b1315b5feaffcadda98ad7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00078.html">diagview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga5c33674c27dc9663c3a76b8c81584a1d">diag</a> (const <a class="el" href="a00862.html#ga584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a> in_id=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (diagonal)  <a href="a00807.html#ga5c33674c27dc9663c3a76b8c81584a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga2def58167305ce98f896e4918fc313dc">diag</a> (const <a class="el" href="a00862.html#ga584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a> in_id=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (diagonal)  <a href="a00807.html#ga2def58167305ce98f896e4918fc313dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga40b14d5a36c66f84e8fd918f36740d55">swap_rows</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6df2b2946f4b96e3354b1c3ca8ce7730">swap_cols</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gad0595e26094a2412ef2ae9c1e0320938">Mat</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00307.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed unary operations  <a href="a00807.html#gad0595e26094a2412ef2ae9c1e0320938"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gaa4674cf1bc952d6fd307eba92cd54d36">operator=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00307.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed unary operations  <a href="a00807.html#gaa4674cf1bc952d6fd307eba92cd54d36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga6e73bbf147bc1f6fca939959e54fb321">operator+=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operand having delayed operations  <a href="a00807.html#ga6e73bbf147bc1f6fca939959e54fb321"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gade9eaff44df34271b77b157e9b1fe61d">operator-=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operand having delayed operations  <a href="a00807.html#gade9eaff44df34271b77b157e9b1fe61d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gaae498ac76bf2d9e5d232c0846d464117">operator*=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication, with the right-hand-side operand having delayed operations  <a href="a00807.html#gaae498ac76bf2d9e5d232c0846d464117"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gae9d43b30d8e22aab1f97752cb321a3fc">operator%=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise multiplication, with the right-hand-side operand having delayed operations  <a href="a00807.html#gae9d43b30d8e22aab1f97752cb321a3fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga0b39e2617954b5f82f1a32cf6a471a8f">operator/=</a> (const <a class="el" href="a00307.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise division, with the right-hand-side operand having delayed operations  <a href="a00807.html#ga0b39e2617954b5f82f1a32cf6a471a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gae99d9ac3f97013476c37729d94021340">Mat</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00092.html">eOp</a>, i.e. run the previously delayed unary operations  <a href="a00807.html#gae99d9ac3f97013476c37729d94021340"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga09b6f9282ef02a155f00011908f635cb">operator=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00092.html">eOp</a>, i.e. run the previously delayed unary operations  <a href="a00807.html#ga09b6f9282ef02a155f00011908f635cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga1057038bcb2fb117cc73dd783366897b">operator+=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga9489dd95254a980f632025c67daeb8b3">operator-=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gaa1b03e3bb8fa10df5c3283d49994b7d0">operator*=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga73fee4211d5de4f24781abbf623007d8">operator%=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gac9d906a34cf66b86ad16e708db5b3a38">operator/=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga913949ff41cc0ba91bf6324a77b799cd">Mat</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00189.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="a00807.html#ga913949ff41cc0ba91bf6324a77b799cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga22e1b9221c9531127d605429a219aae3">operator=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00189.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="a00807.html#ga22e1b9221c9531127d605429a219aae3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga3cb518b25b04ebcab72980bda08ebe26">operator+=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operands having delayed operations  <a href="a00807.html#ga3cb518b25b04ebcab72980bda08ebe26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga77eb50589187818454ff0abf0bd3dd00">operator-=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operands having delayed operations  <a href="a00807.html#ga77eb50589187818454ff0abf0bd3dd00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gac3bc7f2c61b515b4485365003b160e9e">operator*=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplications, with the right-hand-side operands having delayed operations  <a href="a00807.html#gac3bc7f2c61b515b4485365003b160e9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga413568f6312ac864c0ef38a8bc409049">operator%=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise multiplication, with the right-hand-side operands having delayed operations  <a href="a00807.html#ga413568f6312ac864c0ef38a8bc409049"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gac86865b344d26aabc7a6a2724dab1fda">operator/=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise division, with the right-hand-side operands having delayed operations  <a href="a00807.html#gac86865b344d26aabc7a6a2724dab1fda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga33828260303b98a795d34aa0ade8d795">operator+=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, <a class="el" href="a00193.html">glue_times</a> &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga4bd6acf3ae88cea11768642d2fc56310">operator-=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, <a class="el" href="a00193.html">glue_times</a> &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga584f8411678e16a77d1d28ae36e6d255">Mat</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00080.html">eGlue</a>, i.e. run the previously delayed binary operations  <a href="a00807.html#ga584f8411678e16a77d1d28ae36e6d255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga1cc990fef2077df856e899627579d309">operator=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00080.html">eGlue</a>, i.e. run the previously delayed binary operations  <a href="a00807.html#ga1cc990fef2077df856e899627579d309"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga61e59cf226662843699ea406ee2eca24">operator+=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operands having delayed operations  <a href="a00807.html#ga61e59cf226662843699ea406ee2eca24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gac3b983205d8aa844f2b7b203f251a7d7">operator-=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operands having delayed operations  <a href="a00807.html#gac3b983205d8aa844f2b7b203f251a7d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gae574830dbdd434614e87ba1b6abe8f1c">operator*=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga58ca136e17b604726d52e98d5f1ce32c">operator%=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#ga08c11d17c142a9ca4fd79a97316a8b92">operator/=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga3965fcd6e27aab50a0f6df11243b33b5">operator[]</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); no bounds check.  <a href="a00807.html#ga3965fcd6e27aab50a0f6df11243b33b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gad6bfbf4295336cded8c896628517744a">operator[]</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); no bounds check  <a href="a00807.html#gad6bfbf4295336cded8c896628517744a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga60192672859e768daea6a66559804ec0">operator()</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00807.html#ga60192672859e768daea6a66559804ec0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaaca8a366e693604cb28b6010e6f1d937">operator()</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00807.html#gaaca8a366e693604cb28b6010e6f1d937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6e3952e7bf8575ff6423340f4ad1807a">at</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="a00807.html#ga6e3952e7bf8575ff6423340f4ad1807a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gabc8caa5c7911c7a67378fbac4e3b7be2">at</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="a00807.html#gabc8caa5c7911c7a67378fbac4e3b7be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga9f0e97d99bf54549b530e0736a4cda5b">operator()</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00807.html#ga9f0e97d99bf54549b530e0736a4cda5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaadce1499d9a184f1b526f77d1fea615e">operator()</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00807.html#gaadce1499d9a184f1b526f77d1fea615e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaac0f36b3cedf7f6be113582b6edc0fd0">operator++</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix ++  <a href="a00807.html#gaac0f36b3cedf7f6be113582b6edc0fd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gabdf95868404d49f468e4cbd03b80e306">operator++</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++ (must not return the object by reference)  <a href="a00807.html#gabdf95868404d49f468e4cbd03b80e306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00303.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga632e79fa65d54ad7381fde813910d987">operator--</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix --  <a href="a00807.html#ga632e79fa65d54ad7381fde813910d987"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga2e8972e43ad726b00fd4fab21ecef9ae">operator--</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix -- (must not return the object by reference)  <a href="a00807.html#ga2e8972e43ad726b00fd4fab21ecef9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga588483a35cd5e45a01390aab33c7b16b">is_vec</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the object can be interpreted as a column or row vector  <a href="a00807.html#ga588483a35cd5e45a01390aab33c7b16b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaebcde5b059098f2ee43b9ae0a3d3f0b7">is_square</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the object has the same number of non-zero rows and columnns  <a href="a00807.html#gaebcde5b059098f2ee43b9ae0a3d3f0b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga31b2e5a2a3e150cc856642befd83db6a">is_finite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if all of the elements are finite  <a href="a00807.html#ga31b2e5a2a3e150cc856642befd83db6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga9355267e66e1ce202e16b2bc9e486585">colptr</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs for a specified column; no bounds check  <a href="a00807.html#ga9355267e66e1ce202e16b2bc9e486585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga28ff003069bef699eefb649fa2dcdc72">colptr</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs for a specified column; no bounds check  <a href="a00807.html#ga28ff003069bef699eefb649fa2dcdc72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga78bb1eef0619bccb2a13f3dfafee19bf">memptr</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the matrix  <a href="a00807.html#ga78bb1eef0619bccb2a13f3dfafee19bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gaf5686825798075886487c0223f5821cb">memptr</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the matrix  <a href="a00807.html#gaf5686825798075886487c0223f5821cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gabc78fefc6ab8f7cf66638978fd9030d5">print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00807.html#gabc78fefc6ab8f7cf66638978fd9030d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gac9d0f7c07ef22c8c93a3a5d05b60a8e3">print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00807.html#gac9d0f7c07ef22c8c93a3a5d05b60a8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga50326854dc4f92c014e572444e7c1a5f">print_trans</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00807.html#ga50326854dc4f92c014e572444e7c1a5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga9f9808eefb25ca36d9ca064c08d3f3cc">print_trans</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of matrix to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00807.html#ga9f9808eefb25ca36d9ca064c08d3f3cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6417a9fa5275b438ac42105f305bb591">raw_print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified).  <a href="a00807.html#ga6417a9fa5275b438ac42105f305bb591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gad7b2da64f7bcfe3b8a822a0a93d5a141">raw_print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified).  <a href="a00807.html#gad7b2da64f7bcfe3b8a822a0a93d5a141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gad67b361670e40b871022c20ae63605a9">raw_print_trans</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified).  <a href="a00807.html#gad67b361670e40b871022c20ae63605a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga21397c90a1de6797d3fbfc3071198008">raw_print_trans</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified).  <a href="a00807.html#ga21397c90a1de6797d3fbfc3071198008"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00807.html#gabeed7f66dc1018fd551a6e760343dee6">copy_size</a> (const <a class="el" href="a00303.html">Mat</a>&lt; eT2 &gt; &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the matrix (without preserving data) to have the same dimensions as the given matrix  <a href="a00807.html#gabeed7f66dc1018fd551a6e760343dee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gac55ef8df37e04e1af416594dfbe25ac6">set_size</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the matrix to have user specified dimensions (data is not preserved)  <a href="a00807.html#gac55ef8df37e04e1af416594dfbe25ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga39020f25c737f1e47a6439f791e9f11f">fill</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fill the matrix with the specified value  <a href="a00807.html#ga39020f25c737f1e47a6439f791e9f11f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga58ecc7b31c7c7e5efa725afb7d0622ae">zeros</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gae32717b379f37e73ab8222c23d657910">zeros</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga8dfcb949372eef7a74ae8d7f2fc5b328">ones</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gab9e60d50d55b86b849125551d0880b61">ones</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga56ea72dc353369acfc6814db43f84c16">save</a> (const std::string name, const <a class="el" href="a00736.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a file  <a href="a00807.html#ga56ea72dc353369acfc6814db43f84c16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga4fc00e695a4d8f54350462550db41911">save</a> (std::ostream &amp;os, const <a class="el" href="a00736.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a stream  <a href="a00807.html#ga4fc00e695a4d8f54350462550db41911"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gadc2d8e5aa706f9e181f7d94bc5698eec">load</a> (const std::string name, const <a class="el" href="a00736.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a file  <a href="a00807.html#gadc2d8e5aa706f9e181f7d94bc5698eec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga6123cc842874d9930fa6e921033a6ae3">load</a> (std::istream &amp;is, const <a class="el" href="a00736.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a stream  <a href="a00807.html#ga6123cc842874d9930fa6e921033a6ae3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of rows in the matrix (read-only)  <a href="#aaa8c7e5e59361913b15ae55f714ca6c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a163bed70780a1d181594d126295d5a09">n_cols</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of columns in the matrix (read-only)  <a href="#a163bed70780a1d181594d126295d5a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of elements in the matrix (read-only)  <a href="#ab12257afbbe6338a7af830d9b65f3305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a912b66ceb203eb071b36b9e7d456ae3b">use_aux_mem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if externally managed memory is being used (read-only)  <a href="#a912b66ceb203eb071b36b9e7d456ae3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_aligned const eT *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a14a6badc8098d810e5decb22272a07b0">mem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to the memory used by the matrix (memory is read-only)  <a href="#a14a6badc8098d810e5decb22272a07b0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga03f8a60c95132e2b3774b596fd2207c4">init</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal matrix construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new'  <a href="a00807.html#ga03f8a60c95132e2b3774b596fd2207c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga0609204fa5e3cc7f5cdb287e80cbb024">init</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal function to create the matrix from a textual description  <a href="a00807.html#ga0609204fa5e3cc7f5cdb287e80cbb024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#gabe7e3bca86c58b8961c8eac06f289ae2">init</a> (const <a class="el" href="a00303.html">Mat</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00807.html#gabe7e3bca86c58b8961c8eac06f289ae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00807.html#ga3a5c6e9b6facff2a906f90b43ac94dc8">Mat</a> (const char junk, const eT *aux_mem, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DANGEROUS! Construct a temporary matrix, using auxiliary memory. This constructor is NOT intended for usage by user code. Its sole purpose is to be used by the <a class="el" href="a00066.html" title="Dense cube class.">Cube</a> class.  <a href="a00807.html#ga3a5c6e9b6facff2a906f90b43ac94dc8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_aligned eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#aaef55ac7c591b3d6591a31c5651f2883">mem_local</a> [16]</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html#a5daaf3e85b382d2bab2de0e6fcff99a1">Cube&lt; eT &gt;</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename eT&gt;<br/>
 class Mat&lt; eT &gt;</h3>

<p>Dense matrix class. </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00023">23</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3b7c1109cca98fb4bf493b8be33c4299"></a><!-- doxytag: member="Mat::elem_type" ref="a3b7c1109cca98fb4bf493b8be33c4299" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the type of elements stored in the matrix </p>

<p>Reimplemented in <a class="el" href="a00058.html#aa7ec170924ed5ad130545919563c7e3c">Col&lt; eT &gt;</a>, and <a class="el" href="a00466.html#aec0f589b61e71a94e416afe386602275">Row&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00621_source.html#l00027">27</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a364ff14c17bd94689ca7284aea2af5c9"></a><!-- doxytag: member="Mat::pod_type" ref="a364ff14c17bd94689ca7284aea2af5c9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00187.html">get_pod_type</a>&lt;<a class="el" href="a00303.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a>&gt;::result <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#a364ff14c17bd94689ca7284aea2af5c9">pod_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex </p>

<p>Reimplemented in <a class="el" href="a00058.html#a1584d0c1fcd5cc903a31e65af6dae26e">Col&lt; eT &gt;</a>, and <a class="el" href="a00466.html#aec4f0a287b7df7e1618c1b06f5be0c38">Row&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00621_source.html#l00028">28</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5daaf3e85b382d2bab2de0e6fcff99a1"></a><!-- doxytag: member="Mat::Cube&lt; eT &gt;" ref="a5daaf3e85b382d2bab2de0e6fcff99a1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00066.html">Cube</a>&lt; eT &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00621_source.html#l00225">225</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aaa8c7e5e59361913b15ae55f714ca6c6"></a><!-- doxytag: member="Mat::n_rows" ref="aaa8c7e5e59361913b15ae55f714ca6c6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00030">30</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00670_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00668_source.html#l00060">op_trans::apply()</a>, <a class="el" href="a00666_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00664_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00662_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00660_source.html#l00027">op_shuffle::apply()</a>, <a class="el" href="a00658_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00656_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00653_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00647_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00645_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00642_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00640_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00634_source.html#l00025">op_flipud::apply()</a>, <a class="el" href="a00626_source.html#l00025">op_diagmat::apply()</a>, <a class="el" href="a00613_source.html#l00621">glue_times_diag::apply()</a>, <a class="el" href="a00613_source.html#l00382">glue_times::apply()</a>, <a class="el" href="a00604_source.html#l00036">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00603_source.html#l00223">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00603_source.html#l00038">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00602_source.html#l00221">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00602_source.html#l00037">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00604_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00602_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00613_source.html#l00137">glue_times::apply_inplace()</a>, <a class="el" href="a00544_source.html#l00389">eop_core&lt; eop_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00533_source.html#l00260">eglue_core&lt; eglue_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00544_source.html#l00297">eop_core&lt; eop_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00533_source.html#l00198">eglue_core&lt; eglue_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00613_source.html#l00189">glue_times::apply_inplace_plus()</a>, <a class="el" href="a00544_source.html#l00251">eop_core&lt; eop_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00533_source.html#l00167">eglue_core&lt; eglue_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00544_source.html#l00343">eop_core&lt; eop_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00533_source.html#l00229">eglue_core&lt; eglue_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00613_source.html#l00350">glue_times::apply_mixed()</a>, <a class="el" href="a00668_source.html#l00025">op_trans::apply_noalias()</a>, <a class="el" href="a00527_source.html#l00633">arma_assert_mul_size()</a>, <a class="el" href="a00527_source.html#l00323">arma_assert_same_size()</a>, <a class="el" href="a00555_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00620_source.html#l01950">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00514_source.html#l01084">auxlib::chol()</a>, <a class="el" href="a00620_source.html#l02059">Mat&lt; eT &gt;::colptr()</a>, <a class="el" href="a00620_source.html#l01064">Mat&lt; eT &gt;::cols()</a>, <a class="el" href="a00693_source.html#l00652">Row&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00620_source.html#l02293">Mat&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00520_source.html#l00682">Col&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00514_source.html#l00376">auxlib::det()</a>, <a class="el" href="a00620_source.html#l01140">Mat&lt; eT &gt;::diag()</a>, <a class="el" href="a00528_source.html#l00177">diagmat_proxy_check&lt; Mat&lt; eT &gt; &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00528_source.html#l00147">diagmat_proxy_check&lt; T1 &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00622_source.html#l00027">op_cor::direct_cor()</a>, <a class="el" href="a00605_source.html#l00026">glue_cor::direct_cor()</a>, <a class="el" href="a00624_source.html#l00027">op_cov::direct_cov()</a>, <a class="el" href="a00607_source.html#l00026">glue_cov::direct_cov()</a>, <a class="el" href="a00609_source.html#l00028">glue_kron::direct_kron()</a>, <a class="el" href="a00649_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00651_source.html#l00034">op_princomp::direct_princomp()</a>, <a class="el" href="a00632_source.html#l00142">op_dotext::direct_rowvec_diagmat_colvec()</a>, <a class="el" href="a00632_source.html#l00166">op_dotext::direct_rowvec_invdiagmat_colvec()</a>, <a class="el" href="a00632_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, <a class="el" href="a00632_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>, <a class="el" href="a00705_source.html#l00883">subview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00529_source.html#l00235">diagview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00514_source.html#l00913">auxlib::eig_gen()</a>, <a class="el" href="a00514_source.html#l00733">auxlib::eig_sym()</a>, <a class="el" href="a00705_source.html#l00721">subview&lt; eT &gt;::extract()</a>, <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00514_source.html#l00202">auxlib::inv_inplace()</a>, <a class="el" href="a00514_source.html#l00026">auxlib::inv_noalias()</a>, <a class="el" href="a00620_source.html#l02029">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00620_source.html#l02018">Mat&lt; eT &gt;::is_vec()</a>, <a class="el" href="a00531_source.html#l00901">diskio::load_arma_ascii()</a>, <a class="el" href="a00531_source.html#l00787">diskio::load_raw_ascii()</a>, <a class="el" href="a00514_source.html#l00523">auxlib::log_det()</a>, <a class="el" href="a00514_source.html#l00611">auxlib::lu()</a>, <a class="el" href="a00705_source.html#l00829">subview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00529_source.html#l00183">diagview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00613_source.html#l00367">glue_times::mul_storage_cost()</a>, <a class="el" href="a00620_source.html#l01926">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00705_source.html#l00802">subview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00529_source.html#l00157">diagview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00509_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00514_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00620_source.html#l00966">Mat&lt; eT &gt;::row()</a>, <a class="el" href="a00620_source.html#l01026">Mat&lt; eT &gt;::rows()</a>, <a class="el" href="a00531_source.html#l00560">diskio::save_arma_ascii()</a>, <a class="el" href="a00531_source.html#l00644">diskio::save_arma_binary()</a>, <a class="el" href="a00531_source.html#l00701">diskio::save_pgm_binary()</a>, <a class="el" href="a00531_source.html#l02482">diskio::save_ppm_binary()</a>, <a class="el" href="a00531_source.html#l00483">diskio::save_raw_ascii()</a>, <a class="el" href="a00705_source.html#l00856">subview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00529_source.html#l00209">diagview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00589_source.html#l00033">solve()</a>, <a class="el" href="a00514_source.html#l01557">auxlib::solve()</a>, <a class="el" href="a00514_source.html#l01594">auxlib::solve_od()</a>, <a class="el" href="a00514_source.html#l01658">auxlib::solve_ud()</a>, <a class="el" href="a00620_source.html#l01102">Mat&lt; eT &gt;::submat()</a>, <a class="el" href="a00514_source.html#l01220">auxlib::svd()</a>, <a class="el" href="a00620_source.html#l01216">Mat&lt; eT &gt;::swap_cols()</a>, <a class="el" href="a00620_source.html#l01188">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00697_source.html#l00239">running_stat_vec_aux::update_stats()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a163bed70780a1d181594d126295d5a09"></a><!-- doxytag: member="Mat::n_cols" ref="a163bed70780a1d181594d126295d5a09" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#a163bed70780a1d181594d126295d5a09">n_cols</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00031">31</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00670_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00668_source.html#l00060">op_trans::apply()</a>, <a class="el" href="a00666_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00664_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00662_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00660_source.html#l00027">op_shuffle::apply()</a>, <a class="el" href="a00658_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00656_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00653_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00647_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00645_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00642_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00640_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00634_source.html#l00059">op_fliplr::apply()</a>, <a class="el" href="a00613_source.html#l00621">glue_times_diag::apply()</a>, <a class="el" href="a00613_source.html#l00382">glue_times::apply()</a>, <a class="el" href="a00604_source.html#l00036">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00603_source.html#l00223">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00603_source.html#l00038">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00602_source.html#l00221">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00602_source.html#l00037">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00604_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00602_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00613_source.html#l00137">glue_times::apply_inplace()</a>, <a class="el" href="a00544_source.html#l00389">eop_core&lt; eop_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00533_source.html#l00260">eglue_core&lt; eglue_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00544_source.html#l00297">eop_core&lt; eop_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00533_source.html#l00198">eglue_core&lt; eglue_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00613_source.html#l00189">glue_times::apply_inplace_plus()</a>, <a class="el" href="a00544_source.html#l00251">eop_core&lt; eop_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00533_source.html#l00167">eglue_core&lt; eglue_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00544_source.html#l00343">eop_core&lt; eop_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00533_source.html#l00229">eglue_core&lt; eglue_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00613_source.html#l00350">glue_times::apply_mixed()</a>, <a class="el" href="a00668_source.html#l00025">op_trans::apply_noalias()</a>, <a class="el" href="a00527_source.html#l00633">arma_assert_mul_size()</a>, <a class="el" href="a00527_source.html#l00323">arma_assert_same_size()</a>, <a class="el" href="a00555_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00620_source.html#l00996">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00620_source.html#l01064">Mat&lt; eT &gt;::cols()</a>, <a class="el" href="a00693_source.html#l00652">Row&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00620_source.html#l02293">Mat&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00520_source.html#l00682">Col&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00514_source.html#l00376">auxlib::det()</a>, <a class="el" href="a00620_source.html#l01140">Mat&lt; eT &gt;::diag()</a>, <a class="el" href="a00528_source.html#l00177">diagmat_proxy_check&lt; Mat&lt; eT &gt; &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00528_source.html#l00147">diagmat_proxy_check&lt; T1 &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00609_source.html#l00028">glue_kron::direct_kron()</a>, <a class="el" href="a00649_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00651_source.html#l00034">op_princomp::direct_princomp()</a>, <a class="el" href="a00632_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, <a class="el" href="a00632_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>, <a class="el" href="a00705_source.html#l00883">subview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00529_source.html#l00235">diagview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00514_source.html#l00913">auxlib::eig_gen()</a>, <a class="el" href="a00514_source.html#l00733">auxlib::eig_sym()</a>, <a class="el" href="a00705_source.html#l00721">subview&lt; eT &gt;::extract()</a>, <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00514_source.html#l00202">auxlib::inv_inplace()</a>, <a class="el" href="a00514_source.html#l00026">auxlib::inv_noalias()</a>, <a class="el" href="a00620_source.html#l02029">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00620_source.html#l02018">Mat&lt; eT &gt;::is_vec()</a>, <a class="el" href="a00531_source.html#l00901">diskio::load_arma_ascii()</a>, <a class="el" href="a00531_source.html#l00787">diskio::load_raw_ascii()</a>, <a class="el" href="a00514_source.html#l00523">auxlib::log_det()</a>, <a class="el" href="a00514_source.html#l00611">auxlib::lu()</a>, <a class="el" href="a00620_source.html#l00617">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00705_source.html#l00829">subview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00529_source.html#l00183">diagview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00613_source.html#l00367">glue_times::mul_storage_cost()</a>, <a class="el" href="a00620_source.html#l01926">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00705_source.html#l00802">subview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00529_source.html#l00157">diagview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00509_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00514_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00620_source.html#l01026">Mat&lt; eT &gt;::rows()</a>, <a class="el" href="a00531_source.html#l00560">diskio::save_arma_ascii()</a>, <a class="el" href="a00531_source.html#l00644">diskio::save_arma_binary()</a>, <a class="el" href="a00531_source.html#l00701">diskio::save_pgm_binary()</a>, <a class="el" href="a00531_source.html#l02482">diskio::save_ppm_binary()</a>, <a class="el" href="a00531_source.html#l00483">diskio::save_raw_ascii()</a>, <a class="el" href="a00705_source.html#l00856">subview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00529_source.html#l00209">diagview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00514_source.html#l01557">auxlib::solve()</a>, <a class="el" href="a00514_source.html#l01594">auxlib::solve_od()</a>, <a class="el" href="a00514_source.html#l01658">auxlib::solve_ud()</a>, <a class="el" href="a00620_source.html#l01102">Mat&lt; eT &gt;::submat()</a>, <a class="el" href="a00514_source.html#l01220">auxlib::svd()</a>, <a class="el" href="a00620_source.html#l01216">Mat&lt; eT &gt;::swap_cols()</a>, <a class="el" href="a00620_source.html#l01188">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00697_source.html#l00239">running_stat_vec_aux::update_stats()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="ab12257afbbe6338a7af830d9b65f3305"></a><!-- doxytag: member="Mat::n_elem" ref="ab12257afbbe6338a7af830d9b65f3305" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of elements in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00032">32</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00576_source.html#l00438">abs()</a>, <a class="el" href="a00670_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00668_source.html#l00190">op_trans2::apply()</a>, <a class="el" href="a00666_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00664_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00662_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00658_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00656_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00653_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00647_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00645_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00642_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00640_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00626_source.html#l00025">op_diagmat::apply()</a>, <a class="el" href="a00603_source.html#l00417">gemm_mixed&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00602_source.html#l00494">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00052">as_scalar_redirect&lt; N &gt;::apply()</a>, <a class="el" href="a00604_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00602_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00668_source.html#l00025">op_trans::apply_noalias()</a>, <a class="el" href="a00630_source.html#l00173">op_norm_dot::apply_unwrap()</a>, <a class="el" href="a00630_source.html#l00098">op_dot::apply_unwrap()</a>, <a class="el" href="a00555_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00605_source.html#l00026">glue_cor::direct_cor()</a>, <a class="el" href="a00607_source.html#l00026">glue_cov::direct_cov()</a>, <a class="el" href="a00649_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00651_source.html#l00276">op_princomp::direct_princomp()</a>, <a class="el" href="a00632_source.html#l00190">op_dotext::direct_rowvec_invdiagvec_colvec()</a>, <a class="el" href="a00620_source.html#l02306">Mat&lt; eT &gt;::fill()</a>, <a class="el" href="a00557_source.html#l00607">conv_to&lt; Col&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00557_source.html#l00380">conv_to&lt; Row&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00557_source.html#l00234">conv_to&lt; Mat&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00557_source.html#l00095">conv_to&lt; out_eT &gt;::from()</a>, <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00620_source.html#l02040">Mat&lt; eT &gt;::is_finite()</a>, <a class="el" href="a00620_source.html#l02029">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00531_source.html#l00976">diskio::load_arma_binary()</a>, <a class="el" href="a00531_source.html#l01070">diskio::load_pgm_binary()</a>, <a class="el" href="a00531_source.html#l02139">diskio::load_ppm_binary()</a>, <a class="el" href="a00620_source.html#l00442">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00572_source.html#l00044">max()</a>, <a class="el" href="a00573_source.html#l00038">mean()</a>, <a class="el" href="a00574_source.html#l00036">median()</a>, <a class="el" href="a00575_source.html#l00043">min()</a>, <a class="el" href="a00685_source.html#l00046">operator%()</a>, <a class="el" href="a00620_source.html#l00566">Mat&lt; eT &gt;::operator%=()</a>, <a class="el" href="a00620_source.html#l01881">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00620_source.html#l00354">Mat&lt; eT &gt;::operator*=()</a>, <a class="el" href="a00683_source.html#l00086">operator+()</a>, <a class="el" href="a00620_source.html#l00318">Mat&lt; eT &gt;::operator+=()</a>, <a class="el" href="a00681_source.html#l00106">operator-()</a>, <a class="el" href="a00620_source.html#l00336">Mat&lt; eT &gt;::operator-=()</a>, <a class="el" href="a00680_source.html#l00078">operator/()</a>, <a class="el" href="a00620_source.html#l00372">Mat&lt; eT &gt;::operator/=()</a>, <a class="el" href="a00620_source.html#l02612">Mat_aux::postfix_mm()</a>, <a class="el" href="a00620_source.html#l02556">Mat_aux::postfix_pp()</a>, <a class="el" href="a00620_source.html#l02584">Mat_aux::prefix_mm()</a>, <a class="el" href="a00620_source.html#l02528">Mat_aux::prefix_pp()</a>, <a class="el" href="a00509_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00581_source.html#l00046">prod()</a>, <a class="el" href="a00514_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00585_source.html#l00026">rank()</a>, <a class="el" href="a00531_source.html#l00644">diskio::save_arma_binary()</a>, <a class="el" href="a00531_source.html#l00701">diskio::save_pgm_binary()</a>, <a class="el" href="a00531_source.html#l02274">diskio::save_ppm_binary()</a>, <a class="el" href="a00592_source.html#l00048">stddev()</a>, <a class="el" href="a00697_source.html#l00239">running_stat_vec_aux::update_stats()</a>, <a class="el" href="a00598_source.html#l00048">var()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a912b66ceb203eb071b36b9e7d456ae3b"></a><!-- doxytag: member="Mat::use_aux_mem" ref="a912b66ceb203eb071b36b9e7d456ae3b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#a912b66ceb203eb071b36b9e7d456ae3b">use_aux_mem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true if externally managed memory is being used (read-only) </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00033">33</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a14a6badc8098d810e5decb22272a07b0"></a><!-- doxytag: member="Mat::mem" ref="a14a6badc8098d810e5decb22272a07b0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_aligned const eT* const <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#a14a6badc8098d810e5decb22272a07b0">mem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the memory used by the matrix (memory is read-only) </p>

<p>Definition at line <a class="el" href="a00621_source.html#l00035">35</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00555_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00052">as_scalar_redirect&lt; N &gt;::apply()</a>, <a class="el" href="a00604_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00602_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00668_source.html#l00025">op_trans::apply_noalias()</a>, <a class="el" href="a00630_source.html#l00098">op_dot::apply_unwrap()</a>, <a class="el" href="a00555_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00620_source.html#l01950">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00620_source.html#l02059">Mat&lt; eT &gt;::colptr()</a>, <a class="el" href="a00632_source.html#l00190">op_dotext::direct_rowvec_invdiagvec_colvec()</a>, <a class="el" href="a00620_source.html#l02306">Mat&lt; eT &gt;::fill()</a>, <a class="el" href="a00557_source.html#l00095">conv_to&lt; out_eT &gt;::from()</a>, <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00620_source.html#l02040">Mat&lt; eT &gt;::is_finite()</a>, <a class="el" href="a00620_source.html#l00617">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00572_source.html#l00044">max()</a>, <a class="el" href="a00573_source.html#l00038">mean()</a>, <a class="el" href="a00574_source.html#l00036">median()</a>, <a class="el" href="a00620_source.html#l02081">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00575_source.html#l00043">min()</a>, <a class="el" href="a00620_source.html#l01881">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00620_source.html#l00354">Mat&lt; eT &gt;::operator*=()</a>, <a class="el" href="a00620_source.html#l00318">Mat&lt; eT &gt;::operator+=()</a>, <a class="el" href="a00620_source.html#l00336">Mat&lt; eT &gt;::operator-=()</a>, <a class="el" href="a00620_source.html#l00372">Mat&lt; eT &gt;::operator/=()</a>, <a class="el" href="a00620_source.html#l00303">Mat&lt; eT &gt;::operator=()</a>, <a class="el" href="a00620_source.html#l01904">Mat&lt; eT &gt;::operator[]()</a>, <a class="el" href="a00514_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00531_source.html#l00644">diskio::save_arma_binary()</a>, <a class="el" href="a00592_source.html#l00048">stddev()</a>, <a class="el" href="a00620_source.html#l01188">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00598_source.html#l00048">var()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="aaef55ac7c591b3d6591a31c5651f2883"></a><!-- doxytag: member="Mat::mem_local" ref="aaef55ac7c591b3d6591a31c5651f2883" args="[16]" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_aligned eT <a class="el" href="a00303.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00303.html#aaef55ac7c591b3d6591a31c5651f2883">mem_local</a>[16]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00621_source.html#l00038">38</a> of file <a class="el" href="a00621_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00620_source.html#l00085">Mat&lt; eT &gt;::init()</a>, and <a class="el" href="a00620_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
</div>
</BODY>
</HTML>
