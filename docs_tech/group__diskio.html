<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Diskio</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Diskio</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdiskio.html">diskio</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class for saving and loading matrices and fields  <a href="classdiskio.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#gaf047b6ce458f7c55fd215920656d128">file_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41">auto_detect</a>, 
<a class="el" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3">raw_ascii</a>, 
<a class="el" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c">arma_ascii</a>, 
<a class="el" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda">pgm_binary</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">file types supported by Armadillo  <a href="group__diskio.html#gaf047b6ce458f7c55fd215920656d128">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g22c179c5a6705741cff72f9295b23f79">diskio::gen_txt_header</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gbc65ebb995dd7cbffba8842d36c0e6a7">diskio::gen_bin_header</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#gf1b98a9e26843fbaad5a12d626053023">diskio::conv_to_hex_char</a> (const <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#ge1927b3ea8735a7d1e77d89405f592e3">diskio::conv_to_hex</a> (char *out, const <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71">diskio::gen_tmp_name</a> (const std::string &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="group__fn__rand.html#gdd1491dd38148093e6a9519a0eef4b06" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="group__fn__rand.html#gdd1491dd38148093e6a9519a0eef4b06" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="#g81ac9508b1ee96fd24338a9701aeda71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1">diskio::safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="#g21a278d6cee27f2800429aadceaff8b1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g077c37485d87c3ca187f4ec56192ae58">diskio::save_raw_ascii</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Non-complex matrices can be loaded in Matlab and Octave.  <a href="#g077c37485d87c3ca187f4ec56192ae58"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g9331c75698f09560ae427a0f74a6c59d">diskio::save_arma_ascii</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#g9331c75698f09560ae427a0f74a6c59d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gb8dcc462da6d62f290909acf97b751e0">diskio::save_arma_ascii</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#gb8dcc462da6d62f290909acf97b751e0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gb304b81c3d440ff3766b1a3b190fc1b5">diskio::save_arma_binary</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gb304b81c3d440ff3766b1a3b190fc1b5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gab4461cbf8d32275f7d713c995d810eb">diskio::save_arma_binary</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gab4461cbf8d32275f7d713c995d810eb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g46e49b311699b638a37751159980561a">diskio::save_pgm_binary</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#g46e49b311699b638a37751159980561a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g705f30f14248914e58e3fe339ed3ee36">diskio::save_pgm_binary</a> (const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#g705f30f14248914e58e3fe339ed3ee36"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g3b44059e711756fadb143ecb54ad7eed">diskio::load_raw_ascii</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="#g3b44059e711756fadb143ecb54ad7eed"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gd5482bd91c68103b1abe4709d0963be6">diskio::load_arma_ascii</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#gd5482bd91c68103b1abe4709d0963be6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gd6a8ad5a4b38f11e812b0a7aeab0d602">diskio::load_arma_ascii</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#gd6a8ad5a4b38f11e812b0a7aeab0d602"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gcb3671873f490a683a8a7f4110850ee4">diskio::load_arma_binary</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="#gcb3671873f490a683a8a7f4110850ee4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g418ad1e934d18dd0841ea2a151733bfc">diskio::load_arma_binary</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__diskio.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a> (std::fstream &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gb53e35d2a478557024269558d5473334">diskio::load_pgm_binary</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#gb53e35d2a478557024269558d5473334"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g7c9536c492a9434d528ff81ea79ea2ee">diskio::load_pgm_binary</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#g7c9536c492a9434d528ff81ea79ea2ee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#ge7528cc26228ed69b8150dabd99a7ba6">diskio::load_auto_detect</a> (<a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="#ge7528cc26228ed69b8150dabd99a7ba6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#gce4d7fca68dc1e877b1886a360c32931">diskio::save_field</a> (const <a class="el" href="classfield.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__diskio.html#g0b5433d75c86772140fb29099e299c52">diskio::load_field</a> (<a class="el" href="classfield.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gaf047b6ce458f7c55fd215920656d128"></a><!-- doxytag: member="forward_proto.hpp::file_type" ref="gaf047b6ce458f7c55fd215920656d128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__diskio.html#gaf047b6ce458f7c55fd215920656d128">file_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
file types supported by Armadillo 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41"></a><!-- doxytag: member="auto_detect" ref="ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41" args="" -->auto_detect</em>&nbsp;</td><td>
Automatically detect the file type (file must be one of the following types). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3"></a><!-- doxytag: member="raw_ascii" ref="ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3" args="" -->raw_ascii</em>&nbsp;</td><td>
ASCII format (text), without any other information. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c"></a><!-- doxytag: member="arma_ascii" ref="ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c" args="" -->arma_ascii</em>&nbsp;</td><td>
Armadillo ASCII format (text), with information about matrix type and size. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6"></a><!-- doxytag: member="arma_binary" ref="ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6" args="" -->arma_binary</em>&nbsp;</td><td>
Armadillo binary format. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda"></a><!-- doxytag: member="pgm_binary" ref="ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda" args="" -->pgm_binary</em>&nbsp;</td><td>
Portable Grey Map (image). </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="forward__proto_8hpp-source.html#l00075">75</a> of file <a class="el" href="forward__proto_8hpp-source.html">forward_proto.hpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00076"></a>00076   {
<a name="l00077"></a>00077   <a class="code" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128b23ff78608de192c57782353f7562e41" title="Automatically detect the file type (file must be one of the following types).">auto_detect</a>,  <span class="comment">//!&lt; Automatically detect the file type (file must be one of the following types)</span>
<a name="l00078"></a>00078 <span class="comment"></span>  <a class="code" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>,    <span class="comment">//!&lt; ASCII format (text), without any other information.</span>
<a name="l00079"></a>00079 <span class="comment"></span>  <a class="code" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d128a8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>,   <span class="comment">//!&lt; Armadillo ASCII format (text), with information about matrix type and size</span>
<a name="l00080"></a>00080 <span class="comment"></span>  <a class="code" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d12884c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>,  <span class="comment">//!&lt; Armadillo binary format</span>
<a name="l00081"></a>00081 <span class="comment"></span>  <a class="code" href="group__diskio.html#ggaf047b6ce458f7c55fd215920656d1280b14fb78700351dca695ede008144dda" title="Portable Grey Map (image).">pgm_binary</a>    <span class="comment">//!&lt; Portable Grey Map (image)</span>
<a name="l00082"></a>00082 <span class="comment"></span>  };
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g22c179c5a6705741cff72f9295b23f79"></a><!-- doxytag: member="diskio::gen_txt_header" ref="g22c179c5a6705741cff72f9295b23f79" args="(const basic_mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00023">23</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00692">load_arma_ascii()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00387">save_arma_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00024"></a>00024   {
<a name="l00025"></a>00025   <a class="code" href="structarma__type__check.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00026"></a>00026 
<a name="l00027"></a>00027   <span class="keywordflow">if</span>(<a class="code" href="structis__u8.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00028"></a>00028     {
<a name="l00029"></a>00029     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU001"</span>);
<a name="l00030"></a>00030     }
<a name="l00031"></a>00031   <span class="keywordflow">else</span>
<a name="l00032"></a>00032   <span class="keywordflow">if</span>(<a class="code" href="structis__s8.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS001"</span>);
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036   <span class="keywordflow">else</span>
<a name="l00037"></a>00037   <span class="keywordflow">if</span>(<a class="code" href="structis__u16.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00038"></a>00038     {
<a name="l00039"></a>00039     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU002"</span>);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041   <span class="keywordflow">else</span>
<a name="l00042"></a>00042   <span class="keywordflow">if</span>(<a class="code" href="structis__s16.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS002"</span>);
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046   <span class="keywordflow">else</span>
<a name="l00047"></a>00047   <span class="keywordflow">if</span>(<a class="code" href="structis__u32.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00048"></a>00048     {
<a name="l00049"></a>00049     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IU004"</span>);
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051   <span class="keywordflow">else</span>
<a name="l00052"></a>00052   <span class="keywordflow">if</span>(<a class="code" href="structis__s32.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_IS004"</span>);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056   <span class="keywordflow">else</span>
<a name="l00057"></a>00057   <span class="keywordflow">if</span>(<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FN004"</span>);
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061   <span class="keywordflow">else</span>
<a name="l00062"></a>00062   <span class="keywordflow">if</span>(<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FN008"</span>);
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   <span class="keywordflow">else</span>
<a name="l00067"></a>00067   <span class="keywordflow">if</span>(<a class="code" href="structis__complex__float.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00068"></a>00068     {
<a name="l00069"></a>00069     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FC008"</span>);
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071   <span class="keywordflow">else</span>
<a name="l00072"></a>00072   <span class="keywordflow">if</span>(<a class="code" href="structis__complex__double.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00073"></a>00073     {
<a name="l00074"></a>00074     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_TXT_FC016"</span>);
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076   <span class="keywordflow">else</span>
<a name="l00077"></a>00077     {
<a name="l00078"></a>00078     <span class="keywordflow">return</span> std::string();
<a name="l00079"></a>00079     }
<a name="l00080"></a>00080   
<a name="l00081"></a>00081   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gbc65ebb995dd7cbffba8842d36c0e6a7"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gbc65ebb995dd7cbffba8842d36c0e6a7" args="(const basic_mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00088">88</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00768">load_arma_binary()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00471">save_arma_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00089"></a>00089   {
<a name="l00090"></a>00090   <a class="code" href="structarma__type__check.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00091"></a>00091   
<a name="l00092"></a>00092   <span class="keywordflow">if</span>(<a class="code" href="structis__u8.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00093"></a>00093     {
<a name="l00094"></a>00094     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU001"</span>);
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096   <span class="keywordflow">else</span>
<a name="l00097"></a>00097   <span class="keywordflow">if</span>(<a class="code" href="structis__s8.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00098"></a>00098     {
<a name="l00099"></a>00099     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS001"</span>);
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101   <span class="keywordflow">else</span>
<a name="l00102"></a>00102   <span class="keywordflow">if</span>(<a class="code" href="structis__u16.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU002"</span>);
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   <span class="keywordflow">else</span>
<a name="l00107"></a>00107   <span class="keywordflow">if</span>(<a class="code" href="structis__s16.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS002"</span>);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111   <span class="keywordflow">else</span>
<a name="l00112"></a>00112   <span class="keywordflow">if</span>(<a class="code" href="structis__u32.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IU004"</span>);
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116   <span class="keywordflow">else</span>
<a name="l00117"></a>00117   <span class="keywordflow">if</span>(<a class="code" href="structis__s32.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_IS004"</span>);
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121   <span class="keywordflow">if</span>(<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00122"></a>00122     {
<a name="l00123"></a>00123     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FN004"</span>);
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125   <span class="keywordflow">else</span>
<a name="l00126"></a>00126   <span class="keywordflow">if</span>(<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00127"></a>00127     {
<a name="l00128"></a>00128     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FN008"</span>);
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130   <span class="keywordflow">else</span>
<a name="l00131"></a>00131   <span class="keywordflow">if</span>(<a class="code" href="structis__complex__float.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00132"></a>00132     {
<a name="l00133"></a>00133     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FC008"</span>);
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135   <span class="keywordflow">else</span>
<a name="l00136"></a>00136   <span class="keywordflow">if</span>(<a class="code" href="structis__complex__double.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00137"></a>00137     {
<a name="l00138"></a>00138     <span class="keywordflow">return</span> std::string(<span class="stringliteral">"ARMA_MAT_BIN_FC016"</span>);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140   <span class="keywordflow">else</span>
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142     <span class="keywordflow">return</span> std::string();
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144   
<a name="l00145"></a>00145   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf1b98a9e26843fbaad5a12d626053023"></a><!-- doxytag: member="diskio::conv_to_hex_char" ref="gf1b98a9e26843fbaad5a12d626053023" args="(const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char diskio::conv_to_hex_char           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00151">151</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00182">conv_to_hex()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00152"></a>00152   {
<a name="l00153"></a>00153   <span class="keywordtype">char</span> out;
<a name="l00154"></a>00154   <span class="keywordflow">switch</span>(x)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156     <span class="keywordflow">case</span>  0: out = <span class="charliteral">'0'</span>; <span class="keywordflow">break</span>;
<a name="l00157"></a>00157     <span class="keywordflow">case</span>  1: out = <span class="charliteral">'1'</span>; <span class="keywordflow">break</span>;
<a name="l00158"></a>00158     <span class="keywordflow">case</span>  2: out = <span class="charliteral">'2'</span>; <span class="keywordflow">break</span>;
<a name="l00159"></a>00159     <span class="keywordflow">case</span>  3: out = <span class="charliteral">'3'</span>; <span class="keywordflow">break</span>;
<a name="l00160"></a>00160     <span class="keywordflow">case</span>  4: out = <span class="charliteral">'4'</span>; <span class="keywordflow">break</span>;
<a name="l00161"></a>00161     <span class="keywordflow">case</span>  5: out = <span class="charliteral">'5'</span>; <span class="keywordflow">break</span>;
<a name="l00162"></a>00162     <span class="keywordflow">case</span>  6: out = <span class="charliteral">'6'</span>; <span class="keywordflow">break</span>;
<a name="l00163"></a>00163     <span class="keywordflow">case</span>  7: out = <span class="charliteral">'7'</span>; <span class="keywordflow">break</span>;
<a name="l00164"></a>00164     <span class="keywordflow">case</span>  8: out = <span class="charliteral">'8'</span>; <span class="keywordflow">break</span>;
<a name="l00165"></a>00165     <span class="keywordflow">case</span>  9: out = <span class="charliteral">'9'</span>; <span class="keywordflow">break</span>;
<a name="l00166"></a>00166     <span class="keywordflow">case</span> 10: out = <span class="charliteral">'a'</span>; <span class="keywordflow">break</span>;
<a name="l00167"></a>00167     <span class="keywordflow">case</span> 11: out = <span class="charliteral">'b'</span>; <span class="keywordflow">break</span>;
<a name="l00168"></a>00168     <span class="keywordflow">case</span> 12: out = <span class="charliteral">'c'</span>; <span class="keywordflow">break</span>;
<a name="l00169"></a>00169     <span class="keywordflow">case</span> 13: out = <span class="charliteral">'d'</span>; <span class="keywordflow">break</span>;
<a name="l00170"></a>00170     <span class="keywordflow">case</span> 14: out = <span class="charliteral">'e'</span>; <span class="keywordflow">break</span>;
<a name="l00171"></a>00171     <span class="keywordflow">case</span> 15: out = <span class="charliteral">'f'</span>; <span class="keywordflow">break</span>;
<a name="l00172"></a>00172     <span class="keywordflow">default</span>: out = <span class="charliteral">'-'</span>; <span class="keywordflow">break</span>;
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="keywordflow">return</span> out;  
<a name="l00176"></a>00176   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ge1927b3ea8735a7d1e77d89405f592e3"></a><!-- doxytag: member="diskio::conv_to_hex" ref="ge1927b3ea8735a7d1e77d89405f592e3" args="(char *out, const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::conv_to_hex           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00182">182</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="diskio__meat_8hpp-source.html#l00151">conv_to_hex_char()</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00183"></a>00183   {
<a name="l00184"></a>00184   <span class="keyword">const</span> <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> a = x / 16;
<a name="l00185"></a>00185   <span class="keyword">const</span> <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> b = x - 16*a;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   out[0] = <a class="code" href="group__diskio.html#gf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(a);
<a name="l00188"></a>00188   out[1] = <a class="code" href="group__diskio.html#gf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(b);
<a name="l00189"></a>00189   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g81ac9508b1ee96fd24338a9701aeda71"></a><!-- doxytag: member="diskio::gen_tmp_name" ref="g81ac9508b1ee96fd24338a9701aeda71" args="(const std::string &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_tmp_name           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a quasi-random string to the given filename. The <a class="el" href="group__fn__rand.html#gdd1491dd38148093e6a9519a0eef4b06" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="group__fn__rand.html#gdd1491dd38148093e6a9519a0eef4b06" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00202">202</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="diskio__meat_8hpp-source.html#l00182">conv_to_hex()</a>, and <a class="el" href="fn__sum_8hpp-source.html#l00031">sum()</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00357">save_arma_ascii()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00441">save_arma_binary()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l01025">save_field()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00499">save_pgm_binary()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00293">save_raw_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00203"></a>00203   {
<a name="l00204"></a>00204   <span class="keyword">const</span> std::string* ptr_x = &amp;x;
<a name="l00205"></a>00205   <span class="keyword">const</span> <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>* ptr_ptr_x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*<span class="keyword">&gt;</span>(&amp;ptr_x);
<a name="l00206"></a>00206   
<a name="l00207"></a>00207   <span class="keyword">const</span> <span class="keywordtype">char</span>* extra = <span class="stringliteral">".tmp_"</span>;
<a name="l00208"></a>00208   <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> extra_size = 5;
<a name="l00209"></a>00209   
<a name="l00210"></a>00210   <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> tmp_size = 2*<span class="keyword">sizeof</span>(<a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*) + 2*2;
<a name="l00211"></a>00211   <span class="keywordtype">char</span> tmp[tmp_size];
<a name="l00212"></a>00212   
<a name="l00213"></a>00213   <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> char_count = 0;
<a name="l00214"></a>00214   
<a name="l00215"></a>00215   <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<span class="keyword">sizeof</span>(<a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*); ++i)
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217     <a class="code" href="group__diskio.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], ptr_ptr_x[i]);
<a name="l00218"></a>00218     char_count += 2;
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220   
<a name="l00221"></a>00221   <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> x_size = x.size();
<a name="l00222"></a>00222   <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> <a class="code" href="group__fn__sum.html#g362f1ad7163958e6b9b30c4395ead76d" title="Delayed sum of elements of a matrix along a specified dimension (either rows or columns)...">sum</a> = 0;
<a name="l00223"></a>00223   
<a name="l00224"></a>00224   <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226     sum += <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x[i]);
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228   
<a name="l00229"></a>00229   <a class="code" href="group__diskio.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], sum);
<a name="l00230"></a>00230   char_count += 2;
<a name="l00231"></a>00231   
<a name="l00232"></a>00232   <a class="code" href="group__diskio.html#ge1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x_size));
<a name="l00233"></a>00233   
<a name="l00234"></a>00234   
<a name="l00235"></a>00235   std::string out;
<a name="l00236"></a>00236   out.resize(x_size + extra_size + tmp_size);
<a name="l00237"></a>00237   
<a name="l00238"></a>00238   
<a name="l00239"></a>00239   <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00240"></a>00240     {
<a name="l00241"></a>00241     out[i] = x[i];
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243   
<a name="l00244"></a>00244   <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;extra_size; ++i)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246     out[x_size + i] = extra[i];
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248   
<a name="l00249"></a>00249   <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;tmp_size; ++i)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251     out[x_size + extra_size + i] = tmp[i];
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253   
<a name="l00254"></a>00254   <span class="keywordflow">return</span> out;
<a name="l00255"></a>00255   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g21a278d6cee27f2800429aadceaff8b1"></a><!-- doxytag: member="diskio::safe_rename" ref="g21a278d6cee27f2800429aadceaff8b1" args="(const std::string &amp;old_name, const std::string &amp;new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::safe_rename           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>new_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00266">266</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00357">save_arma_ascii()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00441">save_arma_binary()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l01025">save_field()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00499">save_pgm_binary()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00293">save_raw_ascii()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00267"></a>00267   {
<a name="l00268"></a>00268   std::fstream f(new_name.c_str(), std::fstream::out | std::fstream::app);
<a name="l00269"></a>00269   f.put(<span class="charliteral">' '</span>);
<a name="l00270"></a>00270   
<a name="l00271"></a>00271   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00272"></a>00272   f.close();
<a name="l00273"></a>00273   
<a name="l00274"></a>00274   <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, new_name );
<a name="l00275"></a>00275   
<a name="l00276"></a>00276   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00277"></a>00277     {
<a name="l00278"></a>00278     std::remove(new_name.c_str());
<a name="l00279"></a>00279     
<a name="l00280"></a>00280     <span class="keyword">const</span> <span class="keywordtype">int</span> mv_result = std::rename(old_name.c_str(), new_name.c_str());
<a name="l00281"></a>00281     <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>( (mv_result != 0), <span class="stringliteral">"trouble writing "</span>, new_name );
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283   
<a name="l00284"></a>00284   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g077c37485d87c3ca187f4ec56192ae58"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="g077c37485d87c3ca187f4ec56192ae58" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as raw text (no header, human readable). Non-complex matrices can be loaded in Matlab and Octave. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00293">293</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01302">basic_mat&lt; eT &gt;::at()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00266">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01461">basic_mat&lt; eT &gt;::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00294"></a>00294   {
<a name="l00295"></a>00295   arma_extra_debug_sigprint();
<a name="l00296"></a>00296   
<a name="l00297"></a>00297   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00298"></a>00298   
<a name="l00299"></a>00299   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l00300"></a>00300   
<a name="l00301"></a>00301   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00302"></a>00302     {
<a name="l00303"></a>00303     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, tmp_name);
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305   <span class="keywordflow">else</span>
<a name="l00306"></a>00306     {
<a name="l00307"></a>00307     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00308"></a>00308     
<a name="l00309"></a>00309     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00310"></a>00310     
<a name="l00311"></a>00311     <span class="keywordflow">if</span>( (<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00312"></a>00312       {
<a name="l00313"></a>00313       f.setf(ios::scientific);
<a name="l00314"></a>00314       f.precision(8);
<a name="l00315"></a>00315       cell_width = 16;
<a name="l00316"></a>00316       }
<a name="l00317"></a>00317     
<a name="l00318"></a>00318     <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00319"></a>00319       {
<a name="l00320"></a>00320       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00321"></a>00321         {
<a name="l00322"></a>00322         f.put(<span class="charliteral">' '</span>);
<a name="l00323"></a>00323         
<a name="l00324"></a>00324         <span class="keywordflow">if</span>( (<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00325"></a>00325           {
<a name="l00326"></a>00326           f.width(cell_width);
<a name="l00327"></a>00327           }
<a name="l00328"></a>00328         
<a name="l00329"></a>00329         f &lt;&lt; x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00330"></a>00330         }
<a name="l00331"></a>00331         
<a name="l00332"></a>00332       f.put(<span class="charliteral">'\n'</span>);
<a name="l00333"></a>00333       }
<a name="l00334"></a>00334     
<a name="l00335"></a>00335     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00336"></a>00336     
<a name="l00337"></a>00337     <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00338"></a>00338     
<a name="l00339"></a>00339     f.flush();
<a name="l00340"></a>00340     f.close();
<a name="l00341"></a>00341     
<a name="l00342"></a>00342     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00343"></a>00343       {
<a name="l00344"></a>00344       <a class="code" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00345"></a>00345       }
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347   
<a name="l00348"></a>00348   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g9331c75698f09560ae427a0f74a6c59d"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="g9331c75698f09560ae427a0f74a6c59d" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00357">357</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00266">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01461">basic_mat&lt; eT &gt;::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00358"></a>00358   {
<a name="l00359"></a>00359   arma_extra_debug_sigprint();
<a name="l00360"></a>00360   
<a name="l00361"></a>00361   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00362"></a>00362   
<a name="l00363"></a>00363   std::ofstream f(tmp_name.c_str());
<a name="l00364"></a>00364   
<a name="l00365"></a>00365   <a class="code" href="group__diskio.html#g9331c75698f09560ae427a0f74a6c59d" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l00366"></a>00366   
<a name="l00367"></a>00367   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00368"></a>00368   
<a name="l00369"></a>00369   f.flush();
<a name="l00370"></a>00370   f.close();
<a name="l00371"></a>00371   
<a name="l00372"></a>00372   <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00373"></a>00373   
<a name="l00374"></a>00374   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00375"></a>00375     {
<a name="l00376"></a>00376     <a class="code" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gb8dcc462da6d62f290909acf97b751e0"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="gb8dcc462da6d62f290909acf97b751e0" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00387">387</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="basic__mat__meat_8hpp-source.html#l01302">basic_mat&lt; eT &gt;::at()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00023">gen_txt_header()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00388"></a>00388   {
<a name="l00389"></a>00389   arma_extra_debug_sigprint();
<a name="l00390"></a>00390   
<a name="l00391"></a>00391   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393     arma_debug_print(<span class="stringliteral">"unable to write "</span>, name);
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395   <span class="keywordflow">else</span>
<a name="l00396"></a>00396     {
<a name="l00397"></a>00397     <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l00398"></a>00398     
<a name="l00399"></a>00399     f &lt;&lt; <a class="code" href="group__diskio.html#g22c179c5a6705741cff72f9295b23f79">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00400"></a>00400     f &lt;&lt; x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00401"></a>00401     
<a name="l00402"></a>00402     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00403"></a>00403     
<a name="l00404"></a>00404     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00405"></a>00405     
<a name="l00406"></a>00406     <span class="keywordflow">if</span>( (<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00407"></a>00407       {
<a name="l00408"></a>00408       f.setf(ios::scientific);
<a name="l00409"></a>00409       f.precision(8);
<a name="l00410"></a>00410       cell_width = 16;
<a name="l00411"></a>00411       }
<a name="l00412"></a>00412       
<a name="l00413"></a>00413     <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00414"></a>00414       {
<a name="l00415"></a>00415       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417         f.put(<span class="charliteral">' '</span>);
<a name="l00418"></a>00418         
<a name="l00419"></a>00419         <span class="keywordflow">if</span>( (<a class="code" href="structis__float.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="structis__double.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l00420"></a>00420           {
<a name="l00421"></a>00421           f.width(cell_width);
<a name="l00422"></a>00422           }
<a name="l00423"></a>00423         
<a name="l00424"></a>00424         f &lt;&lt; x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426       
<a name="l00427"></a>00427       f.put(<span class="charliteral">'\n'</span>);
<a name="l00428"></a>00428       }
<a name="l00429"></a>00429     
<a name="l00430"></a>00430     f.flags(orig_flags);
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gb304b81c3d440ff3766b1a3b190fc1b5"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gb304b81c3d440ff3766b1a3b190fc1b5" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00441">441</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00266">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01461">basic_mat&lt; eT &gt;::save()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l01025">save_field()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00442"></a>00442   {
<a name="l00443"></a>00443   arma_extra_debug_sigprint();
<a name="l00444"></a>00444   
<a name="l00445"></a>00445   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00446"></a>00446   
<a name="l00447"></a>00447   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l00448"></a>00448   
<a name="l00449"></a>00449   <a class="code" href="group__diskio.html#gb304b81c3d440ff3766b1a3b190fc1b5" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l00450"></a>00450   
<a name="l00451"></a>00451   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00452"></a>00452   
<a name="l00453"></a>00453   f.flush();
<a name="l00454"></a>00454   f.close();
<a name="l00455"></a>00455   
<a name="l00456"></a>00456   <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00457"></a>00457   
<a name="l00458"></a>00458   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00459"></a>00459     {
<a name="l00460"></a>00460     <a class="code" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gab4461cbf8d32275f7d713c995d810eb"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gab4461cbf8d32275f7d713c995d810eb" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00471">471</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00088">gen_bin_header()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00037">basic_mat&lt; eT &gt;::mem</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00035">basic_mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00472"></a>00472   {
<a name="l00473"></a>00473   arma_extra_debug_sigprint();
<a name="l00474"></a>00474   
<a name="l00475"></a>00475   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00476"></a>00476     {
<a name="l00477"></a>00477     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, name);
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479   <span class="keywordflow">else</span>
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481     f &lt;&lt; <a class="code" href="group__diskio.html#gbc65ebb995dd7cbffba8842d36c0e6a7">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00482"></a>00482     f &lt;&lt; x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00483"></a>00483     
<a name="l00484"></a>00484     f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="classbasic__mat.html#763130910bc04861a4c015b3d8d8dcda" title="pointer to memory used by the matrix (memory is read-only)">mem</a>), x.<a class="code" href="classbasic__mat.html#eaec32a9a7194935aaeed2f57edd8efe" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486   
<a name="l00487"></a>00487   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g46e49b311699b638a37751159980561a"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="g46e49b311699b638a37751159980561a" args="(const basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as a PGM greyscale image. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00499">499</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>, <a class="el" href="podarray__proto_8hpp-source.html#l00031">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00035">basic_mat&lt; eT &gt;::n_elem</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00266">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01461">basic_mat&lt; eT &gt;::save()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00554">save_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00500"></a>00500   {
<a name="l00501"></a>00501   arma_extra_debug_sigprint();
<a name="l00502"></a>00502   
<a name="l00503"></a>00503   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00504"></a>00504   
<a name="l00505"></a>00505   std::fstream f(tmp_name.c_str(), std::fstream::out | std::fstream::binary);
<a name="l00506"></a>00506   
<a name="l00507"></a>00507   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00508"></a>00508     {
<a name="l00509"></a>00509     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to write "</span>, tmp_name);
<a name="l00510"></a>00510     }
<a name="l00511"></a>00511   <span class="keywordflow">else</span>
<a name="l00512"></a>00512     {
<a name="l00513"></a>00513     f &lt;&lt; <span class="stringliteral">"P5"</span> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00514"></a>00514     f &lt;&lt; x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00515"></a>00515     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l00516"></a>00516     
<a name="l00517"></a>00517     <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a> * x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l00518"></a>00518     <a class="code" href="classpodarray.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00519"></a>00519     
<a name="l00520"></a>00520     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00521"></a>00521     
<a name="l00522"></a>00522     <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00523"></a>00523       {
<a name="l00524"></a>00524       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00525"></a>00525         {
<a name="l00526"></a>00526         tmp[i] = <a class="code" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x(row,col) );  <span class="comment">// TODO: add round() ?</span>
<a name="l00527"></a>00527         ++i;
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529       }
<a name="l00530"></a>00530     
<a name="l00531"></a>00531     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l00532"></a>00532     
<a name="l00533"></a>00533     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00534"></a>00534     
<a name="l00535"></a>00535     <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l00536"></a>00536     
<a name="l00537"></a>00537     f.flush();
<a name="l00538"></a>00538     f.close();
<a name="l00539"></a>00539     
<a name="l00540"></a>00540     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00541"></a>00541       {
<a name="l00542"></a>00542       <a class="code" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00543"></a>00543       }
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545   
<a name="l00546"></a>00546   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g705f30f14248914e58e3fe339ed3ee36"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="g705f30f14248914e58e3fe339ed3ee36" args="(const basic_mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__mat.html">basic_mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save a matrix as a PGM greyscale image. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00554">554</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="fn__conv__to_8hpp-source.html#l00084">conv_to&lt; out_eT &gt;::from()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00499">save_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00555"></a>00555   {
<a name="l00556"></a>00556   arma_extra_debug_sigprint();
<a name="l00557"></a>00557   
<a name="l00558"></a>00558   <span class="keyword">const</span> <a class="code" href="classbasic__mat.html" title="Dense matrix class.">uchar_mat</a> tmp = <a class="code" href="group__fn__conv__to.html#gd9d7776771aeb0e3cc4d6a8c204911c5">conv_to&lt;uchar_mat&gt;::from</a>(x);
<a name="l00559"></a>00559   <a class="code" href="group__diskio.html#g46e49b311699b638a37751159980561a" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(tmp,name);
<a name="l00560"></a>00560   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g3b44059e711756fadb143ecb54ad7eed"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="g3b44059e711756fadb143ecb54ad7eed" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00570">570</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01302">basic_mat&lt; eT &gt;::at()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01448">basic_mat&lt; eT &gt;::reset()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l00075">basic_mat&lt; eT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00971">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00571"></a>00571   {
<a name="l00572"></a>00572   arma_extra_debug_sigprint();
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   std::fstream f;
<a name="l00575"></a>00575   f.open(name.c_str(), std::fstream::in);
<a name="l00576"></a>00576   
<a name="l00577"></a>00577   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00578"></a>00578   
<a name="l00579"></a>00579   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00580"></a>00580     {
<a name="l00581"></a>00581     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to read "</span>, name );
<a name="l00582"></a>00582     load_okay = <span class="keyword">false</span>;
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584   <span class="keywordflow">else</span>
<a name="l00585"></a>00585     {
<a name="l00586"></a>00586     <span class="comment">//std::fstream::pos_type start = f.tellg();</span>
<a name="l00587"></a>00587     
<a name="l00588"></a>00588     <span class="comment">//</span>
<a name="l00589"></a>00589     <span class="comment">// work out the size</span>
<a name="l00590"></a>00590     
<a name="l00591"></a>00591     
<a name="l00592"></a>00592     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l00593"></a>00593     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l00594"></a>00594     
<a name="l00595"></a>00595     <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l00596"></a>00596     
<a name="l00597"></a>00597     std::string line_string;
<a name="l00598"></a>00598     std::string token;
<a name="l00599"></a>00599     
<a name="l00600"></a>00600     <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l00601"></a>00601       {
<a name="l00602"></a>00602       std::getline(f, line_string);
<a name="l00603"></a>00603       <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l00604"></a>00604         <span class="keywordflow">break</span>;
<a name="l00605"></a>00605       
<a name="l00606"></a>00606       std::stringstream line_stream(line_string);
<a name="l00607"></a>00607       
<a name="l00608"></a>00608       <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l00609"></a>00609       <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l00610"></a>00610         line_n_cols++;
<a name="l00611"></a>00611       
<a name="l00612"></a>00612       <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l00613"></a>00613         {
<a name="l00614"></a>00614         f_n_cols = line_n_cols;
<a name="l00615"></a>00615         f_n_cols_found = <span class="keyword">true</span>;
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617       <span class="keywordflow">else</span>
<a name="l00618"></a>00618         {
<a name="l00619"></a>00619         <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l00620"></a>00620           {
<a name="l00621"></a>00621           <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"inconsistent number of columns in "</span>, name );
<a name="l00622"></a>00622           load_okay = <span class="keyword">false</span>;
<a name="l00623"></a>00623           }
<a name="l00624"></a>00624         }
<a name="l00625"></a>00625       
<a name="l00626"></a>00626       ++f_n_rows;
<a name="l00627"></a>00627       }
<a name="l00628"></a>00628       
<a name="l00629"></a>00629     <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l00630"></a>00630       {
<a name="l00631"></a>00631       f.clear();
<a name="l00632"></a>00632       f.seekg(0, ios::beg);
<a name="l00633"></a>00633       <span class="comment">//f.seekg(start);</span>
<a name="l00634"></a>00634       
<a name="l00635"></a>00635       x.<a class="code" href="group__basic__mat.html#g67768d8f73fc8f42068679859204af91" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00636"></a>00636     
<a name="l00637"></a>00637       eT val;
<a name="l00638"></a>00638       
<a name="l00639"></a>00639       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00640"></a>00640         {
<a name="l00641"></a>00641         <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00642"></a>00642           {
<a name="l00643"></a>00643           <span class="comment">// f &gt;&gt; token;</span>
<a name="l00644"></a>00644           <span class="comment">// x.at(row,col) = eT( strtod(token.c_str(), 0) );</span>
<a name="l00645"></a>00645           
<a name="l00646"></a>00646           f &gt;&gt; val;
<a name="l00647"></a>00647           x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col) = val;
<a name="l00648"></a>00648           }
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650       }
<a name="l00651"></a>00651     
<a name="l00652"></a>00652     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00653"></a>00653       {
<a name="l00654"></a>00654       <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name );
<a name="l00655"></a>00655       load_okay = <span class="keyword">false</span>; 
<a name="l00656"></a>00656       }
<a name="l00657"></a>00657     
<a name="l00658"></a>00658     f.close();
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660   
<a name="l00661"></a>00661   
<a name="l00662"></a>00662   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00663"></a>00663     {
<a name="l00664"></a>00664     x.<a class="code" href="group__basic__mat.html#g9356bb1e3672f50c45cc897826d16ab2">reset</a>();
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666   
<a name="l00667"></a>00667   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gd5482bd91c68103b1abe4709d0963be6"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="gd5482bd91c68103b1abe4709d0963be6" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00676">676</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00971">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00677"></a>00677   {
<a name="l00678"></a>00678   arma_extra_debug_sigprint();
<a name="l00679"></a>00679   
<a name="l00680"></a>00680   std::ifstream f(name.c_str());
<a name="l00681"></a>00681   <a class="code" href="group__diskio.html#gd5482bd91c68103b1abe4709d0963be6" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l00682"></a>00682   f.close();
<a name="l00683"></a>00683   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gd6a8ad5a4b38f11e812b0a7aeab0d602"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="gd6a8ad5a4b38f11e812b0a7aeab0d602" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00692">692</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01302">basic_mat&lt; eT &gt;::at()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00023">gen_txt_header()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00034">basic_mat&lt; eT &gt;::n_cols</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00033">basic_mat&lt; eT &gt;::n_rows</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01448">basic_mat&lt; eT &gt;::reset()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l00075">basic_mat&lt; eT &gt;::set_size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00693"></a>00693   {
<a name="l00694"></a>00694   arma_extra_debug_sigprint();
<a name="l00695"></a>00695   
<a name="l00696"></a>00696   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00697"></a>00697   
<a name="l00698"></a>00698   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00699"></a>00699     {
<a name="l00700"></a>00700     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00701"></a>00701     load_okay = <span class="keyword">false</span>;
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703   <span class="keywordflow">else</span>
<a name="l00704"></a>00704     {
<a name="l00705"></a>00705     std::string f_header;
<a name="l00706"></a>00706     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00707"></a>00707     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00708"></a>00708     
<a name="l00709"></a>00709     f &gt;&gt; f_header;
<a name="l00710"></a>00710     f &gt;&gt; f_n_rows;
<a name="l00711"></a>00711     f &gt;&gt; f_n_cols;
<a name="l00712"></a>00712     
<a name="l00713"></a>00713     <span class="keywordflow">if</span>(f_header == <a class="code" href="group__diskio.html#g22c179c5a6705741cff72f9295b23f79">diskio::gen_txt_header</a>(x))
<a name="l00714"></a>00714       {
<a name="l00715"></a>00715       x.<a class="code" href="group__basic__mat.html#g67768d8f73fc8f42068679859204af91" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00716"></a>00716       
<a name="l00717"></a>00717       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != x.<a class="code" href="classbasic__mat.html#46e71419c3b7b28290faca70905fe37d" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719         <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != x.<a class="code" href="classbasic__mat.html#c603c030b0186d82df5d31b20bd3113f" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00720"></a>00720           {
<a name="l00721"></a>00721           f &gt;&gt; x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00722"></a>00722           }
<a name="l00723"></a>00723         }
<a name="l00724"></a>00724       
<a name="l00725"></a>00725       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00726"></a>00726         {
<a name="l00727"></a>00727         <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00728"></a>00728         load_okay = <span class="keyword">false</span>;
<a name="l00729"></a>00729         }
<a name="l00730"></a>00730       }
<a name="l00731"></a>00731     <span class="keywordflow">else</span>
<a name="l00732"></a>00732       {
<a name="l00733"></a>00733       <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"incorrect header in "</span>, name );
<a name="l00734"></a>00734       load_okay = <span class="keyword">false</span>;
<a name="l00735"></a>00735       }
<a name="l00736"></a>00736   
<a name="l00737"></a>00737     }
<a name="l00738"></a>00738   
<a name="l00739"></a>00739   
<a name="l00740"></a>00740   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00741"></a>00741     {
<a name="l00742"></a>00742     x.<a class="code" href="group__basic__mat.html#g9356bb1e3672f50c45cc897826d16ab2">reset</a>();
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gcb3671873f490a683a8a7f4110850ee4"></a><!-- doxytag: member="diskio::load_arma_binary" ref="gcb3671873f490a683a8a7f4110850ee4" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00753">753</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00971">load_auto_detect()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l01070">load_field()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00754"></a>00754   {
<a name="l00755"></a>00755   arma_extra_debug_sigprint();
<a name="l00756"></a>00756   
<a name="l00757"></a>00757   std::ifstream f;
<a name="l00758"></a>00758   f.open(name.c_str(), std::fstream::binary);
<a name="l00759"></a>00759   <a class="code" href="group__diskio.html#gcb3671873f490a683a8a7f4110850ee4" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l00760"></a>00760   f.close();
<a name="l00761"></a>00761   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g418ad1e934d18dd0841ea2a151733bfc"></a><!-- doxytag: member="diskio::load_arma_binary" ref="g418ad1e934d18dd0841ea2a151733bfc" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00768">768</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00088">gen_bin_header()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01368">basic_mat&lt; eT &gt;::memptr()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00035">basic_mat&lt; eT &gt;::n_elem</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01448">basic_mat&lt; eT &gt;::reset()</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l00075">basic_mat&lt; eT &gt;::set_size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00769"></a>00769   {
<a name="l00770"></a>00770   arma_extra_debug_sigprint();
<a name="l00771"></a>00771   
<a name="l00772"></a>00772   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00773"></a>00773   
<a name="l00774"></a>00774   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00775"></a>00775     {
<a name="l00776"></a>00776     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to read "</span>, name);
<a name="l00777"></a>00777     load_okay = <span class="keyword">false</span>;
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779   <span class="keywordflow">else</span>
<a name="l00780"></a>00780     {
<a name="l00781"></a>00781     std::string f_header;
<a name="l00782"></a>00782     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00783"></a>00783     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00784"></a>00784     
<a name="l00785"></a>00785     f &gt;&gt; f_header;
<a name="l00786"></a>00786     f &gt;&gt; f_n_rows;
<a name="l00787"></a>00787     f &gt;&gt; f_n_cols;
<a name="l00788"></a>00788     
<a name="l00789"></a>00789     <span class="keywordflow">if</span>(f_header == <a class="code" href="group__diskio.html#gbc65ebb995dd7cbffba8842d36c0e6a7">diskio::gen_bin_header</a>(x))
<a name="l00790"></a>00790       {
<a name="l00791"></a>00791       <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l00792"></a>00792       f.get();
<a name="l00793"></a>00793       
<a name="l00794"></a>00794       x.<a class="code" href="group__basic__mat.html#g67768d8f73fc8f42068679859204af91" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00795"></a>00795       f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="group__basic__mat.html#gf4ac72a9fa749d55568665b8ef07787e" title="returns a pointer to array of eTs used by the matrix">memptr</a>()), x.<a class="code" href="classbasic__mat.html#eaec32a9a7194935aaeed2f57edd8efe" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00796"></a>00796       
<a name="l00797"></a>00797       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00798"></a>00798         {
<a name="l00799"></a>00799         <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00800"></a>00800         load_okay = <span class="keyword">false</span>;
<a name="l00801"></a>00801         }
<a name="l00802"></a>00802       }
<a name="l00803"></a>00803     <span class="keywordflow">else</span>
<a name="l00804"></a>00804       {
<a name="l00805"></a>00805       <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"incorrect header in "</span>, name);
<a name="l00806"></a>00806       load_okay = <span class="keyword">false</span>;
<a name="l00807"></a>00807       }
<a name="l00808"></a>00808     
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810   
<a name="l00811"></a>00811   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00812"></a>00812     {
<a name="l00813"></a>00813     x.<a class="code" href="group__basic__mat.html#g9356bb1e3672f50c45cc897826d16ab2">reset</a>();
<a name="l00814"></a>00814     }
<a name="l00815"></a>00815   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g95ad21ffb197a2d1c88e9305a03a1ee7"></a><!-- doxytag: member="diskio::pnm_skip_comments" ref="g95ad21ffb197a2d1c88e9305a03a1ee7" args="(std::fstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::pnm_skip_comments           </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00821">821</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="diskio__meat_8hpp-source.html#l00842">load_pgm_binary()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00822"></a>00822   {
<a name="l00823"></a>00823   <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00824"></a>00824     {
<a name="l00825"></a>00825     <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00826"></a>00826       f.get();
<a name="l00827"></a>00827   
<a name="l00828"></a>00828     <span class="keywordflow">if</span>(f.peek() == <span class="charliteral">'#'</span>)
<a name="l00829"></a>00829       {
<a name="l00830"></a>00830       <span class="keywordflow">while</span>( (f.peek() != <span class="charliteral">'\r'</span>) &amp;&amp; (f.peek()!=<span class="charliteral">'\n'</span>) )
<a name="l00831"></a>00831         f.get();
<a name="l00832"></a>00832       }
<a name="l00833"></a>00833     }
<a name="l00834"></a>00834   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gb53e35d2a478557024269558d5473334"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="gb53e35d2a478557024269558d5473334" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a PGM greyscale image as a matrix. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00842">842</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01302">basic_mat&lt; eT &gt;::at()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00727">basic_mat&lt; eT &gt;::col()</a>, <a class="el" href="podarray__meat_8hpp-source.html#l00190">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="basic__mat__proto_8hpp-source.html#l00035">basic_mat&lt; eT &gt;::n_elem</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00821">pnm_skip_comments()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l01448">basic_mat&lt; eT &gt;::reset()</a>, <a class="el" href="basic__mat__meat_8hpp-source.html#l00697">basic_mat&lt; eT &gt;::row()</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l00075">basic_mat&lt; eT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00971">load_auto_detect()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00843"></a>00843   {
<a name="l00844"></a>00844   arma_extra_debug_sigprint();
<a name="l00845"></a>00845   
<a name="l00846"></a>00846   std::fstream f;
<a name="l00847"></a>00847   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l00848"></a>00848   
<a name="l00849"></a>00849   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00850"></a>00850   
<a name="l00851"></a>00851   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00852"></a>00852     {
<a name="l00853"></a>00853     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to read "</span>, name );
<a name="l00854"></a>00854     load_okay = <span class="keyword">false</span>;
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856   <span class="keywordflow">else</span>
<a name="l00857"></a>00857     {
<a name="l00858"></a>00858     std::string f_header;
<a name="l00859"></a>00859     f &gt;&gt; f_header;
<a name="l00860"></a>00860     
<a name="l00861"></a>00861     <span class="keywordflow">if</span>(f_header == <span class="stringliteral">"P5"</span>)
<a name="l00862"></a>00862       {
<a name="l00863"></a>00863       <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows   = 0;
<a name="l00864"></a>00864       <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols   = 0;
<a name="l00865"></a>00865       <span class="keywordtype">int</span> f_maxval = 0;
<a name="l00866"></a>00866     
<a name="l00867"></a>00867       <a class="code" href="group__diskio.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00868"></a>00868     
<a name="l00869"></a>00869       f &gt;&gt; f_n_cols;
<a name="l00870"></a>00870       <a class="code" href="group__diskio.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00871"></a>00871     
<a name="l00872"></a>00872       f &gt;&gt; f_n_rows;
<a name="l00873"></a>00873       <a class="code" href="group__diskio.html#g95ad21ffb197a2d1c88e9305a03a1ee7">diskio::pnm_skip_comments</a>(f);
<a name="l00874"></a>00874     
<a name="l00875"></a>00875       f &gt;&gt; f_maxval;
<a name="l00876"></a>00876       f.get();
<a name="l00877"></a>00877       
<a name="l00878"></a>00878       <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l00879"></a>00879         {
<a name="l00880"></a>00880         x.<a class="code" href="group__basic__mat.html#g67768d8f73fc8f42068679859204af91" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00881"></a>00881         
<a name="l00882"></a>00882         <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l00883"></a>00883           {
<a name="l00884"></a>00884           <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l00885"></a>00885           <a class="code" href="classpodarray.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00886"></a>00886           
<a name="l00887"></a>00887           f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l00888"></a>00888           
<a name="l00889"></a>00889           <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00890"></a>00890           
<a name="l00891"></a>00891           <span class="comment">//cout &lt;&lt; "f_n_cols = " &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l00892"></a>00892           <span class="comment">//cout &lt;&lt; "f_n_rows = " &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l00893"></a>00893           
<a name="l00894"></a>00894           
<a name="l00895"></a>00895           <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != f_n_rows; ++row)
<a name="l00896"></a>00896             {
<a name="l00897"></a>00897             <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != f_n_cols; ++col)
<a name="l00898"></a>00898               {
<a name="l00899"></a>00899               x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l00900"></a>00900               ++i;
<a name="l00901"></a>00901               }
<a name="l00902"></a>00902             
<a name="l00903"></a>00903             }
<a name="l00904"></a>00904           }
<a name="l00905"></a>00905         <span class="keywordflow">else</span>
<a name="l00906"></a>00906           {
<a name="l00907"></a>00907           <span class="keyword">const</span> <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l00908"></a>00908           <a class="code" href="classpodarray.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l00909"></a>00909           
<a name="l00910"></a>00910           f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), n_elem*2);
<a name="l00911"></a>00911           
<a name="l00912"></a>00912           <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00913"></a>00913           
<a name="l00914"></a>00914           <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row != f_n_rows; ++row)
<a name="l00915"></a>00915             {
<a name="l00916"></a>00916             <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col != f_n_cols; ++col)
<a name="l00917"></a>00917               {
<a name="l00918"></a>00918               x.<a class="code" href="group__basic__mat.html#gfb578dba9857443331f2a905b439da67" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l00919"></a>00919               ++i;
<a name="l00920"></a>00920               }
<a name="l00921"></a>00921             
<a name="l00922"></a>00922             }
<a name="l00923"></a>00923           
<a name="l00924"></a>00924           }
<a name="l00925"></a>00925         
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927       
<a name="l00928"></a>00928       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00929"></a>00929         {
<a name="l00930"></a>00930         <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l00931"></a>00931         load_okay = <span class="keyword">false</span>;
<a name="l00932"></a>00932         }
<a name="l00933"></a>00933       }
<a name="l00934"></a>00934     <span class="keywordflow">else</span>
<a name="l00935"></a>00935       {
<a name="l00936"></a>00936       <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported header in "</span>, name);
<a name="l00937"></a>00937       load_okay = <span class="keyword">false</span>;
<a name="l00938"></a>00938       }
<a name="l00939"></a>00939     
<a name="l00940"></a>00940     f.close();
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942   
<a name="l00943"></a>00943   
<a name="l00944"></a>00944   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00945"></a>00945     {
<a name="l00946"></a>00946     x.<a class="code" href="group__basic__mat.html#g9356bb1e3672f50c45cc897826d16ab2">reset</a>();
<a name="l00947"></a>00947     }
<a name="l00948"></a>00948   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g7c9536c492a9434d528ff81ea79ea2ee"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="g7c9536c492a9434d528ff81ea79ea2ee" args="(basic_mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Load a PGM greyscale image as a matrix. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00956">956</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00957"></a>00957   {
<a name="l00958"></a>00958   arma_extra_debug_sigprint();
<a name="l00959"></a>00959   
<a name="l00960"></a>00960   <a class="code" href="classbasic__mat.html" title="Dense matrix class.">uchar_mat</a> tmp;
<a name="l00961"></a>00961   tmp.<a class="code" href="group__basic__mat.html#gad75d814af0af7e9458a352ed3f5c8e8" title="load a matrix from a file">load</a>(name);
<a name="l00962"></a>00962   x = <a class="code" href="classconv__to.html">conv_to&lt; basic_mat&lt; std::complex&lt;T&gt;</a> &gt; &gt;::from(tmp);
<a name="l00963"></a>00963   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ge7528cc26228ed69b8150dabd99a7ba6"></a><!-- doxytag: member="diskio::load_auto_detect" ref="ge7528cc26228ed69b8150dabd99a7ba6" args="(basic_mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to load a matrix by automatically determining its type. 
<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l00971">971</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00676">load_arma_ascii()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00753">load_arma_binary()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00842">load_pgm_binary()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00570">load_raw_ascii()</a>, and <a class="el" href="basic__mat__meat_8hpp-source.html#l01448">basic_mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="basic__mat__meat_8hpp-source.html#l01495">basic_mat&lt; eT &gt;::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00972"></a>00972   {
<a name="l00973"></a>00973   arma_extra_debug_sigprint();
<a name="l00974"></a>00974   
<a name="l00975"></a>00975   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_TXT = <span class="stringliteral">"ARMA_MAT_TXT"</span>;
<a name="l00976"></a>00976   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_BIN = <span class="stringliteral">"ARMA_MAT_BIN"</span>;
<a name="l00977"></a>00977   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P5 = <span class="stringliteral">"P5"</span>;
<a name="l00978"></a>00978   
<a name="l00979"></a>00979   std::fstream f;
<a name="l00980"></a>00980   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l00981"></a>00981   
<a name="l00982"></a>00982   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00983"></a>00983     {
<a name="l00984"></a>00984     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"diskio::load_auto_detect(): unable to read "</span>, name );
<a name="l00985"></a>00985     x.<a class="code" href="group__basic__mat.html#g9356bb1e3672f50c45cc897826d16ab2">reset</a>();
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987   <span class="keywordflow">else</span>
<a name="l00988"></a>00988     {
<a name="l00989"></a>00989     <a class="code" href="classpodarray.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(1 + ARMA_MAT_TXT.length());
<a name="l00990"></a>00990     
<a name="l00991"></a>00991     f.read(raw_header.memptr(), ARMA_MAT_TXT.length());
<a name="l00992"></a>00992     raw_header[ARMA_MAT_TXT.length()] = <span class="charliteral">'\0'</span>;
<a name="l00993"></a>00993     
<a name="l00994"></a>00994     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l00995"></a>00995     
<a name="l00996"></a>00996     <span class="keywordflow">if</span>(ARMA_MAT_TXT == header.substr(0,ARMA_MAT_TXT.length()))
<a name="l00997"></a>00997       {
<a name="l00998"></a>00998       <a class="code" href="group__diskio.html#gd5482bd91c68103b1abe4709d0963be6" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name);
<a name="l00999"></a>00999       }
<a name="l01000"></a>01000     <span class="keywordflow">else</span>
<a name="l01001"></a>01001     <span class="keywordflow">if</span>(ARMA_MAT_BIN == header.substr(0,ARMA_MAT_BIN.length()))
<a name="l01002"></a>01002       {
<a name="l01003"></a>01003       <a class="code" href="group__diskio.html#gcb3671873f490a683a8a7f4110850ee4" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name);
<a name="l01004"></a>01004       }
<a name="l01005"></a>01005     <span class="keywordflow">else</span>
<a name="l01006"></a>01006     <span class="keywordflow">if</span>(P5 == header.substr(0,P5.length()))
<a name="l01007"></a>01007       {
<a name="l01008"></a>01008       <a class="code" href="group__diskio.html#gb53e35d2a478557024269558d5473334" title="Load a PGM greyscale image as a matrix.">load_pgm_binary</a>(x, name);
<a name="l01009"></a>01009       }
<a name="l01010"></a>01010     <span class="keywordflow">else</span>
<a name="l01011"></a>01011       {
<a name="l01012"></a>01012       <a class="code" href="group__diskio.html#g3b44059e711756fadb143ecb54ad7eed" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name);
<a name="l01013"></a>01013       }
<a name="l01014"></a>01014     
<a name="l01015"></a>01015     f.close();
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017   
<a name="l01018"></a>01018   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gce4d7fca68dc1e877b1886a360c32931"></a><!-- doxytag: member="diskio::save_field" ref="gce4d7fca68dc1e877b1886a360c32931" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_field           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfield.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l01025">1025</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="debug_8hpp-source.html#l00159">arma_warn()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00202">gen_tmp_name()</a>, <a class="el" href="field__proto_8hpp-source.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="field__proto_8hpp-source.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="field__proto_8hpp-source.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00266">safe_rename()</a>, and <a class="el" href="diskio__meat_8hpp-source.html#l00441">save_arma_binary()</a>.</p>

<p>Referenced by <a class="el" href="field__meat_8hpp-source.html#l00516">field&lt; oT &gt;::save()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01026"></a>01026   {
<a name="l01027"></a>01027   arma_extra_debug_sigprint();
<a name="l01028"></a>01028   
<a name="l01029"></a>01029   <a class="code" href="structarma__type__check.html">arma_type_check&lt;is_basic_mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01030"></a>01030   
<a name="l01031"></a>01031   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="group__diskio.html#g81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01032"></a>01032   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01033"></a>01033   
<a name="l01034"></a>01034   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01035"></a>01035     {
<a name="l01036"></a>01036     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"couldn't write "</span>, tmp_name);
<a name="l01037"></a>01037     }
<a name="l01038"></a>01038   <span class="keywordflow">else</span>
<a name="l01039"></a>01039     {
<a name="l01040"></a>01040     f &lt;&lt; <span class="stringliteral">"ARMA_FLD_BIN"</span> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01041"></a>01041     f &lt;&lt; x.<a class="code" href="classfield.html#98d956dc3c4571ff9d29ee3d709d0202">n_rows</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01042"></a>01042     f &lt;&lt; x.<a class="code" href="classfield.html#d33a934565f6e02edb4e7f6d1331d34a">n_cols</a> &lt;&lt; <span class="charliteral">'\n'</span>;
<a name="l01043"></a>01043     
<a name="l01044"></a>01044     <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="classfield.html#546aa9caedb2f0a0657e4dd765503db7">n_elem</a>; ++i)
<a name="l01045"></a>01045       {
<a name="l01046"></a>01046       <a class="code" href="group__diskio.html#gb304b81c3d440ff3766b1a3b190fc1b5" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x[i], tmp_name, f);
<a name="l01047"></a>01047       }
<a name="l01048"></a>01048     
<a name="l01049"></a>01049     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01050"></a>01050     
<a name="l01051"></a>01051     <a class="code" href="group__debug.html#g22a16c8da1f2f02e60cc810091973ae0" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">"trouble writing "</span>, tmp_name );
<a name="l01052"></a>01052     
<a name="l01053"></a>01053     f.flush();
<a name="l01054"></a>01054     f.close();
<a name="l01055"></a>01055     
<a name="l01056"></a>01056     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01057"></a>01057       {
<a name="l01058"></a>01058       <a class="code" href="group__diskio.html#g21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01059"></a>01059       }
<a name="l01060"></a>01060     
<a name="l01061"></a>01061     }
<a name="l01062"></a>01062   
<a name="l01063"></a>01063   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g0b5433d75c86772140fb29099e299c52"></a><!-- doxytag: member="diskio::load_field" ref="g0b5433d75c86772140fb29099e299c52" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_field           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfield.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="diskio__meat_8hpp-source.html#l01070">1070</a> of file <a class="el" href="diskio__meat_8hpp-source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="debug_8hpp-source.html#l00026">arma_print()</a>, <a class="el" href="diskio__meat_8hpp-source.html#l00753">load_arma_binary()</a>, <a class="el" href="field__proto_8hpp-source.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="field__meat_8hpp-source.html#l00492">field&lt; oT &gt;::reset()</a>, and <a class="el" href="field__meat_8hpp-source.html#l00150">field&lt; oT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="field__meat_8hpp-source.html#l00528">field&lt; oT &gt;::load()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01071"></a>01071   {
<a name="l01072"></a>01072   arma_extra_debug_sigprint();
<a name="l01073"></a>01073   
<a name="l01074"></a>01074   <a class="code" href="structarma__type__check.html">arma_type_check&lt;is_basic_mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01075"></a>01075   
<a name="l01076"></a>01076   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01077"></a>01077   
<a name="l01078"></a>01078   std::ifstream f( name.c_str() );
<a name="l01079"></a>01079   
<a name="l01080"></a>01080   <span class="keywordflow">if</span>(f.fail())
<a name="l01081"></a>01081     {
<a name="l01082"></a>01082     <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unable to read "</span>, name );
<a name="l01083"></a>01083     load_okay = <span class="keyword">false</span>;
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085   <span class="keywordflow">else</span>
<a name="l01086"></a>01086     {
<a name="l01087"></a>01087     std::string f_type;
<a name="l01088"></a>01088     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>         f_n_rows;
<a name="l01089"></a>01089     <a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>         f_n_cols;
<a name="l01090"></a>01090     
<a name="l01091"></a>01091     f &gt;&gt; f_type;
<a name="l01092"></a>01092     <span class="keywordflow">if</span>(f_type != <span class="stringliteral">"ARMA_FLD_BIN"</span>)
<a name="l01093"></a>01093       {
<a name="l01094"></a>01094       <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"unsupported field type in "</span>, name);
<a name="l01095"></a>01095       load_okay = <span class="keyword">false</span>;
<a name="l01096"></a>01096       }
<a name="l01097"></a>01097     <span class="keywordflow">else</span>
<a name="l01098"></a>01098       {
<a name="l01099"></a>01099       f &gt;&gt; f_n_rows;
<a name="l01100"></a>01100       f &gt;&gt; f_n_cols;
<a name="l01101"></a>01101       
<a name="l01102"></a>01102       x.<a class="code" href="group__field.html#gfd7a090f4134eab2ab1c805fb867e85c" title="change the field to have a user specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01103"></a>01103       
<a name="l01104"></a>01104       f.get();      
<a name="l01105"></a>01105       
<a name="l01106"></a>01106       <span class="keywordflow">for</span>(<a class="code" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="classfield.html#546aa9caedb2f0a0657e4dd765503db7">n_elem</a>; ++i)
<a name="l01107"></a>01107         {
<a name="l01108"></a>01108         <a class="code" href="group__diskio.html#gcb3671873f490a683a8a7f4110850ee4" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x[i], name, f);
<a name="l01109"></a>01109         
<a name="l01110"></a>01110         <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01111"></a>01111           {
<a name="l01112"></a>01112           <a class="code" href="group__debug.html#gdcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">"trouble reading "</span>, name);
<a name="l01113"></a>01113           load_okay = <span class="keyword">false</span>;
<a name="l01114"></a>01114           <span class="keywordflow">break</span>;
<a name="l01115"></a>01115           }
<a name="l01116"></a>01116         }
<a name="l01117"></a>01117       }
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119   
<a name="l01120"></a>01120   f.close();
<a name="l01121"></a>01121   
<a name="l01122"></a>01122   
<a name="l01123"></a>01123   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01124"></a>01124     {
<a name="l01125"></a>01125     x.<a class="code" href="group__field.html#gc9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01126"></a>01126     }
<a name="l01127"></a>01127   }
</pre></div>
<p>

</div>
</div><p>
</div>
</BODY>
</HTML>
