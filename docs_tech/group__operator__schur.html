<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Operator_schur</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Operator_schur</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g9d3233a1dd13db72cc8352b79bfcca39">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a>  <a href="#g9d3233a1dd13db72cc8352b79bfcca39"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, <a class="el" href="classop__data.html">op_data</a><br>
&lt; T2, <a class="el" href="classop__diagmat.html">op_diagmat</a> &gt;<br>
, <a class="el" href="classglue__schur__diag.html">glue_schur_diag</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g520efe96c922531c5abed15637067e2c">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T2::elem_type, T1 &gt; &amp;X, const <a class="el" href="classop__data.html">op_data</a>&lt; T2, <a class="el" href="classop__diagmat.html">op_diagmat</a> &gt; &amp;Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % diagmat  <a href="#g520efe96c922531c5abed15637067e2c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; <a class="el" href="classop__data.html">op_data</a>&lt; T1, <br>
<a class="el" href="classop__diagmat.html">op_diagmat</a> &gt;, T2, <br>
<a class="el" href="classglue__schur__diag.html">glue_schur_diag</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g8695ead48c2b8fa684107566e69f5f95">operator%</a> (const <a class="el" href="classop__data.html">op_data</a>&lt; T1, <a class="el" href="classop__diagmat.html">op_diagmat</a> &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">diagmat % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a>  <a href="#g8695ead48c2b8fa684107566e69f5f95"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename eT1, typename T1, typename eT2, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt; typename <br>
<a class="el" href="structpromote__type.html">promote_type</a>&lt; eT1, eT2 &gt;<br>
::result &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#gc018e1b501ca61f12a1b1d114aabbb97">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; eT1, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; eT2, T2 &gt; &amp;Y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a>  <a href="#gc018e1b501ca61f12a1b1d114aabbb97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#gf940786115bd312c48efa9d9f97e7e76">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; double &gt;, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; double &gt;, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g37bf21d37cf9215483063dfa8dd2d5da">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; float &gt;, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; float &gt;, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g33bc99632d5cb21f0dbcbde435a2fcad">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; double, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; double, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#gea723cb2129d6ec7b88fb16badc755c7">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; float, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; float, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g1a529ac5e196cf9db1a0557abd1772c0">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a>, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g38ba6ec830013084abe7cf167e7fd939">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g7a23d8a2580f9ff9e471bd24888656a1">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2e9bf6983da73775aa86158c825bf777">s16</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2e9bf6983da73775aa86158c825bf777">s16</a>, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g2f12287f546d050a2967b161c123cd37">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g9e6c91d77e24643b888dbd1a1a590054">u16</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g9e6c91d77e24643b888dbd1a1a590054">u16</a>, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#g2904bb752c7c69909e52ef319645e9dd">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2ff401e087cf786c38a6812723e94473">s8</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2ff401e087cf786c38a6812723e94473">s8</a>, T2 &gt; &amp;Y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const <a class="el" href="classglue__data.html">glue_data</a>&lt; T1, T2, <br>
<a class="el" href="classglue__schur.html">glue_schur</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operator__schur.html#gd9a80ac749e59352721942529d719119">operator%</a> (const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>, T1 &gt; &amp;X, const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>, T2 &gt; &amp;Y)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g9d3233a1dd13db72cc8352b79bfcca39"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g9d3233a1dd13db72cc8352b79bfcca39" args="(const arma_base&lt; typename T1::elem_type, T1 &gt; &amp;X, const arma_base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> 
<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00028">28</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00029"></a>00029   {
<a name="l00030"></a>00030   arma_extra_debug_sigprint();
<a name="l00031"></a>00031   
<a name="l00032"></a>00032   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00033"></a>00033   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g520efe96c922531c5abed15637067e2c"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g520efe96c922531c5abed15637067e2c" args="(const arma_base&lt; typename T2::elem_type, T1 &gt; &amp;X, const op_data&lt; T2, op_diagmat &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, <a class="el" href="classop__data.html">op_data</a>&lt;T2,<a class="el" href="classop__diagmat.html">op_diagmat</a>&gt;, <a class="el" href="classglue__schur__diag.html">glue_schur_diag</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T2::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classop__data.html">op_data</a>&lt; T2, <a class="el" href="classop__diagmat.html">op_diagmat</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % diagmat 
<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00042">42</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00043"></a>00043   {
<a name="l00044"></a>00044   arma_extra_debug_sigprint();
<a name="l00045"></a>00045   
<a name="l00046"></a>00046   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, op_data&lt;T2,op_diagmat&gt;</a>, <a class="code" href="classglue__schur__diag.html">glue_schur_diag</a>&gt;(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y);
<a name="l00047"></a>00047   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g8695ead48c2b8fa684107566e69f5f95"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g8695ead48c2b8fa684107566e69f5f95" args="(const op_data&lt; T1, op_diagmat &gt; &amp;X, const arma_base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt; <a class="el" href="classop__data.html">op_data</a>&lt;T1,<a class="el" href="classop__diagmat.html">op_diagmat</a>&gt;, T2, <a class="el" href="classglue__schur__diag.html">glue_schur_diag</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classop__data.html">op_data</a>&lt; T1, <a class="el" href="classop__diagmat.html">op_diagmat</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
diagmat % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> 
<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00056">56</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; T1::elem_type, op_data&lt; T1, op_type &gt; &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00057"></a>00057   {
<a name="l00058"></a>00058   arma_extra_debug_sigprint();
<a name="l00059"></a>00059   
<a name="l00060"></a>00060   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt; op_data&lt;T1,op_diagmat&gt;</a>, T2, <a class="code" href="classglue__schur__diag.html">glue_schur_diag</a>&gt;(X, Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00061"></a>00061   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gc018e1b501ca61f12a1b1d114aabbb97"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="gc018e1b501ca61f12a1b1d114aabbb97" args="(const arma_base&lt; eT1, T1 &gt; &amp;X, const arma_base&lt; eT2, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT1, typename T1, typename eT2, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__mat.html">basic_mat</a>&lt;typename <a class="el" href="structpromote__type.html">promote_type</a>&lt;eT1,eT2&gt;::result&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; eT1, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; eT2, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> % <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> 
<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00076">76</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="glue__schur__meat_8hpp-source.html#l00225">glue_schur::apply_mixed()</a>, <a class="el" href="traits_8hpp-source.html#l00458">promote_type&lt; T1, T2 &gt;::check()</a>, and <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00077"></a>00077   {
<a name="l00078"></a>00078   arma_extra_debug_sigprint();
<a name="l00079"></a>00079   
<a name="l00080"></a>00080   <a class="code" href="structpromote__type.html#f84f38f42cfb0d891487c3273c521f2d">promote_type&lt;eT1,eT2&gt;::check</a>();
<a name="l00081"></a>00081   
<a name="l00082"></a>00082   <span class="keyword">const</span> <a class="code" href="classunwrap.html">unwrap&lt;T1&gt;</a> tmp1(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00083"></a>00083   <span class="keyword">const</span> <a class="code" href="classunwrap.html">unwrap&lt;T2&gt;</a> tmp2(Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00084"></a>00084   
<a name="l00085"></a>00085   <span class="keyword">const</span> <a class="code" href="classbasic__mat.html" title="Dense matrix class.">basic_mat&lt;eT1&gt;</a>&amp; A = tmp1.M;
<a name="l00086"></a>00086   <span class="keyword">const</span> <a class="code" href="classbasic__mat.html" title="Dense matrix class.">basic_mat&lt;eT2&gt;</a>&amp; B = tmp2.M;
<a name="l00087"></a>00087   
<a name="l00088"></a>00088   <a class="code" href="classbasic__mat.html" title="Dense matrix class.">basic_mat&lt; typename promote_type&lt;eT1,eT2&gt;::result</a> &gt; out;
<a name="l00089"></a>00089   <a class="code" href="group__glue__schur.html#g011d0547ea60ca28361c5e0951cd2560">glue_schur::apply_mixed</a>(out, A, B);
<a name="l00090"></a>00090   
<a name="l00091"></a>00091   <span class="keywordflow">return</span> out;
<a name="l00092"></a>00092   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gf940786115bd312c48efa9d9f97e7e76"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="gf940786115bd312c48efa9d9f97e7e76" args="(const arma_base&lt; std::complex&lt; double &gt;, T1 &gt; &amp;X, const arma_base&lt; std::complex&lt; double &gt;, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; double &gt;, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; double &gt;, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00106">106</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00107"></a>00107   {
<a name="l00108"></a>00108   arma_extra_debug_sigprint();
<a name="l00109"></a>00109   
<a name="l00110"></a>00110   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00111"></a>00111   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g37bf21d37cf9215483063dfa8dd2d5da"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g37bf21d37cf9215483063dfa8dd2d5da" args="(const arma_base&lt; std::complex&lt; float &gt;, T1 &gt; &amp;X, const arma_base&lt; std::complex&lt; float &gt;, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; float &gt;, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; std::complex&lt; float &gt;, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00119">119</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00120"></a>00120   {
<a name="l00121"></a>00121   arma_extra_debug_sigprint();
<a name="l00122"></a>00122   
<a name="l00123"></a>00123   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00124"></a>00124   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g33bc99632d5cb21f0dbcbde435a2fcad"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g33bc99632d5cb21f0dbcbde435a2fcad" args="(const arma_base&lt; double, T1 &gt; &amp;X, const arma_base&lt; double, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; double, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; double, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00132">132</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00133"></a>00133   {
<a name="l00134"></a>00134   arma_extra_debug_sigprint();
<a name="l00135"></a>00135   
<a name="l00136"></a>00136   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00137"></a>00137   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gea723cb2129d6ec7b88fb16badc755c7"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="gea723cb2129d6ec7b88fb16badc755c7" args="(const arma_base&lt; float, T1 &gt; &amp;X, const arma_base&lt; float, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; float, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; float, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00145">145</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00146"></a>00146   {
<a name="l00147"></a>00147   arma_extra_debug_sigprint();
<a name="l00148"></a>00148   
<a name="l00149"></a>00149   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00150"></a>00150   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g1a529ac5e196cf9db1a0557abd1772c0"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g1a529ac5e196cf9db1a0557abd1772c0" args="(const arma_base&lt; s32, T1 &gt; &amp;X, const arma_base&lt; s32, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00158">158</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00159"></a>00159   {
<a name="l00160"></a>00160   arma_extra_debug_sigprint();
<a name="l00161"></a>00161   
<a name="l00162"></a>00162   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00163"></a>00163   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g38ba6ec830013084abe7cf167e7fd939"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g38ba6ec830013084abe7cf167e7fd939" args="(const arma_base&lt; u32, T1 &gt; &amp;X, const arma_base&lt; u32, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00171">171</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00172"></a>00172   {
<a name="l00173"></a>00173   arma_extra_debug_sigprint();
<a name="l00174"></a>00174   
<a name="l00175"></a>00175   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00176"></a>00176   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g7a23d8a2580f9ff9e471bd24888656a1"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g7a23d8a2580f9ff9e471bd24888656a1" args="(const arma_base&lt; s16, T1 &gt; &amp;X, const arma_base&lt; s16, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2e9bf6983da73775aa86158c825bf777">s16</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2e9bf6983da73775aa86158c825bf777">s16</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00184">184</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00185"></a>00185   {
<a name="l00186"></a>00186   arma_extra_debug_sigprint();
<a name="l00187"></a>00187   
<a name="l00188"></a>00188   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00189"></a>00189   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g2f12287f546d050a2967b161c123cd37"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g2f12287f546d050a2967b161c123cd37" args="(const arma_base&lt; u16, T1 &gt; &amp;X, const arma_base&lt; u16, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g9e6c91d77e24643b888dbd1a1a590054">u16</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g9e6c91d77e24643b888dbd1a1a590054">u16</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00197">197</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00198"></a>00198   {
<a name="l00199"></a>00199   arma_extra_debug_sigprint();
<a name="l00200"></a>00200   
<a name="l00201"></a>00201   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00202"></a>00202   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g2904bb752c7c69909e52ef319645e9dd"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="g2904bb752c7c69909e52ef319645e9dd" args="(const arma_base&lt; s8, T1 &gt; &amp;X, const arma_base&lt; s8, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2ff401e087cf786c38a6812723e94473">s8</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#g2ff401e087cf786c38a6812723e94473">s8</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00210">210</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00211"></a>00211   {
<a name="l00212"></a>00212   arma_extra_debug_sigprint();
<a name="l00213"></a>00213   
<a name="l00214"></a>00214   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00215"></a>00215   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gd9a80ac749e59352721942529d719119"></a><!-- doxytag: member="operator_schur.hpp::operator%" ref="gd9a80ac749e59352721942529d719119" args="(const arma_base&lt; u8, T1 &gt; &amp;X, const arma_base&lt; u8, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classglue__data.html">glue_data</a>&lt;T1, T2, <a class="el" href="classglue__schur.html">glue_schur</a>&gt; operator%           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarma__base.html">arma_base</a>&lt; <a class="el" href="group__typedef.html#ged742c436da53c1080638ce6ef7d13de">u8</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="operator__schur_8hpp-source.html#l00223">223</a> of file <a class="el" href="operator__schur_8hpp-source.html">operator_schur.hpp</a>.</p>

<p>References <a class="el" href="arma__base_8hpp-source.html#l00031">arma_base&lt; elem_type, arma_derived &gt;::get_ref()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00224"></a>00224   {
<a name="l00225"></a>00225   arma_extra_debug_sigprint();
<a name="l00226"></a>00226   
<a name="l00227"></a>00227   <span class="keywordflow">return</span> <a class="code" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data&lt;T1, T2, glue_schur&gt;</a>(X.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>(), Y.<a class="code" href="structarma__base.html#3df691ef66b807ee66f6161c1607d13a">get_ref</a>());
<a name="l00228"></a>00228   }
</pre></div>
<p>

</div>
</div><p>
</div>
</BODY>
</HTML>
