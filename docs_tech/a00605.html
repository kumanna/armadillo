<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Cube</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Cube</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">Cube&lt; eT &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dense cube class.  <a href="a00031.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">Cube_aux</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga006b848eba2275b63aefbca4502a33aa">Cube::~Cube</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaa8b4ea1c9891b95adc73fa425c7971db">Cube::Cube</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaf6dc1f3691535561dd614637f7a2dda0">Cube::Cube</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct the cube to have user specified dimensions  <a href="#gaf6dc1f3691535561dd614637f7a2dda0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83">Cube::init</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal cube construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new'  <a href="#ga3d00c0a819c450a9dc7d09abaf95dd83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga261fe3edd2f2706d3ad7875487cd3c69">Cube::delete_mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga1bc39b7915eec73d01dbd1b959cb6732">Cube::create_mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga73fd2fa4151f5bd8dab023d73c8731ba">Cube::operator=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the cube to be equal to the specified scalar. NOTE: the size of the cube will be 1x1x1.  <a href="#ga73fd2fa4151f5bd8dab023d73c8731ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gad6ca23e58aac88ec2a723ebeae7a60e1">Cube::operator+=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place addition of a scalar to all elements of the cube.  <a href="#gad6ca23e58aac88ec2a723ebeae7a60e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gafdd9657cc414a01c77ddaecf06c072ed">Cube::operator-=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place subtraction of a scalar from all elements of the cube.  <a href="#gafdd9657cc414a01c77ddaecf06c072ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga348b03ddc6dbaebf2bcddf2625947980">Cube::operator*=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place multiplication of all elements of the cube with a scalar.  <a href="#ga348b03ddc6dbaebf2bcddf2625947980"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga40d5d0e8391797cd3eac772147297b43">Cube::operator/=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place division of all elements of the cube with a scalar.  <a href="#ga40d5d0e8391797cd3eac772147297b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga458bec1f3fc6ebb878d88eaaae747089">Cube::Cube</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a given cube  <a href="#ga458bec1f3fc6ebb878d88eaaae747089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga2c4c1a84d9c3e8c2c59f4759a6e3a1af">Cube::operator=</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a given cube  <a href="#ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaac8dfe2922518d480f6d89326e3991e2">Cube::init</a> (const <a class="el" href="a00031.html">Cube</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a given cube  <a href="#gaac8dfe2922518d480f6d89326e3991e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gac330d35dcab2f8916d3dac82f88309b9">Cube::Cube</a> (eT *aux_mem, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_slices, const bool copy_aux_mem=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). note that in the latter case the default is to copy the array.  <a href="#gac330d35dcab2f8916d3dac82f88309b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab23146a09d55cfeec1f74809cf006790">Cube::Cube</a> (const eT *aux_mem, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_slices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a given auxiliary read-only array of eTs. the array is copied.  <a href="#gab23146a09d55cfeec1f74809cf006790"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga031db49c5ce03bf5fbdd6f141a784125">Cube::operator+=</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube addition  <a href="#ga031db49c5ce03bf5fbdd6f141a784125"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gafcc85205e8a9fd17f18566b8b3a03c70">Cube::operator-=</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube subtraction  <a href="#gafcc85205e8a9fd17f18566b8b3a03c70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga6e4729f1623baf2c96b9cca73e06a9a2">Cube::operator%=</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise cube multiplication  <a href="#ga6e4729f1623baf2c96b9cca73e06a9a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga996bc9ab51f31e1a32694bb6a1b95520">Cube::operator/=</a> (const <a class="el" href="a00031.html">Cube</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise cube division  <a href="#ga996bc9ab51f31e1a32694bb6a1b95520"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga14529609eaa889061eb3972522f5da3b">Cube::Cube</a> (const <a class="el" href="a00020.html">BaseCube</a>&lt; pod_type, T1 &gt; &amp;A, const <a class="el" href="a00020.html">BaseCube</a>&lt; pod_type, T2 &gt; &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for constructing a complex cube out of two non-complex cubes  <a href="#ga14529609eaa889061eb3972522f5da3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga5edb2ac646b7408343aba2971b181104">Cube::Cube</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation)  <a href="#ga5edb2ac646b7408343aba2971b181104"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab6fc51265fb78aa3b5e69e7ce51bff6f">Cube::operator=</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a cube from a <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation)  <a href="#gab6fc51265fb78aa3b5e69e7ce51bff6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab7ff823e63a04d322137bab296fd40c0">Cube::operator+=</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube addition (using a subcube on the right-hand-side)  <a href="#gab7ff823e63a04d322137bab296fd40c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab188ca927465a03ded825df6cb8c8d5e">Cube::operator-=</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube subtraction (using a subcube on the right-hand-side)  <a href="#gab188ca927465a03ded825df6cb8c8d5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gae32382263d12d93c74b5593145a7250c">Cube::operator%=</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise cube mutiplication (using a subcube on the right-hand-side)  <a href="#gae32382263d12d93c74b5593145a7250c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga4769b282b8a4a39a15b52a6131c1acc6">Cube::operator/=</a> (const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise cube division (using a subcube on the right-hand-side)  <a href="#ga4769b282b8a4a39a15b52a6131c1acc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68">Cube::slice</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">provide the reference to the matrix representing a single slice  <a href="#ga278055e14ab971acffa2d4616cc65f68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga54d5d9ffe36d6e84cbbd0fa453b070b9">Cube::slice</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">provide the reference to the matrix representing a single slice  <a href="#ga54d5d9ffe36d6e84cbbd0fa453b070b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gabb10bd8ca819f55992e6a00a499a7534">Cube::slices</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (subcube comprised of specified slices)  <a href="#gabb10bd8ca819f55992e6a00a499a7534"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00321.html">subview_cube</a><br class="typebreak"/>
&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga5d520256a1d24d61cfac4744eaa3278a">Cube::slices</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (subcube comprised of specified slices)  <a href="#ga5d520256a1d24d61cfac4744eaa3278a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga13d5f790036b1c28af7f839d7026078f">Cube::subcube</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (generic subcube)  <a href="#ga13d5f790036b1c28af7f839d7026078f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00321.html">subview_cube</a><br class="typebreak"/>
&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga3e8561d6c2b738e2eef9e836c85b39a4">Cube::subcube</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice1, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (generic subcube)  <a href="#ga3e8561d6c2b738e2eef9e836c85b39a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga96ac56c25f53f3318c2cd205ec245c14">Cube::Cube</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a cube from <a class="el" href="a00229.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations  <a href="#ga96ac56c25f53f3318c2cd205ec245c14"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gad549847c54ebdfa4d8fc620af86fa28a">Cube::operator=</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a cube from <a class="el" href="a00229.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations  <a href="#gad549847c54ebdfa4d8fc620af86fa28a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga0c9be3b1f887464943ee8eb72ef27be1">Cube::operator+=</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operand having delayed operations  <a href="#ga0c9be3b1f887464943ee8eb72ef27be1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga0371c0de0cb968f530fcd952a7f0f7cf">Cube::operator-=</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operand having delayed operations  <a href="#ga0371c0de0cb968f530fcd952a7f0f7cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gabc8ff44d694e522045d8fbf7eadfddfe">Cube::operator%=</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operand having delayed operations  <a href="#gabc8ff44d694e522045d8fbf7eadfddfe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga9121b55b0f49c8b38a4f81042ace6670">Cube::operator/=</a> (const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operand having delayed operations  <a href="#ga9121b55b0f49c8b38a4f81042ace6670"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga55083a264e4d2ab43624215b2b9d1b81">Cube::Cube</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a cube from <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="#ga55083a264e4d2ab43624215b2b9d1b81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gaa80458b9a802a48454e6708a17712fe1">Cube::operator=</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a cube from <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="#gaa80458b9a802a48454e6708a17712fe1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gaa37e3b72f34684c213166c78afcb7890">Cube::operator+=</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube addition, with the right-hand-side operands having delayed operations  <a href="#gaa37e3b72f34684c213166c78afcb7890"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gac64226124d2264e4a751f58502bcd511">Cube::operator-=</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube subtraction, with the right-hand-side operands having delayed operations  <a href="#gac64226124d2264e4a751f58502bcd511"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga735e135b7b9505cb44f97bb3cf94b142">Cube::operator%=</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube element-wise multiplication, with the right-hand-side operands having delayed operations  <a href="#ga735e135b7b9505cb44f97bb3cf94b142"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga57102c0ed5f78153e8d96cd2e9636c0f">Cube::operator/=</a> (const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place cube element-wise division, with the right-hand-side operands having delayed operations  <a href="#ga57102c0ed5f78153e8d96cd2e9636c0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga4e59e4633632a8ae7558d7ff6d6fdba4">Cube::operator()</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="#ga4e59e4633632a8ae7558d7ff6d6fdba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga118d45e6400af4a07014f7469736b8d0">Cube::operator()</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="#ga118d45e6400af4a07014f7469736b8d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaba0217b709fe7de1e87a7c800a0889f6">Cube::operator[]</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check.  <a href="#gaba0217b709fe7de1e87a7c800a0889f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga88d1abb930c1f5be83811ea896316e26">Cube::operator[]</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the cube as a vector); no bounds check  <a href="#ga88d1abb930c1f5be83811ea896316e26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga4aa508c78ec365c4c4ff5365c318dfd2">Cube::operator()</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="#ga4aa508c78ec365c4c4ff5365c318dfd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga38cab70dd2d52a6f55ecf5b7ba8e00db">Cube::operator()</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="#ga38cab70dd2d52a6f55ecf5b7ba8e00db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga88789d28113d5e6606c27f802c506c82">Cube::at</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="#ga88789d28113d5e6606c27f802c506c82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab41c42d70e1802037cff313e11f3d3e6">Cube::at</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="#gab41c42d70e1802037cff313e11f3d3e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga63f49cd73b0a28cd718820aabcbfc55b">Cube::operator++</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix ++  <a href="#ga63f49cd73b0a28cd718820aabcbfc55b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga08e53f4d13c896de95e1d6d5c187ae55">Cube::operator++</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++ (must not return the object by reference)  <a href="#ga08e53f4d13c896de95e1d6d5c187ae55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00031.html">Cube</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga8adaf465f35b98b70c02fc3c6407ed28">Cube::operator--</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix --  <a href="#ga8adaf465f35b98b70c02fc3c6407ed28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga85f7e423acb147da1ff5eed3c24eef84">Cube::operator--</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix -- (must not return the object by reference)  <a href="#ga85f7e423acb147da1ff5eed3c24eef84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaf668de01e26c206f524f5161929d01fa">Cube::is_finite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if all of the elements are finite  <a href="#gaf668de01e26c206f524f5161929d01fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615">Cube::memptr</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the cube  <a href="#ga1e0aa001a72a50700fc151a655ece615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga7909c5331eaa24bf3460a319a62d1096">Cube::memptr</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the cube  <a href="#ga7909c5331eaa24bf3460a319a62d1096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gabb8c874cad5aac59f1877f7525b675de">Cube::slice_memptr</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube  <a href="#gabb8c874cad5aac59f1877f7525b675de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga552f2287ca08e1b228fd13cece553f25">Cube::slice_memptr</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube  <a href="#ga552f2287ca08e1b228fd13cece553f25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga8c87a3fbb8c3c9b2ae3d104d3f36d97b">Cube::slice_colptr</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube  <a href="#ga8c87a3fbb8c3c9b2ae3d104d3f36d97b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga72490b66dbde72a017186ca27572f66f">Cube::slice_colptr</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slice, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the specified slice in the cube  <a href="#ga72490b66dbde72a017186ca27572f66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga12c4f14c74e1653b5560acd83264acb0">Cube::print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="#ga12c4f14c74e1653b5560acd83264acb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga4d9c58eb0f9fbdf0397b2235ac094488">Cube::print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="#ga4d9c58eb0f9fbdf0397b2235ac094488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga42abd15133eecb98ebb2510c997631e6">Cube::raw_print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified).  <a href="#ga42abd15133eecb98ebb2510c997631e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gad4e83bc50d3f8910b1fc2ce30d5eef73">Cube::raw_print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified).  <a href="#gad4e83bc50d3f8910b1fc2ce30d5eef73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gac10bacf38c391e357e110e36b74c8863">Cube::set_size</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the cube to have user specified dimensions (data is not preserved)  <a href="#gac10bacf38c391e357e110e36b74c8863"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gabec1313f7c0ce9e000d74654392c7c51">Cube::copy_size</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT2 &gt; &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the cube (without preserving data) to have the same dimensions as the given cube  <a href="#gabec1313f7c0ce9e000d74654392c7c51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga4bcefd621084689a02805acfa696cecb">Cube::fill</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fill the cube with the specified value  <a href="#ga4bcefd621084689a02805acfa696cecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga14876b8ab1f0681ce0d3af3dfec65c30">Cube::zeros</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gab451e891732c7bddf9829ca042ce25a7">Cube::zeros</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slices)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga32914e3bd1cfaebee179d41f382e1159">Cube::ones</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga080bc34e734a22d505e310f070871e40">Cube::ones</a> (const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols, const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_slices)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">Cube::reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga9cba3b9de9a7b32c7d7b7c836b306c65">Cube::save</a> (const std::string name, const <a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the cube to a file  <a href="#ga9cba3b9de9a7b32c7d7b7c836b306c65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00605.html#ga2c92a3f78b5c4b2026739b77e0e5a1a6">Cube::load</a> (const std::string name, const <a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a cube from a file  <a href="#ga2c92a3f78b5c4b2026739b77e0e5a1a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gaa0ebb575427635df9dad21d2bd0457f3">Cube_aux::prefix_pp</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix ++  <a href="#gaa0ebb575427635df9dad21d2bd0457f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga94cb50acaf1e4360e6325f325ba096bd">Cube_aux::prefix_pp</a> (<a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix ++ for complex numbers (work around for limitations of the std::complex class)  <a href="#ga94cb50acaf1e4360e6325f325ba096bd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga4e73d6e46a8d79e6c6b40607154e7b1b">Cube_aux::postfix_pp</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++  <a href="#ga4e73d6e46a8d79e6c6b40607154e7b1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga2ff885c12d4c334ae827157ddbed71b0">Cube_aux::postfix_pp</a> (<a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++ for complex numbers (work around for limitations of the std::complex class)  <a href="#ga2ff885c12d4c334ae827157ddbed71b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#ga4d72f270fd218a69d79adecac7e9fc5c">Cube_aux::prefix_mm</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix --  <a href="#ga4d72f270fd218a69d79adecac7e9fc5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gab4485a579abb88757b7f8e83805ec2f4">Cube_aux::prefix_mm</a> (<a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix -- for complex numbers (work around for limitations of the std::complex class)  <a href="#gab4485a579abb88757b7f8e83805ec2f4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gae95e218a4268fbcee637e80b56e1e6f6">Cube_aux::postfix_mm</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix --  <a href="#gae95e218a4268fbcee637e80b56e1e6f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_inline void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00605.html#gae2e53de87e71bb5b874bfbe95f4e380c">Cube_aux::postfix_mm</a> (<a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++ for complex numbers (work around for limitations of the std::complex class)  <a href="#gae2e53de87e71bb5b874bfbe95f4e380c"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga006b848eba2275b63aefbca4502a33aa"></a><!-- doxytag: member="Cube::~Cube" ref="ga006b848eba2275b63aefbca4502a33aa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::~<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l00022">22</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00400_source.html#l00209">arma_config::debug</a>, <a class="el" href="a00401_source.html#l00165">Cube&lt; eT &gt;::delete_mat()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00045">Cube&lt; eT &gt;::mem_local</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00385_source.html#l00028">access::rw()</a>, and <a class="el" href="a00402_source.html#l00038">Cube&lt; eT &gt;::use_aux_mem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00023"></a>00023   {
<a name="l00024"></a>00024   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00025"></a>00025   
<a name="l00026"></a>00026   <a class="code" href="a00605.html#ga261fe3edd2f2706d3ad7875487cd3c69">delete_mat</a>();
<a name="l00027"></a>00027   
<a name="l00028"></a>00028   <span class="keywordflow">if</span>(<a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a> == <span class="keyword">false</span>)
<a name="l00029"></a>00029     {
<a name="l00030"></a>00030     <span class="keywordflow">if</span>(<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> &gt; <span class="keyword">sizeof</span>(<a class="code" href="a00031.html#affe8edfa16d511baeb67a655228136dc">mem_local</a>)/<span class="keyword">sizeof</span>(eT) )
<a name="l00031"></a>00031       {
<a name="l00032"></a>00032       <span class="keyword">delete</span> [] <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>;
<a name="l00033"></a>00033       }
<a name="l00034"></a>00034     }
<a name="l00035"></a>00035     
<a name="l00036"></a>00036   <span class="keywordflow">if</span>(<a class="code" href="a00004.html#a7c60d1458dbc25f2433ef212ba618f2e">arma_config::debug</a> == <span class="keyword">true</span>)
<a name="l00037"></a>00037     {
<a name="l00038"></a>00038     <span class="comment">// try to expose buggy user code that accesses deleted objects</span>
<a name="l00039"></a>00039     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)       = 0;
<a name="l00040"></a>00040     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)       = 0;
<a name="l00041"></a>00041     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>) = 0;
<a name="l00042"></a>00042     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)     = 0;
<a name="l00043"></a>00043     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>)       = 0;
<a name="l00044"></a>00044     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)     = 0;
<a name="l00045"></a>00045     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)          = 0;
<a name="l00046"></a>00046     }
<a name="l00047"></a>00047   
<a name="l00048"></a>00048   <a class="code" href="a00151.html">isnt_supported_elem_type&lt;eT&gt;::check</a>();
<a name="l00049"></a>00049   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa8b4ea1c9891b95adc73fa425c7971db"></a><!-- doxytag: member="Cube::Cube" ref="gaa8b4ea1c9891b95adc73fa425c7971db" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l00055">55</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00056"></a>00056   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00057"></a>00057   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00058"></a>00058   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00059"></a>00059   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00060"></a>00060   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00061"></a>00061   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00062"></a>00062   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00063"></a>00063   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00064"></a>00064   {
<a name="l00065"></a>00065   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00066"></a>00066   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf6dc1f3691535561dd614637f7a2dda0"></a><!-- doxytag: member="Cube::Cube" ref="gaf6dc1f3691535561dd614637f7a2dda0" args="(const u32 in_rows, const u32 in_cols, const u32 in_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct the cube to have user specified dimensions </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00073">73</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00074"></a>00074   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00075"></a>00075   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00076"></a>00076   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00077"></a>00077   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00078"></a>00078   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00079"></a>00079   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00080"></a>00080   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00081"></a>00081   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00082"></a>00082   {
<a name="l00083"></a>00083   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00084"></a>00084   
<a name="l00085"></a>00085   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(in_n_rows, in_n_cols, in_n_slices);
<a name="l00086"></a>00086   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3d00c0a819c450a9dc7d09abaf95dd83"></a><!-- doxytag: member="Cube::init" ref="ga3d00c0a819c450a9dc7d09abaf95dd83" args="(const u32 in_rows, const u32 in_cols, const u32 in_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>internal cube construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new' </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00095">95</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00214">arma_check()</a>, <a class="el" href="a00401_source.html#l00185">Cube&lt; eT &gt;::create_mat()</a>, <a class="el" href="a00401_source.html#l00165">Cube&lt; eT &gt;::delete_mat()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00045">Cube&lt; eT &gt;::mem_local</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00385_source.html#l00028">access::rw()</a>, and <a class="el" href="a00402_source.html#l00038">Cube&lt; eT &gt;::use_aux_mem</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01268">Cube&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00401_source.html#l00073">Cube&lt; eT &gt;::Cube()</a>, <a class="el" href="a00401_source.html#l00333">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00401_source.html#l00212">Cube&lt; eT &gt;::operator=()</a>, <a class="el" href="a00401_source.html#l01346">Cube&lt; eT &gt;::reset()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00096"></a>00096   {
<a name="l00097"></a>00097   arma_extra_debug_sigprint( <a class="code" href="a00045.html">arma_boost::format</a>(<span class="stringliteral">&quot;in_n_rows = %d, in_n_cols = %d, in_n_slices = %d&quot;</span>) % in_n_rows % in_n_cols % in_n_slices );
<a name="l00098"></a>00098   
<a name="l00099"></a>00099   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> new_n_elem = in_n_rows * in_n_cols * in_n_slices;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101   <span class="keywordflow">if</span>(<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> == new_n_elem)
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103     <span class="keywordflow">if</span>( (<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> != in_n_rows) || (<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> != in_n_cols) || (<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> != in_n_slices) )
<a name="l00104"></a>00104       {
<a name="l00105"></a>00105       <a class="code" href="a00605.html#ga261fe3edd2f2706d3ad7875487cd3c69">delete_mat</a>();
<a name="l00106"></a>00106 
<a name="l00107"></a>00107       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)       = in_n_rows;
<a name="l00108"></a>00108       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)       = in_n_cols;
<a name="l00109"></a>00109       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>) = in_n_rows*in_n_cols;
<a name="l00110"></a>00110       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)     = in_n_slices;
<a name="l00111"></a>00111     
<a name="l00112"></a>00112       <a class="code" href="a00605.html#ga1bc39b7915eec73d01dbd1b959cb6732">create_mat</a>();
<a name="l00113"></a>00113       }
<a name="l00114"></a>00114     }
<a name="l00115"></a>00115   <span class="keywordflow">else</span>
<a name="l00116"></a>00116     {
<a name="l00117"></a>00117     arma_debug_check
<a name="l00118"></a>00118       (
<a name="l00119"></a>00119       (<a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a> == <span class="keyword">true</span>),
<a name="l00120"></a>00120       <span class="stringliteral">&quot;Cube::init(): can&apos;t change the amount of memory as auxiliary memory is in use&quot;</span>
<a name="l00121"></a>00121       );
<a name="l00122"></a>00122       
<a name="l00123"></a>00123     <a class="code" href="a00605.html#ga261fe3edd2f2706d3ad7875487cd3c69">delete_mat</a>();
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     <span class="keywordflow">if</span>(<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> &gt; <span class="keyword">sizeof</span>(<a class="code" href="a00031.html#affe8edfa16d511baeb67a655228136dc">mem_local</a>)/<span class="keyword">sizeof</span>(eT) )
<a name="l00126"></a>00126       {
<a name="l00127"></a>00127       <span class="keyword">delete</span> [] <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>;
<a name="l00128"></a>00128       }
<a name="l00129"></a>00129     
<a name="l00130"></a>00130     <span class="keywordflow">if</span>(new_n_elem &lt;= <span class="keyword">sizeof</span>(<a class="code" href="a00031.html#affe8edfa16d511baeb67a655228136dc">mem_local</a>)/<span class="keyword">sizeof</span>(eT) )
<a name="l00131"></a>00131       {
<a name="l00132"></a>00132       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>) = <a class="code" href="a00031.html#affe8edfa16d511baeb67a655228136dc">mem_local</a>;
<a name="l00133"></a>00133       }
<a name="l00134"></a>00134     <span class="keywordflow">else</span>
<a name="l00135"></a>00135       {
<a name="l00136"></a>00136       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>) = <span class="keyword">new</span>(std::nothrow) eT[new_n_elem];
<a name="l00137"></a>00137       <a class="code" href="a00606.html#gae33c63e1a88bbb22b1874f472f27df9e" title="if state is true, throw a run-time error exception">arma_check</a>( (<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a> == 0), <span class="stringliteral">&quot;Cube::init(): out of memory&quot;</span> );
<a name="l00138"></a>00138       }
<a name="l00139"></a>00139     
<a name="l00140"></a>00140     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>) = new_n_elem;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="keywordflow">if</span>(new_n_elem == 0)
<a name="l00143"></a>00143       {
<a name="l00144"></a>00144       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)       = 0;
<a name="l00145"></a>00145       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)       = 0;
<a name="l00146"></a>00146       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>) = 0;
<a name="l00147"></a>00147       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)     = 0;
<a name="l00148"></a>00148       }
<a name="l00149"></a>00149     <span class="keywordflow">else</span>
<a name="l00150"></a>00150       {
<a name="l00151"></a>00151       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)       = in_n_rows;
<a name="l00152"></a>00152       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)       = in_n_cols;
<a name="l00153"></a>00153       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>) = in_n_rows*in_n_cols;
<a name="l00154"></a>00154       <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)     = in_n_slices;
<a name="l00155"></a>00155       }
<a name="l00156"></a>00156       
<a name="l00157"></a>00157     <a class="code" href="a00605.html#ga1bc39b7915eec73d01dbd1b959cb6732">create_mat</a>();
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga261fe3edd2f2706d3ad7875487cd3c69"></a><!-- doxytag: member="Cube::delete_mat" ref="ga261fe3edd2f2706d3ad7875487cd3c69" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::delete_mat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l00165">165</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00044">Cube&lt; eT &gt;::mat_ptrs_local</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00385_source.html#l00028">access::rw()</a>, and <a class="el" href="a00401_source.html#l00594">Cube&lt; eT &gt;::slice()</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, and <a class="el" href="a00401_source.html#l00022">Cube&lt; eT &gt;::~Cube()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00166"></a>00166   {
<a name="l00167"></a>00167   arma_extra_debug_sigprint();
<a name="l00168"></a>00168   
<a name="l00169"></a>00169   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a> = 0; <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a> &lt; <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>)
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171     <span class="keyword">delete</span> <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>[<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>]);
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">if</span>(n_slices &gt; <span class="keyword">sizeof</span>(<a class="code" href="a00031.html#a54ae76c79489891b2b0f136b6b6ff717">mat_ptrs_local</a>)/<span class="keyword">sizeof</span>(<a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>*) )
<a name="l00175"></a>00175     {
<a name="l00176"></a>00176     <span class="keyword">delete</span> [] <a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>;
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1bc39b7915eec73d01dbd1b959cb6732"></a><!-- doxytag: member="Cube::create_mat" ref="ga1bc39b7915eec73d01dbd1b959cb6732" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::create_mat </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l00185">185</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00214">arma_check()</a>, <a class="el" href="a00402_source.html#l00044">Cube&lt; eT &gt;::mat_ptrs_local</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00385_source.html#l00028">access::rw()</a>, <a class="el" href="a00401_source.html#l00594">Cube&lt; eT &gt;::slice()</a>, and <a class="el" href="a00401_source.html#l01127">Cube&lt; eT &gt;::slice_memptr()</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00186"></a>00186   {
<a name="l00187"></a>00187   arma_extra_debug_sigprint();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">if</span>( <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &lt;= <span class="keyword">sizeof</span>(<a class="code" href="a00031.html#a54ae76c79489891b2b0f136b6b6ff717">mat_ptrs_local</a>)/<span class="keyword">sizeof</span>(<a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>*) )
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>) = <span class="keyword">const_cast&lt;</span> <span class="keyword">const </span><a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>** <span class="keyword">&gt;</span>(<a class="code" href="a00031.html#a54ae76c79489891b2b0f136b6b6ff717">mat_ptrs_local</a>);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193   <span class="keywordflow">else</span>
<a name="l00194"></a>00194     {
<a name="l00195"></a>00195     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>) = <span class="keyword">new</span>(std::nothrow) <span class="keyword">const</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>*[<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>];
<a name="l00196"></a>00196     <a class="code" href="a00606.html#gae33c63e1a88bbb22b1874f472f27df9e" title="if state is true, throw a run-time error exception">arma_check</a>( (<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a> == 0), <span class="stringliteral">&quot;Cube::create_mat(): out of memory&quot;</span> );
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198     
<a name="l00199"></a>00199   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a> = 0; <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a> &lt; <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201     <a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>[<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>] = <span class="keyword">new</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>(<span class="charliteral">&apos;j&apos;</span>, <a class="code" href="a00605.html#gabb8c874cad5aac59f1877f7525b675de" title="returns a pointer to array of eTs used by the specified slice in the cube">slice_memptr</a>(<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>), <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>, <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>);
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga73fd2fa4151f5bd8dab023d73c8731ba"></a><!-- doxytag: member="Cube::operator=" ref="ga73fd2fa4151f5bd8dab023d73c8731ba" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the cube to be equal to the specified scalar. NOTE: the size of the cube will be 1x1x1. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00212">212</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l00503">Cube&lt; eT &gt;::Cube()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00213"></a>00213   {
<a name="l00214"></a>00214   arma_extra_debug_sigprint();
<a name="l00215"></a>00215   
<a name="l00216"></a>00216   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(1,1,1);
<a name="l00217"></a>00217   <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[0]) = val;
<a name="l00218"></a>00218   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00219"></a>00219   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad6ca23e58aac88ec2a723ebeae7a60e1"></a><!-- doxytag: member="Cube::operator+=" ref="gad6ca23e58aac88ec2a723ebeae7a60e1" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place addition of a scalar to all elements of the cube. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00227">227</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00228"></a>00228   {
<a name="l00229"></a>00229   arma_extra_debug_sigprint();
<a name="l00230"></a>00230   
<a name="l00231"></a>00231   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l00232"></a>00232     {
<a name="l00233"></a>00233     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) += val;
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235   
<a name="l00236"></a>00236   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00237"></a>00237   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafdd9657cc414a01c77ddaecf06c072ed"></a><!-- doxytag: member="Cube::operator&#45;=" ref="gafdd9657cc414a01c77ddaecf06c072ed" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place subtraction of a scalar from all elements of the cube. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00245">245</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00246"></a>00246   {
<a name="l00247"></a>00247   arma_extra_debug_sigprint();
<a name="l00248"></a>00248   
<a name="l00249"></a>00249   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) -= val;
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253       
<a name="l00254"></a>00254   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00255"></a>00255   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga348b03ddc6dbaebf2bcddf2625947980"></a><!-- doxytag: member="Cube::operator*=" ref="ga348b03ddc6dbaebf2bcddf2625947980" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place multiplication of all elements of the cube with a scalar. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00263">263</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00264"></a>00264   {
<a name="l00265"></a>00265   arma_extra_debug_sigprint();
<a name="l00266"></a>00266   
<a name="l00267"></a>00267   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l00268"></a>00268     {
<a name="l00269"></a>00269     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) *= val;
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271   
<a name="l00272"></a>00272   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00273"></a>00273   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga40d5d0e8391797cd3eac772147297b43"></a><!-- doxytag: member="Cube::operator/=" ref="ga40d5d0e8391797cd3eac772147297b43" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In-place division of all elements of the cube with a scalar. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00281">281</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00282"></a>00282   {
<a name="l00283"></a>00283   arma_extra_debug_sigprint();
<a name="l00284"></a>00284   
<a name="l00285"></a>00285   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l00286"></a>00286     {
<a name="l00287"></a>00287     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) /= val;
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289   
<a name="l00290"></a>00290   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00291"></a>00291   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga458bec1f3fc6ebb878d88eaaae747089"></a><!-- doxytag: member="Cube::Cube" ref="ga458bec1f3fc6ebb878d88eaaae747089" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a given cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00298">298</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00299"></a>00299   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00300"></a>00300   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00301"></a>00301   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00302"></a>00302   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00303"></a>00303   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00304"></a>00304   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00305"></a>00305   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00306"></a>00306   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00307"></a>00307   {
<a name="l00308"></a>00308   arma_extra_debug_sigprint(<a class="code" href="a00045.html">arma_boost::format</a>(<span class="stringliteral">&quot;this = %x   in_cube = %x&quot;</span>) % <span class="keyword">this</span> % &amp;in_cube);
<a name="l00309"></a>00309   
<a name="l00310"></a>00310   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(in_cube);
<a name="l00311"></a>00311   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2c4c1a84d9c3e8c2c59f4759a6e3a1af"></a><!-- doxytag: member="Cube::operator=" ref="ga2c4c1a84d9c3e8c2c59f4759a6e3a1af" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a given cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00319">319</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00320"></a>00320   {
<a name="l00321"></a>00321   arma_extra_debug_sigprint();
<a name="l00322"></a>00322   
<a name="l00323"></a>00323   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(x);
<a name="l00324"></a>00324   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00325"></a>00325   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaac8dfe2922518d480f6d89326e3991e2"></a><!-- doxytag: member="Cube::init" ref="gaac8dfe2922518d480f6d89326e3991e2" args="(const Cube &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a given cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00333">333</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00582_source.html#l00028">syslib::copy_elem()</a>, <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00334"></a>00334   {
<a name="l00335"></a>00335   arma_extra_debug_sigprint();
<a name="l00336"></a>00336   
<a name="l00337"></a>00337   <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;x)
<a name="l00338"></a>00338     {
<a name="l00339"></a>00339     <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>, x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>, x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>);
<a name="l00340"></a>00340     <a class="code" href="a00324.html#a9eb4d78b666f4deaafdf75d1345a38e1">syslib::copy_elem</a>( <a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>(), x.<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>, <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> );
<a name="l00341"></a>00341     }
<a name="l00342"></a>00342   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac330d35dcab2f8916d3dac82f88309b9"></a><!-- doxytag: member="Cube::Cube" ref="gac330d35dcab2f8916d3dac82f88309b9" args="(eT *aux_mem, const u32 aux_n_rows, const u32 aux_n_cols, const u32 aux_n_slices, const bool copy_aux_mem=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">eT *&nbsp;</td>
          <td class="paramname"> <em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>copy_aux_mem</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). note that in the latter case the default is to copy the array. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00354">354</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00582_source.html#l00028">syslib::copy_elem()</a>, <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00355"></a>00355   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>      (copy_aux_mem ? 0     : aux_n_rows                        )
<a name="l00356"></a>00356   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>      (copy_aux_mem ? 0     : aux_n_cols                        )
<a name="l00357"></a>00357   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(copy_aux_mem ? 0     : aux_n_rows*aux_n_cols             )
<a name="l00358"></a>00358   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>    (copy_aux_mem ? 0     : aux_n_slices                      )
<a name="l00359"></a>00359   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>      (copy_aux_mem ? 0     : aux_n_rows*aux_n_cols*aux_n_slices)
<a name="l00360"></a>00360   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a> (copy_aux_mem ? <span class="keyword">false</span> : <span class="keyword">true</span>                              )
<a name="l00361"></a>00361   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>         (copy_aux_mem ? <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>   : aux_mem                           )
<a name="l00362"></a>00362   {
<a name="l00363"></a>00363   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00364"></a>00364   
<a name="l00365"></a>00365   <span class="keywordflow">if</span>(copy_aux_mem == <span class="keyword">true</span>)
<a name="l00366"></a>00366     {
<a name="l00367"></a>00367     <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(aux_n_rows, aux_n_cols, aux_n_slices);
<a name="l00368"></a>00368     <a class="code" href="a00324.html#a9eb4d78b666f4deaafdf75d1345a38e1">syslib::copy_elem</a>( <a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>(), aux_mem, <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> );
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab23146a09d55cfeec1f74809cf006790"></a><!-- doxytag: member="Cube::Cube" ref="gab23146a09d55cfeec1f74809cf006790" args="(const eT *aux_mem, const u32 aux_n_rows, const u32 aux_n_cols, const u32 aux_n_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const eT *&nbsp;</td>
          <td class="paramname"> <em>aux_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>aux_n_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a given auxiliary read-only array of eTs. the array is copied. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00378">378</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00582_source.html#l00028">syslib::copy_elem()</a>, <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00379"></a>00379   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00380"></a>00380   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00381"></a>00381   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00382"></a>00382   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00383"></a>00383   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00384"></a>00384   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00385"></a>00385   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00386"></a>00386   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00387"></a>00387   {
<a name="l00388"></a>00388   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00389"></a>00389   
<a name="l00390"></a>00390   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(aux_n_rows, aux_n_cols, aux_n_slices);
<a name="l00391"></a>00391   <a class="code" href="a00324.html#a9eb4d78b666f4deaafdf75d1345a38e1">syslib::copy_elem</a>( <a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>(), aux_mem, <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a> );
<a name="l00392"></a>00392   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga031db49c5ce03bf5fbdd6f141a784125"></a><!-- doxytag: member="Cube::operator+=" ref="ga031db49c5ce03bf5fbdd6f141a784125" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube addition </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00400">400</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00465_source.html#l00098">glue_cube_plus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00401"></a>00401   {
<a name="l00402"></a>00402   arma_extra_debug_sigprint();
<a name="l00403"></a>00403   
<a name="l00404"></a>00404   <a class="code" href="a00660.html#ga8b71fcfed869b60dc6d44decd33dba76">glue_cube_plus::apply_inplace</a>(*<span class="keyword">this</span>, m);
<a name="l00405"></a>00405   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00406"></a>00406   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafcc85205e8a9fd17f18566b8b3a03c70"></a><!-- doxytag: member="Cube::operator&#45;=" ref="gafcc85205e8a9fd17f18566b8b3a03c70" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube subtraction </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00414">414</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00463_source.html#l00098">glue_cube_minus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00415"></a>00415   {
<a name="l00416"></a>00416   arma_extra_debug_sigprint();
<a name="l00417"></a>00417   
<a name="l00418"></a>00418   <a class="code" href="a00659.html#gad6c096948f754f0d250aa22b3e2080b5" title="Immediate out -= B.">glue_cube_minus::apply_inplace</a>(*<span class="keyword">this</span>, m);
<a name="l00419"></a>00419   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00420"></a>00420   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6e4729f1623baf2c96b9cca73e06a9a2"></a><!-- doxytag: member="Cube::operator%=" ref="ga6e4729f1623baf2c96b9cca73e06a9a2" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place element-wise cube multiplication </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00428">428</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00467_source.html#l00097">glue_cube_schur::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00429"></a>00429   {
<a name="l00430"></a>00430   arma_extra_debug_sigprint();
<a name="l00431"></a>00431   
<a name="l00432"></a>00432   <a class="code" href="a00661.html#gad988c8656c9af34325e61f6dd7a2d21d">glue_cube_schur::apply_inplace</a>(*<span class="keyword">this</span>, m);
<a name="l00433"></a>00433   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00434"></a>00434   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga996bc9ab51f31e1a32694bb6a1b95520"></a><!-- doxytag: member="Cube::operator/=" ref="ga996bc9ab51f31e1a32694bb6a1b95520" args="(const Cube &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place element-wise cube division </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00442">442</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00460_source.html#l00097">glue_cube_div::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00443"></a>00443   {
<a name="l00444"></a>00444   arma_extra_debug_sigprint();
<a name="l00445"></a>00445   
<a name="l00446"></a>00446   <a class="code" href="a00657.html#gae7b85291b9076feca2728eee30ac1336">glue_cube_div::apply_inplace</a>(*<span class="keyword">this</span>, m);
<a name="l00447"></a>00447   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00448"></a>00448   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga14529609eaa889061eb3972522f5da3b"></a><!-- doxytag: member="Cube::Cube" ref="ga14529609eaa889061eb3972522f5da3b" args="(const BaseCube&lt; pod_type, T1 &gt; &amp;A, const BaseCube&lt; pod_type, T2 &gt; &amp;B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00020.html">BaseCube</a>&lt; <a class="el" href="a00031.html#a20449225ba1271069393abc4086e2b2c">pod_type</a>, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00020.html">BaseCube</a>&lt; <a class="el" href="a00031.html#a20449225ba1271069393abc4086e2b2c">pod_type</a>, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for constructing a complex cube out of two non-complex cubes </p>

<p><p>&lt; compile-time abort if eT isn't std::complex</p>
<p>&lt; compile-time abort if T is std::complex</p>
<p>&lt; compile-time abort if types are not compatible </p>
</p>

<p>Definition at line <a class="el" href="a00401_source.html#l00457">457</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00285">arma_assert_same_size()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00461"></a>00461   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00462"></a>00462   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00463"></a>00463   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00464"></a>00464   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00465"></a>00465   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00466"></a>00466   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00467"></a>00467   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00468"></a>00468   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00469"></a>00469   {
<a name="l00470"></a>00470   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00471"></a>00471   
<a name="l00472"></a>00472   <a class="code" href="a00016.html">arma_type_check&lt; is_complex&lt;eT&gt;::value</a> == <span class="keyword">false</span> &gt;::apply();   <span class="comment">//!&lt; compile-time abort if eT isn&apos;t std::complex</span>
<a name="l00473"></a>00473 <span class="comment"></span>  
<a name="l00474"></a>00474   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type T;
<a name="l00475"></a>00475   <a class="code" href="a00016.html">arma_type_check&lt; is_complex&lt;T&gt;::value</a> == <span class="keyword">true</span> &gt;::apply();   <span class="comment">//!&lt; compile-time abort if T is std::complex</span>
<a name="l00476"></a>00476 <span class="comment"></span>  
<a name="l00477"></a>00477   <a class="code" href="a00149.html">isnt_same_type&lt;std::complex&lt;T&gt;</a>, eT&gt;::check();   <span class="comment">//!&lt; compile-time abort if types are not compatible</span>
<a name="l00478"></a>00478 <span class="comment"></span>  
<a name="l00479"></a>00479   <span class="keyword">const</span> <a class="code" href="a00341.html">unwrap_cube&lt;T1&gt;</a> tmp_A(A.<a class="code" href="a00020.html#a65f6e7fb3341e814ca4e7d683ec3595c">get_ref</a>());
<a name="l00480"></a>00480   <span class="keyword">const</span> <a class="code" href="a00341.html">unwrap_cube&lt;T2&gt;</a> tmp_B(B.<a class="code" href="a00020.html#a65f6e7fb3341e814ca4e7d683ec3595c">get_ref</a>());
<a name="l00481"></a>00481   
<a name="l00482"></a>00482   <span class="keyword">const</span> <a class="code" href="a00031.html" title="Dense cube class.">Cube&lt;T&gt;</a>&amp; X = tmp_A.M;
<a name="l00483"></a>00483   <span class="keyword">const</span> <a class="code" href="a00031.html" title="Dense cube class.">Cube&lt;T&gt;</a>&amp; Y = tmp_B.M;
<a name="l00484"></a>00484   
<a name="l00485"></a>00485   <a class="code" href="a00606.html#gaed62a3eceba5209655f9deefba4fc7cc">arma_assert_same_size</a>(X, Y, <span class="stringliteral">&quot;Cube()&quot;</span>);
<a name="l00486"></a>00486   
<a name="l00487"></a>00487   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(X.n_rows, X.n_cols, X.n_slices);
<a name="l00488"></a>00488   
<a name="l00489"></a>00489   <span class="keyword">const</span> T* X_mem = X.mem;
<a name="l00490"></a>00490   <span class="keyword">const</span> T* Y_mem = Y.<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>;
<a name="l00491"></a>00491   
<a name="l00492"></a>00492   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l00493"></a>00493     {
<a name="l00494"></a>00494     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) = std::complex&lt;T&gt;(X_mem[i], Y_mem[i]);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga5edb2ac646b7408343aba2971b181104"></a><!-- doxytag: member="Cube::Cube" ref="ga5edb2ac646b7408343aba2971b181104" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00503">503</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00212">Cube&lt; eT &gt;::operator=()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00504"></a>00504   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00505"></a>00505   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00506"></a>00506   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00507"></a>00507   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00508"></a>00508   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00509"></a>00509   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00510"></a>00510   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00511"></a>00511   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00512"></a>00512   {
<a name="l00513"></a>00513   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00514"></a>00514   
<a name="l00515"></a>00515   this-&gt;<a class="code" href="a00605.html#ga73fd2fa4151f5bd8dab023d73c8731ba" title="Set the cube to be equal to the specified scalar. NOTE: the size of the cube will...">operator=</a>(X);
<a name="l00516"></a>00516   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab6fc51265fb78aa3b5e69e7ce51bff6f"></a><!-- doxytag: member="Cube::operator=" ref="gab6fc51265fb78aa3b5e69e7ce51bff6f" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct a cube from a <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance (e.g. construct a cube from a delayed subcube operation) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00524">524</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00525"></a>00525   {
<a name="l00526"></a>00526   arma_extra_debug_sigprint();
<a name="l00527"></a>00527   
<a name="l00528"></a>00528   <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;::extract</a>(*<span class="keyword">this</span>, X);
<a name="l00529"></a>00529   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00530"></a>00530   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab7ff823e63a04d322137bab296fd40c0"></a><!-- doxytag: member="Cube::operator+=" ref="gab7ff823e63a04d322137bab296fd40c0" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube addition (using a subcube on the right-hand-side) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00538">538</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00539"></a>00539   {
<a name="l00540"></a>00540   arma_extra_debug_sigprint();
<a name="l00541"></a>00541   
<a name="l00542"></a>00542   <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;::plus_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00543"></a>00543   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00544"></a>00544   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab188ca927465a03ded825df6cb8c8d5e"></a><!-- doxytag: member="Cube::operator&#45;=" ref="gab188ca927465a03ded825df6cb8c8d5e" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube subtraction (using a subcube on the right-hand-side) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00552">552</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00553"></a>00553   {
<a name="l00554"></a>00554   arma_extra_debug_sigprint();
<a name="l00555"></a>00555   
<a name="l00556"></a>00556   <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;::minus_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00557"></a>00557   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00558"></a>00558   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae32382263d12d93c74b5593145a7250c"></a><!-- doxytag: member="Cube::operator%=" ref="gae32382263d12d93c74b5593145a7250c" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place element-wise cube mutiplication (using a subcube on the right-hand-side) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00566">566</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00567"></a>00567   {
<a name="l00568"></a>00568   arma_extra_debug_sigprint();
<a name="l00569"></a>00569   
<a name="l00570"></a>00570   <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;::schur_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00571"></a>00571   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00572"></a>00572   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4769b282b8a4a39a15b52a6131c1acc6"></a><!-- doxytag: member="Cube::operator/=" ref="ga4769b282b8a4a39a15b52a6131c1acc6" args="(const subview_cube&lt; eT &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place element-wise cube division (using a subcube on the right-hand-side) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00580">580</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00581"></a>00581   {
<a name="l00582"></a>00582   arma_extra_debug_sigprint();
<a name="l00583"></a>00583   
<a name="l00584"></a>00584   <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;::div_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00585"></a>00585   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00586"></a>00586   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga278055e14ab971acffa2d4616cc65f68"></a><!-- doxytag: member="Cube::slice" ref="ga278055e14ab971acffa2d4616cc65f68" args="(const u32 in_slice)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>provide the reference to the matrix representing a single slice </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00594">594</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l00185">Cube&lt; eT &gt;::create_mat()</a>, <a class="el" href="a00401_source.html#l00165">Cube&lt; eT &gt;::delete_mat()</a>, <a class="el" href="a00406_source.html#l01399">diskio::load_raw_ascii()</a>, and <a class="el" href="a00386_source.html#l00229">arma_ostream::print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00595"></a>00595   {
<a name="l00596"></a>00596   arma_extra_debug_sigprint();
<a name="l00597"></a>00597   
<a name="l00598"></a>00598   arma_debug_check
<a name="l00599"></a>00599     (
<a name="l00600"></a>00600     (in_slice &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00601"></a>00601     <span class="stringliteral">&quot;Cube::slice(): index out of bounds&quot;</span>
<a name="l00602"></a>00602     );
<a name="l00603"></a>00603   
<a name="l00604"></a>00604   <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; <span class="keyword">&gt;</span>( *(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>[in_slice]) );
<a name="l00605"></a>00605   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga54d5d9ffe36d6e84cbbd0fa453b070b9"></a><!-- doxytag: member="Cube::slice" ref="ga54d5d9ffe36d6e84cbbd0fa453b070b9" args="(const u32 in_slice) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>provide the reference to the matrix representing a single slice </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00613">613</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00614"></a>00614   {
<a name="l00615"></a>00615   arma_extra_debug_sigprint();
<a name="l00616"></a>00616   
<a name="l00617"></a>00617   arma_debug_check
<a name="l00618"></a>00618     (
<a name="l00619"></a>00619     (in_slice &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00620"></a>00620     <span class="stringliteral">&quot;Cube::slice(): index out of bounds&quot;</span>
<a name="l00621"></a>00621     );
<a name="l00622"></a>00622    
<a name="l00623"></a>00623   <span class="keywordflow">return</span> *(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>[in_slice]);
<a name="l00624"></a>00624   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gabb10bd8ca819f55992e6a00a499a7534"></a><!-- doxytag: member="Cube::slices" ref="gabb10bd8ca819f55992e6a00a499a7534" args="(const u32 in_slice1, const u32 in_slice2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (subcube comprised of specified slices) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00632">632</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00633"></a>00633   {
<a name="l00634"></a>00634   arma_extra_debug_sigprint();
<a name="l00635"></a>00635   
<a name="l00636"></a>00636   arma_debug_check
<a name="l00637"></a>00637     (
<a name="l00638"></a>00638     (in_slice1 &gt; in_slice2) || (in_slice2 &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00639"></a>00639     <span class="stringliteral">&quot;Cube::slices(): indices out of bounds or incorrectly used&quot;</span>
<a name="l00640"></a>00640     );
<a name="l00641"></a>00641   
<a name="l00642"></a>00642   <span class="keywordflow">return</span> <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;</a>(*<span class="keyword">this</span>, 0, 0, in_slice1, ( (<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>&gt;0) ? <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>-1 : 0 ), ( (<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>&gt;0) ? <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>-1 : 0 ), in_slice2);
<a name="l00643"></a>00643   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga5d520256a1d24d61cfac4744eaa3278a"></a><!-- doxytag: member="Cube::slices" ref="ga5d520256a1d24d61cfac4744eaa3278a" args="(const u32 in_slice1, const u32 in_slice2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (subcube comprised of specified slices) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00651">651</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00652"></a>00652   {
<a name="l00653"></a>00653   arma_extra_debug_sigprint();
<a name="l00654"></a>00654   
<a name="l00655"></a>00655   arma_debug_check
<a name="l00656"></a>00656     (
<a name="l00657"></a>00657     (in_slice1 &gt; in_slice2) || (in_slice2 &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00658"></a>00658     <span class="stringliteral">&quot;Cube::rows(): indices out of bounds or incorrectly used&quot;</span>
<a name="l00659"></a>00659     );
<a name="l00660"></a>00660   
<a name="l00661"></a>00661   <span class="keywordflow">return</span> <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;</a>(*<span class="keyword">this</span>, 0, 0, in_slice1, ( (<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>&gt;0) ? <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>-1 : 0 ), ( (<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>&gt;0) ? <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>-1 : 0 ), in_slice2);
<a name="l00662"></a>00662   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga13d5f790036b1c28af7f839d7026078f"></a><!-- doxytag: member="Cube::subcube" ref="ga13d5f790036b1c28af7f839d7026078f" args="(const u32 in_row1, const u32 in_col1, const u32 in_slice1, const u32 in_row2, const u32 in_col2, const u32 in_slice2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::subcube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (generic subcube) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00670">670</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00671"></a>00671   {
<a name="l00672"></a>00672   arma_extra_debug_sigprint();
<a name="l00673"></a>00673   
<a name="l00674"></a>00674   arma_debug_check
<a name="l00675"></a>00675     (
<a name="l00676"></a>00676     (in_row1 &gt;  in_row2) || (in_col1 &gt;  in_col2) || (in_slice1 &gt;  in_slice2) ||
<a name="l00677"></a>00677     (in_row2 &gt;= <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)  || (in_col2 &gt;= <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)  || (in_slice2 &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00678"></a>00678     <span class="stringliteral">&quot;Cube::subcube(): indices out of bounds or incorrectly used&quot;</span>
<a name="l00679"></a>00679     );
<a name="l00680"></a>00680   
<a name="l00681"></a>00681   <span class="keywordflow">return</span> <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;</a>(*<span class="keyword">this</span>, in_row1, in_col1, in_slice1, in_row2, in_col2, in_slice2);
<a name="l00682"></a>00682   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga3e8561d6c2b738e2eef9e836c85b39a4"></a><!-- doxytag: member="Cube::subcube" ref="ga3e8561d6c2b738e2eef9e836c85b39a4" args="(const u32 in_row1, const u32 in_col1, const u32 in_slice1, const u32 in_row2, const u32 in_col2, const u32 in_slice2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00321.html">subview_cube</a>&lt; eT &gt; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::subcube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creation of <a class="el" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> (generic subcube) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00690">690</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00691"></a>00691   {
<a name="l00692"></a>00692   arma_extra_debug_sigprint();
<a name="l00693"></a>00693   
<a name="l00694"></a>00694   arma_debug_check
<a name="l00695"></a>00695     (
<a name="l00696"></a>00696     (in_row1 &gt;  in_row2) || (in_col1 &gt;  in_col2) || (in_slice1 &gt;  in_slice2) ||
<a name="l00697"></a>00697     (in_row2 &gt;= <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>)  || (in_col2 &gt;= <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>)  || (in_slice2 &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>),
<a name="l00698"></a>00698     <span class="stringliteral">&quot;Cube::subcube(): indices out of bounds or incorrectly used&quot;</span>
<a name="l00699"></a>00699     );
<a name="l00700"></a>00700     
<a name="l00701"></a>00701   <span class="keywordflow">return</span> <a class="code" href="a00321.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube&lt;eT&gt;</a>(*<span class="keyword">this</span>, in_row1, in_col1, in_slice1, in_row2, in_col2, in_slice2);
<a name="l00702"></a>00702   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga96ac56c25f53f3318c2cd205ec245c14"></a><!-- doxytag: member="Cube::Cube" ref="ga96ac56c25f53f3318c2cd205ec245c14" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a cube from <a class="el" href="a00229.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00710">710</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00711"></a>00711   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00712"></a>00712   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00713"></a>00713   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00714"></a>00714   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00715"></a>00715   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00716"></a>00716   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00717"></a>00717   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00718"></a>00718   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00719"></a>00719   {
<a name="l00720"></a>00720   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00723"></a>00723   
<a name="l00724"></a>00724   op_cube_type::apply(*<span class="keyword">this</span>, X);
<a name="l00725"></a>00725   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad549847c54ebdfa4d8fc620af86fa28a"></a><!-- doxytag: member="Cube::operator=" ref="gad549847c54ebdfa4d8fc620af86fa28a" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a cube from <a class="el" href="a00229.html" title="Analog of the Op class, intended for cubes.">OpCube</a>, i.e. run the previously delayed unary operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00734">734</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00735"></a>00735   {
<a name="l00736"></a>00736   arma_extra_debug_sigprint();
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00739"></a>00739   
<a name="l00740"></a>00740   op_cube_type::apply(*<span class="keyword">this</span>, X);
<a name="l00741"></a>00741   
<a name="l00742"></a>00742   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00743"></a>00743   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0c9be3b1f887464943ee8eb72ef27be1"></a><!-- doxytag: member="Cube::operator+=" ref="ga0c9be3b1f887464943ee8eb72ef27be1" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube addition, with the right-hand-side operand having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00752">752</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00465_source.html#l00098">glue_cube_plus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00753"></a>00753   {
<a name="l00754"></a>00754   arma_extra_debug_sigprint();
<a name="l00755"></a>00755   
<a name="l00756"></a>00756   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00757"></a>00757   
<a name="l00758"></a>00758   <a class="code" href="a00660.html#ga8b71fcfed869b60dc6d44decd33dba76">glue_cube_plus::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00759"></a>00759   
<a name="l00760"></a>00760   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00761"></a>00761   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0371c0de0cb968f530fcd952a7f0f7cf"></a><!-- doxytag: member="Cube::operator&#45;=" ref="ga0371c0de0cb968f530fcd952a7f0f7cf" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube subtraction, with the right-hand-side operand having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00770">770</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00463_source.html#l00098">glue_cube_minus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00771"></a>00771   {
<a name="l00772"></a>00772   arma_extra_debug_sigprint();
<a name="l00773"></a>00773   
<a name="l00774"></a>00774   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00775"></a>00775   
<a name="l00776"></a>00776   <a class="code" href="a00659.html#gad6c096948f754f0d250aa22b3e2080b5" title="Immediate out -= B.">glue_cube_minus::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00777"></a>00777   
<a name="l00778"></a>00778   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00779"></a>00779   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gabc8ff44d694e522045d8fbf7eadfddfe"></a><!-- doxytag: member="Cube::operator%=" ref="gabc8ff44d694e522045d8fbf7eadfddfe" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube element-wise multiplication, with the right-hand-side operand having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00788">788</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00467_source.html#l00097">glue_cube_schur::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00789"></a>00789   {
<a name="l00790"></a>00790   arma_extra_debug_sigprint();
<a name="l00791"></a>00791   
<a name="l00792"></a>00792   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00793"></a>00793   <a class="code" href="a00661.html#gad988c8656c9af34325e61f6dd7a2d21d">glue_cube_schur::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00794"></a>00794   
<a name="l00795"></a>00795   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00796"></a>00796   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9121b55b0f49c8b38a4f81042ace6670"></a><!-- doxytag: member="Cube::operator/=" ref="ga9121b55b0f49c8b38a4f81042ace6670" args="(const OpCube&lt; T1, op_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename op_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00229.html">OpCube</a>&lt; T1, op_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube element-wise division, with the right-hand-side operand having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00805">805</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00460_source.html#l00097">glue_cube_div::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00806"></a>00806   {
<a name="l00807"></a>00807   arma_extra_debug_sigprint();
<a name="l00808"></a>00808   
<a name="l00809"></a>00809   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00810"></a>00810   <a class="code" href="a00657.html#gae7b85291b9076feca2728eee30ac1336">glue_cube_div::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00811"></a>00811   
<a name="l00812"></a>00812   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00813"></a>00813   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga55083a264e4d2ab43624215b2b9d1b81"></a><!-- doxytag: member="Cube::Cube" ref="ga55083a264e4d2ab43624215b2b9d1b81" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::<a class="el" href="a00031.html">Cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a cube from <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00821">821</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00212">Cube&lt; eT &gt;::operator=()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00822"></a>00822   : <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>(0)
<a name="l00823"></a>00823   , <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>(0)
<a name="l00824"></a>00824   , <a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a>(0)
<a name="l00825"></a>00825   , <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>(0)
<a name="l00826"></a>00826   , <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>(0)
<a name="l00827"></a>00827   , <a class="code" href="a00031.html#a76ca60ba526d0f30fd9af3140cd3f90f" title="true if externally managed memory is being used (read-only)">use_aux_mem</a>(<span class="keyword">false</span>)
<a name="l00828"></a>00828   , <a class="code" href="a00031.html#af36259cd155a9251769b6533146eeeb8" title="pointer to an array containing pointers to Mat instances (one for each slice)">mat_ptrs</a>(<a class="code" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a>)
<a name="l00829"></a>00829   , <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>)
<a name="l00830"></a>00830   {
<a name="l00831"></a>00831   arma_extra_debug_sigprint_this(<span class="keyword">this</span>);
<a name="l00832"></a>00832   this-&gt;<a class="code" href="a00605.html#ga73fd2fa4151f5bd8dab023d73c8731ba" title="Set the cube to be equal to the specified scalar. NOTE: the size of the cube will...">operator=</a>(X);
<a name="l00833"></a>00833   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa80458b9a802a48454e6708a17712fe1"></a><!-- doxytag: member="Cube::operator=" ref="gaa80458b9a802a48454e6708a17712fe1" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a cube from <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00842">842</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00843"></a>00843   {
<a name="l00844"></a>00844   arma_extra_debug_sigprint();
<a name="l00845"></a>00845   
<a name="l00846"></a>00846   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00847"></a>00847   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T2::elem_type&gt;::check</a>();
<a name="l00848"></a>00848   
<a name="l00849"></a>00849   glue_cube_type::apply(*<span class="keyword">this</span>, X);
<a name="l00850"></a>00850   
<a name="l00851"></a>00851   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00852"></a>00852   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa37e3b72f34684c213166c78afcb7890"></a><!-- doxytag: member="Cube::operator+=" ref="gaa37e3b72f34684c213166c78afcb7890" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube addition, with the right-hand-side operands having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00860">860</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00465_source.html#l00098">glue_cube_plus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00861"></a>00861   {
<a name="l00862"></a>00862   arma_extra_debug_sigprint();
<a name="l00863"></a>00863   
<a name="l00864"></a>00864   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00865"></a>00865   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T2::elem_type&gt;::check</a>();
<a name="l00866"></a>00866   
<a name="l00867"></a>00867   <a class="code" href="a00660.html#ga8b71fcfed869b60dc6d44decd33dba76">glue_cube_plus::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00868"></a>00868   
<a name="l00869"></a>00869   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00870"></a>00870   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac64226124d2264e4a751f58502bcd511"></a><!-- doxytag: member="Cube::operator&#45;=" ref="gac64226124d2264e4a751f58502bcd511" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube subtraction, with the right-hand-side operands having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00879">879</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00463_source.html#l00098">glue_cube_minus::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00880"></a>00880   {
<a name="l00881"></a>00881   arma_extra_debug_sigprint();
<a name="l00882"></a>00882   
<a name="l00883"></a>00883   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00884"></a>00884   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T2::elem_type&gt;::check</a>();
<a name="l00885"></a>00885   
<a name="l00886"></a>00886   <a class="code" href="a00659.html#gad6c096948f754f0d250aa22b3e2080b5" title="Immediate out -= B.">glue_cube_minus::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00887"></a>00887   
<a name="l00888"></a>00888   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00889"></a>00889   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga735e135b7b9505cb44f97bb3cf94b142"></a><!-- doxytag: member="Cube::operator%=" ref="ga735e135b7b9505cb44f97bb3cf94b142" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube element-wise multiplication, with the right-hand-side operands having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00898">898</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00467_source.html#l00097">glue_cube_schur::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00899"></a>00899   {
<a name="l00900"></a>00900   arma_extra_debug_sigprint();
<a name="l00901"></a>00901   
<a name="l00902"></a>00902   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00903"></a>00903   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T2::elem_type&gt;::check</a>();
<a name="l00904"></a>00904   
<a name="l00905"></a>00905   <a class="code" href="a00661.html#gad988c8656c9af34325e61f6dd7a2d21d">glue_cube_schur::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00906"></a>00906   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00907"></a>00907   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga57102c0ed5f78153e8d96cd2e9636c0f"></a><!-- doxytag: member="Cube::operator/=" ref="ga57102c0ed5f78153e8d96cd2e9636c0f" args="(const GlueCube&lt; T1, T2, glue_cube_type &gt; &amp;X)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename glue_cube_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">GlueCube</a>&lt; T1, T2, glue_cube_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>in-place cube element-wise division, with the right-hand-side operands having delayed operations </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00916">916</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00460_source.html#l00097">glue_cube_div::apply_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00917"></a>00917   {
<a name="l00918"></a>00918   arma_extra_debug_sigprint();
<a name="l00919"></a>00919   
<a name="l00920"></a>00920   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T1::elem_type&gt;::check</a>();
<a name="l00921"></a>00921   <a class="code" href="a00149.html">isnt_same_type&lt;eT, typename T2::elem_type&gt;::check</a>();
<a name="l00922"></a>00922   
<a name="l00923"></a>00923   <a class="code" href="a00657.html#gae7b85291b9076feca2728eee30ac1336">glue_cube_div::apply_inplace</a>(*<span class="keyword">this</span>, X);
<a name="l00924"></a>00924   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00925"></a>00925   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4e59e4633632a8ae7558d7ff6d6fdba4"></a><!-- doxytag: member="Cube::operator()" ref="ga4e59e4633632a8ae7558d7ff6d6fdba4" args="(const u32 i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00933">933</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00934"></a>00934   {
<a name="l00935"></a>00935   arma_debug_check( (i &gt;= <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>), <span class="stringliteral">&quot;Cube::operator(): index out of bounds&quot;</span>);
<a name="l00936"></a>00936   <span class="keywordflow">return</span> <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]);
<a name="l00937"></a>00937   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga118d45e6400af4a07014f7469736b8d0"></a><!-- doxytag: member="Cube::operator()" ref="ga118d45e6400af4a07014f7469736b8d0" args="(const u32 i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>linear element accessor (treats the cube as a vector); bounds checking not done when ARMA_NO_DEBUG is defined </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00945">945</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00946"></a>00946   {
<a name="l00947"></a>00947   arma_debug_check( (i &gt;= <a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>), <span class="stringliteral">&quot;Cube::operator(): index out of bounds&quot;</span>);
<a name="l00948"></a>00948   <span class="keywordflow">return</span> <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i];
<a name="l00949"></a>00949   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaba0217b709fe7de1e87a7c800a0889f6"></a><!-- doxytag: member="Cube::operator[]" ref="gaba0217b709fe7de1e87a7c800a0889f6" args="(const u32 i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>linear element accessor (treats the cube as a vector); no bounds check. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00956">956</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00957"></a>00957   {
<a name="l00958"></a>00958   <span class="keywordflow">return</span> <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]);
<a name="l00959"></a>00959   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga88d1abb930c1f5be83811ea896316e26"></a><!-- doxytag: member="Cube::operator[]" ref="ga88d1abb930c1f5be83811ea896316e26" args="(const u32 i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>linear element accessor (treats the cube as a vector); no bounds check </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00967">967</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00968"></a>00968   {
<a name="l00969"></a>00969   <span class="keywordflow">return</span> <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i];
<a name="l00970"></a>00970   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4aa508c78ec365c4c4ff5365c318dfd2"></a><!-- doxytag: member="Cube::operator()" ref="ga4aa508c78ec365c4c4ff5365c318dfd2" args="(const u32 in_row, const u32 in_col, const u32 in_slice)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element accessor; bounds checking not done when ARMA_NO_DEBUG is defined </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00978">978</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00979"></a>00979   {
<a name="l00980"></a>00980   arma_debug_check
<a name="l00981"></a>00981     (
<a name="l00982"></a>00982     (in_row &gt;= <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>) ||
<a name="l00983"></a>00983     (in_col &gt;= <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>) ||
<a name="l00984"></a>00984     (in_slice &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)
<a name="l00985"></a>00985     ,
<a name="l00986"></a>00986     <span class="stringliteral">&quot;Cube::operator(): index out of bounds&quot;</span>
<a name="l00987"></a>00987     );
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   <span class="keywordflow">return</span> <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[in_slice*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + in_col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> + in_row]);
<a name="l00990"></a>00990   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga38cab70dd2d52a6f55ecf5b7ba8e00db"></a><!-- doxytag: member="Cube::operator()" ref="ga38cab70dd2d52a6f55ecf5b7ba8e00db" args="(const u32 in_row, const u32 in_col, const u32 in_slice) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element accessor; bounds checking not done when ARMA_NO_DEBUG is defined </p>

<p>Definition at line <a class="el" href="a00401_source.html#l00998">998</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00999"></a>00999   {
<a name="l01000"></a>01000   arma_debug_check
<a name="l01001"></a>01001     (
<a name="l01002"></a>01002     (in_row &gt;= <a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>) ||
<a name="l01003"></a>01003     (in_col &gt;= <a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>) ||
<a name="l01004"></a>01004     (in_slice &gt;= <a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>)
<a name="l01005"></a>01005     ,
<a name="l01006"></a>01006     <span class="stringliteral">&quot;Cube::operator(): index out of bounds&quot;</span>
<a name="l01007"></a>01007     );
<a name="l01008"></a>01008 
<a name="l01009"></a>01009   <span class="keywordflow">return</span> <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[in_slice*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + in_col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> + in_row];
<a name="l01010"></a>01010   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga88789d28113d5e6606c27f802c506c82"></a><!-- doxytag: member="Cube::at" ref="ga88789d28113d5e6606c27f802c506c82" args="(const u32 in_row, const u32 in_col, const u32 in_slice)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element accessor; no bounds check </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01018">1018</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p>Referenced by <a class="el" href="a00531_source.html#l00082">op_reshape::apply()</a>, <a class="el" href="a00465_source.html#l00238">glue_cube_plus::apply()</a>, <a class="el" href="a00406_source.html#l01437">diskio::load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l01943">diskio::load_ppm_binary()</a>, <a class="el" href="a00406_source.html#l01287">diskio::save_arma_ascii()</a>, <a class="el" href="a00406_source.html#l02062">diskio::save_ppm_binary()</a>, and <a class="el" href="a00406_source.html#l01190">diskio::save_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01019"></a>01019   {
<a name="l01020"></a>01020   <span class="keywordflow">return</span> <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>( <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[in_slice*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + in_col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> + in_row] );
<a name="l01021"></a>01021   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab41c42d70e1802037cff313e11f3d3e6"></a><!-- doxytag: member="Cube::at" ref="gab41c42d70e1802037cff313e11f3d3e6" args="(const u32 in_row, const u32 in_col, const u32 in_slice) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>element accessor; no bounds check </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01029">1029</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, and <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01030"></a>01030   {
<a name="l01031"></a>01031   <span class="keywordflow">return</span> <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[in_slice*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + in_col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> + in_row];
<a name="l01032"></a>01032   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga63f49cd73b0a28cd718820aabcbfc55b"></a><!-- doxytag: member="Cube::operator++" ref="ga63f49cd73b0a28cd718820aabcbfc55b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix ++ </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01040">1040</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01431">Cube_aux::prefix_pp()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01041"></a>01041   {
<a name="l01042"></a>01042   <a class="code" href="a00605.html#gaa0ebb575427635df9dad21d2bd0457f3" title="prefix ++">Cube_aux::prefix_pp</a>(*<span class="keyword">this</span>);
<a name="l01043"></a>01043   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01044"></a>01044   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga08e53f4d13c896de95e1d6d5c187ae55"></a><!-- doxytag: member="Cube::operator++" ref="ga08e53f4d13c896de95e1d6d5c187ae55" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix ++ (must not return the object by reference) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01052">1052</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01459">Cube_aux::postfix_pp()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01053"></a>01053   {
<a name="l01054"></a>01054   <a class="code" href="a00605.html#ga4e73d6e46a8d79e6c6b40607154e7b1b" title="postfix ++">Cube_aux::postfix_pp</a>(*<span class="keyword">this</span>);
<a name="l01055"></a>01055   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8adaf465f35b98b70c02fc3c6407ed28"></a><!-- doxytag: member="Cube::operator&#45;&#45;" ref="ga8adaf465f35b98b70c02fc3c6407ed28" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp; <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix -- </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01063">1063</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01487">Cube_aux::prefix_mm()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01064"></a>01064   {
<a name="l01065"></a>01065   <a class="code" href="a00605.html#ga4d72f270fd218a69d79adecac7e9fc5c" title="prefix --">Cube_aux::prefix_mm</a>(*<span class="keyword">this</span>);
<a name="l01066"></a>01066   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01067"></a>01067   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga85f7e423acb147da1ff5eed3c24eef84"></a><!-- doxytag: member="Cube::operator&#45;&#45;" ref="ga85f7e423acb147da1ff5eed3c24eef84" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix -- (must not return the object by reference) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01075">1075</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01515">Cube_aux::postfix_mm()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01076"></a>01076   {
<a name="l01077"></a>01077   <a class="code" href="a00605.html#gae95e218a4268fbcee637e80b56e1e6f6" title="postfix --">Cube_aux::postfix_mm</a>(*<span class="keyword">this</span>);
<a name="l01078"></a>01078   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf668de01e26c206f524f5161929d01fa"></a><!-- doxytag: member="Cube::is_finite" ref="gaf668de01e26c206f524f5161929d01fa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline bool <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::is_finite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns true if all of the elements are finite </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01086">1086</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00396_source.html#l00025">arma_isfinite()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01087"></a>01087   {
<a name="l01088"></a>01088   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l01089"></a>01089     {
<a name="l01090"></a>01090     <span class="keywordflow">if</span>(<a class="code" href="a00602.html#ga45b15200b888678d0a473de2dfd602fc">arma_isfinite</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) == <span class="keyword">false</span>)
<a name="l01091"></a>01091       {
<a name="l01092"></a>01092       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01093"></a>01093       }
<a name="l01094"></a>01094     }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01097"></a>01097   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1e0aa001a72a50700fc151a655ece615"></a><!-- doxytag: member="Cube::memptr" ref="ga1e0aa001a72a50700fc151a655ece615" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::memptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01105">1105</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>.</p>

<p>Referenced by <a class="el" href="a00428_source.html#l00432">abs()</a>, <a class="el" href="a00545_source.html#l00934">op_atanh::apply()</a>, <a class="el" href="a00545_source.html#l00870">op_tanh::apply()</a>, <a class="el" href="a00545_source.html#l00742">op_atan::apply()</a>, <a class="el" href="a00545_source.html#l00686">op_tan::apply()</a>, <a class="el" href="a00545_source.html#l00621">op_asinh::apply()</a>, <a class="el" href="a00545_source.html#l00558">op_sinh::apply()</a>, <a class="el" href="a00545_source.html#l00430">op_asin::apply()</a>, <a class="el" href="a00545_source.html#l00374">op_sin::apply()</a>, <a class="el" href="a00545_source.html#l00308">op_acosh::apply()</a>, <a class="el" href="a00545_source.html#l00244">op_cosh::apply()</a>, <a class="el" href="a00545_source.html#l00116">op_acos::apply()</a>, <a class="el" href="a00545_source.html#l00060">op_cos::apply()</a>, <a class="el" href="a00533_source.html#l00786">op_scalar_div_post::apply()</a>, <a class="el" href="a00533_source.html#l00500">op_scalar_div_pre::apply()</a>, <a class="el" href="a00533_source.html#l00208">op_scalar_times::apply()</a>, <a class="el" href="a00533_source.html#l00156">op_scalar_minus_post::apply()</a>, <a class="el" href="a00533_source.html#l00104">op_scalar_minus_pre::apply()</a>, <a class="el" href="a00533_source.html#l00052">op_scalar_plus::apply()</a>, <a class="el" href="a00531_source.html#l00082">op_reshape::apply()</a>, <a class="el" href="a00527_source.html#l00100">op_randn::apply()</a>, <a class="el" href="a00525_source.html#l00075">op_rand::apply()</a>, <a class="el" href="a00516_source.html#l00052">op_neg::apply()</a>, <a class="el" href="a00514_source.html#l00684">op_conj::apply()</a>, <a class="el" href="a00514_source.html#l00632">op_pow_s32::apply()</a>, <a class="el" href="a00514_source.html#l00442">op_pow::apply()</a>, <a class="el" href="a00514_source.html#l00337">op_square::apply()</a>, <a class="el" href="a00514_source.html#l00288">op_sqrt::apply()</a>, <a class="el" href="a00514_source.html#l00240">op_trunc_exp::apply()</a>, <a class="el" href="a00514_source.html#l00192">op_exp::apply()</a>, <a class="el" href="a00514_source.html#l00144">op_log10::apply()</a>, <a class="el" href="a00514_source.html#l00096">op_trunc_log::apply()</a>, <a class="el" href="a00514_source.html#l00048">op_log::apply()</a>, <a class="el" href="a00467_source.html#l00154">glue_cube_schur::apply()</a>, <a class="el" href="a00465_source.html#l00156">glue_cube_plus::apply()</a>, <a class="el" href="a00463_source.html#l00156">glue_cube_minus::apply()</a>, <a class="el" href="a00460_source.html#l00154">glue_cube_div::apply()</a>, <a class="el" href="a00467_source.html#l00097">glue_cube_schur::apply_inplace()</a>, <a class="el" href="a00465_source.html#l00098">glue_cube_plus::apply_inplace()</a>, <a class="el" href="a00463_source.html#l00098">glue_cube_minus::apply_inplace()</a>, <a class="el" href="a00460_source.html#l00097">glue_cube_div::apply_inplace()</a>, <a class="el" href="a00401_source.html#l00354">Cube&lt; eT &gt;::Cube()</a>, <a class="el" href="a00576_source.html#l01194">subview_cube&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00412_source.html#l00818">conv_to&lt; Cube&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00428_source.html#l00158">imag()</a>, <a class="el" href="a00401_source.html#l00333">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00406_source.html#l01518">diskio::load_arma_binary()</a>, <a class="el" href="a00556_source.html#l00067">operator!=()</a>, <a class="el" href="a00556_source.html#l00235">operator&lt;()</a>, <a class="el" href="a00556_source.html#l00151">operator&lt;=()</a>, <a class="el" href="a00556_source.html#l00025">operator==()</a>, <a class="el" href="a00556_source.html#l00193">operator&gt;()</a>, <a class="el" href="a00556_source.html#l00109">operator&gt;=()</a>, <a class="el" href="a00576_source.html#l01057">subview_cube&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00401_source.html#l01515">Cube_aux::postfix_mm()</a>, <a class="el" href="a00401_source.html#l01459">Cube_aux::postfix_pp()</a>, <a class="el" href="a00401_source.html#l01487">Cube_aux::prefix_mm()</a>, <a class="el" href="a00401_source.html#l01431">Cube_aux::prefix_pp()</a>, <a class="el" href="a00386_source.html#l00229">arma_ostream::print()</a>, <a class="el" href="a00428_source.html#l00101">real()</a>, and <a class="el" href="a00576_source.html#l01146">subview_cube&lt; eT &gt;::schur_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01106"></a>01106   {
<a name="l01107"></a>01107   <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>eT*<span class="keyword">&gt;</span>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>);
<a name="l01108"></a>01108   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga7909c5331eaa24bf3460a319a62d1096"></a><!-- doxytag: member="Cube::memptr" ref="ga7909c5331eaa24bf3460a319a62d1096" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::memptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01116">1116</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01117"></a>01117   {
<a name="l01118"></a>01118   <span class="keywordflow">return</span> <a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>;
<a name="l01119"></a>01119   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gabb8c874cad5aac59f1877f7525b675de"></a><!-- doxytag: member="Cube::slice_memptr" ref="gabb8c874cad5aac59f1877f7525b675de" args="(const u32 slice)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice_memptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>slice</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the specified slice in the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01127">1127</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l00185">Cube&lt; eT &gt;::create_mat()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01128"></a>01128   {
<a name="l01129"></a>01129   <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>eT*<span class="keyword">&gt;</span>( &amp;<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[ <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> ] );
<a name="l01130"></a>01130   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga552f2287ca08e1b228fd13cece553f25"></a><!-- doxytag: member="Cube::slice_memptr" ref="ga552f2287ca08e1b228fd13cece553f25" args="(const u32 slice) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice_memptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>slice</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the specified slice in the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01138">1138</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, and <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01139"></a>01139   {
<a name="l01140"></a>01140   <span class="keywordflow">return</span> &amp;<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[ <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> ];
<a name="l01141"></a>01141   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8c87a3fbb8c3c9b2ae3d104d3f36d97b"></a><!-- doxytag: member="Cube::slice_colptr" ref="ga8c87a3fbb8c3c9b2ae3d104d3f36d97b" args="(const u32 in_slice, const u32 in_col)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice_colptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the specified slice in the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01149">1149</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, and <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>.</p>

<p>Referenced by <a class="el" href="a00576_source.html#l01194">subview_cube&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00576_source.html#l00980">subview_cube&lt; eT &gt;::extract()</a>, <a class="el" href="a00576_source.html#l01104">subview_cube&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00576_source.html#l01057">subview_cube&lt; eT &gt;::plus_inplace()</a>, and <a class="el" href="a00576_source.html#l01146">subview_cube&lt; eT &gt;::schur_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01150"></a>01150   {
<a name="l01151"></a>01151   <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>eT*<span class="keyword">&gt;</span>( &amp;<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[ <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>] );
<a name="l01152"></a>01152   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga72490b66dbde72a017186ca27572f66f"></a><!-- doxytag: member="Cube::slice_colptr" ref="ga72490b66dbde72a017186ca27572f66f" args="(const u32 in_slice, const u32 in_col) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline const eT * <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::slice_colptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_col</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a pointer to array of eTs used by the specified slice in the cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01160">1160</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00035">Cube&lt; eT &gt;::n_elem_slice</a>, and <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01161"></a>01161   {
<a name="l01162"></a>01162   <span class="keywordflow">return</span> &amp;<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[ <a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>*<a class="code" href="a00031.html#aceb46f96d3e364fb7f645cc39460df61" title="number of elements in each slice (read-only)">n_elem_slice</a> + col*<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> ];
<a name="l01163"></a>01163   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga12c4f14c74e1653b5560acd83264acb0"></a><!-- doxytag: member="Cube::print" ref="ga12c4f14c74e1653b5560acd83264acb0" args="(const std::string extra_text=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::print </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>extra_text</em> = <code>&quot;&quot;</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01174">1174</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01194">Cube&lt; eT &gt;::print()</a>, and <a class="el" href="a00401_source.html#l01215">Cube&lt; eT &gt;::raw_print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01175"></a>01175   {
<a name="l01176"></a>01176   arma_extra_debug_sigprint();
<a name="l01177"></a>01177   
<a name="l01178"></a>01178   <span class="keywordflow">if</span>(extra_text.length() != 0)
<a name="l01179"></a>01179     {
<a name="l01180"></a>01180     cout &lt;&lt; extra_text &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182   
<a name="l01183"></a>01183   <a class="code" href="a00605.html#ga12c4f14c74e1653b5560acd83264acb0" title="print contents of the cube (to the cout stream), optionally preceding with a user...">arma_ostream::print</a>(cout, *<span class="keyword">this</span>, <span class="keyword">true</span>);
<a name="l01184"></a>01184   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4d9c58eb0f9fbdf0397b2235ac094488"></a><!-- doxytag: member="Cube::print" ref="ga4d9c58eb0f9fbdf0397b2235ac094488" args="(std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>extra_text</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values. </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01194">1194</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01174">Cube&lt; eT &gt;::print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01195"></a>01195   {
<a name="l01196"></a>01196   arma_extra_debug_sigprint();
<a name="l01197"></a>01197   
<a name="l01198"></a>01198   <span class="keywordflow">if</span>(extra_text.length() != 0)
<a name="l01199"></a>01199     {
<a name="l01200"></a>01200     user_stream &lt;&lt; extra_text &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202   
<a name="l01203"></a>01203   <a class="code" href="a00605.html#ga12c4f14c74e1653b5560acd83264acb0" title="print contents of the cube (to the cout stream), optionally preceding with a user...">arma_ostream::print</a>(user_stream, *<span class="keyword">this</span>, <span class="keyword">true</span>);
<a name="l01204"></a>01204   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga42abd15133eecb98ebb2510c997631e6"></a><!-- doxytag: member="Cube::raw_print" ref="ga42abd15133eecb98ebb2510c997631e6" args="(const std::string extra_text=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::raw_print </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>extra_text</em> = <code>&quot;&quot;</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>print contents of the cube (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified). </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01215">1215</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01174">Cube&lt; eT &gt;::print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01216"></a>01216   {
<a name="l01217"></a>01217   arma_extra_debug_sigprint();
<a name="l01218"></a>01218   
<a name="l01219"></a>01219   <span class="keywordflow">if</span>(extra_text.length() != 0)
<a name="l01220"></a>01220     {
<a name="l01221"></a>01221     cout &lt;&lt; extra_text &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01222"></a>01222     }
<a name="l01223"></a>01223   
<a name="l01224"></a>01224   <a class="code" href="a00605.html#ga12c4f14c74e1653b5560acd83264acb0" title="print contents of the cube (to the cout stream), optionally preceding with a user...">arma_ostream::print</a>(cout, *<span class="keyword">this</span>, <span class="keyword">false</span>);
<a name="l01225"></a>01225   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad4e83bc50d3f8910b1fc2ce30d5eef73"></a><!-- doxytag: member="Cube::raw_print" ref="gad4e83bc50d3f8910b1fc2ce30d5eef73" args="(std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::raw_print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>user_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>extra_text</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>print contents of the cube to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified). </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01236">1236</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01174">Cube&lt; eT &gt;::print()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01237"></a>01237   {
<a name="l01238"></a>01238   arma_extra_debug_sigprint();
<a name="l01239"></a>01239   
<a name="l01240"></a>01240   <span class="keywordflow">if</span>(extra_text.length() != 0)
<a name="l01241"></a>01241     {
<a name="l01242"></a>01242     user_stream &lt;&lt; extra_text &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244   
<a name="l01245"></a>01245   <a class="code" href="a00605.html#ga12c4f14c74e1653b5560acd83264acb0" title="print contents of the cube (to the cout stream), optionally preceding with a user...">arma_ostream::print</a>(user_stream, *<span class="keyword">this</span>, <span class="keyword">false</span>);
<a name="l01246"></a>01246   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac10bacf38c391e357e110e36b74c8863"></a><!-- doxytag: member="Cube::set_size" ref="gac10bacf38c391e357e110e36b74c8863" args="(const u32 in_rows, const u32 in_cols, const u32 in_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::set_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>change the cube to have user specified dimensions (data is not preserved) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01254">1254</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p>Referenced by <a class="el" href="a00531_source.html#l00082">op_reshape::apply()</a>, <a class="el" href="a00527_source.html#l00100">op_randn::apply()</a>, <a class="el" href="a00525_source.html#l00075">op_rand::apply()</a>, <a class="el" href="a00467_source.html#l00024">glue_cube_schur::apply()</a>, <a class="el" href="a00465_source.html#l00024">glue_cube_plus::apply()</a>, <a class="el" href="a00463_source.html#l00025">glue_cube_minus::apply()</a>, <a class="el" href="a00460_source.html#l00024">glue_cube_div::apply()</a>, <a class="el" href="a00576_source.html#l00980">subview_cube&lt; eT &gt;::extract()</a>, <a class="el" href="a00406_source.html#l01437">diskio::load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l01518">diskio::load_arma_binary()</a>, <a class="el" href="a00406_source.html#l01943">diskio::load_ppm_binary()</a>, <a class="el" href="a00406_source.html#l01399">diskio::load_raw_ascii()</a>, <a class="el" href="a00401_source.html#l01333">Cube&lt; eT &gt;::ones()</a>, and <a class="el" href="a00401_source.html#l01308">Cube&lt; eT &gt;::zeros()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01255"></a>01255   {
<a name="l01256"></a>01256   arma_extra_debug_sigprint();
<a name="l01257"></a>01257   
<a name="l01258"></a>01258   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(in_n_rows, in_n_cols, in_n_slices);
<a name="l01259"></a>01259   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gabec1313f7c0ce9e000d74654392c7c51"></a><!-- doxytag: member="Cube::copy_size" ref="gabec1313f7c0ce9e000d74654392c7c51" args="(const Cube&lt; eT2 &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
<div class="memtemplate">
template&lt;typename eT2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::copy_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>change the cube (without preserving data) to have the same dimensions as the given cube </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01268">1268</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p>Referenced by <a class="el" href="a00545_source.html#l00934">op_atanh::apply()</a>, <a class="el" href="a00545_source.html#l00870">op_tanh::apply()</a>, <a class="el" href="a00545_source.html#l00742">op_atan::apply()</a>, <a class="el" href="a00545_source.html#l00686">op_tan::apply()</a>, <a class="el" href="a00545_source.html#l00621">op_asinh::apply()</a>, <a class="el" href="a00545_source.html#l00558">op_sinh::apply()</a>, <a class="el" href="a00545_source.html#l00430">op_asin::apply()</a>, <a class="el" href="a00545_source.html#l00374">op_sin::apply()</a>, <a class="el" href="a00545_source.html#l00308">op_acosh::apply()</a>, <a class="el" href="a00545_source.html#l00244">op_cosh::apply()</a>, <a class="el" href="a00545_source.html#l00116">op_acos::apply()</a>, <a class="el" href="a00545_source.html#l00060">op_cos::apply()</a>, <a class="el" href="a00533_source.html#l00852">op_scalar_div_post::apply()</a>, <a class="el" href="a00533_source.html#l00566">op_scalar_div_pre::apply()</a>, <a class="el" href="a00533_source.html#l00276">op_scalar_times::apply()</a>, <a class="el" href="a00467_source.html#l00154">glue_cube_schur::apply()</a>, <a class="el" href="a00465_source.html#l00156">glue_cube_plus::apply()</a>, <a class="el" href="a00463_source.html#l00156">glue_cube_minus::apply()</a>, <a class="el" href="a00460_source.html#l00154">glue_cube_div::apply()</a>, and <a class="el" href="a00586_source.html#l00253">unwrap_cube_write&lt; Cube&lt; eT &gt; &gt;::unwrap_cube_write()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01269"></a>01269   {
<a name="l01270"></a>01270   arma_extra_debug_sigprint();
<a name="l01271"></a>01271   
<a name="l01272"></a>01272   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(m.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>, m.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>, m.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>);
<a name="l01273"></a>01273   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4bcefd621084689a02805acfa696cecb"></a><!-- doxytag: member="Cube::fill" ref="ga4bcefd621084689a02805acfa696cecb" args="(const eT val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const eT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fill the cube with the specified value </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01281">1281</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00385_source.html#l00028">access::rw()</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01321">Cube&lt; eT &gt;::ones()</a>, <a class="el" href="a00558_source.html#l00056">operator*()</a>, <a class="el" href="a00553_source.html#l00040">operator/()</a>, and <a class="el" href="a00401_source.html#l01296">Cube&lt; eT &gt;::zeros()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01282"></a>01282   {
<a name="l01283"></a>01283   arma_extra_debug_sigprint();
<a name="l01284"></a>01284   
<a name="l01285"></a>01285   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>; ++i)
<a name="l01286"></a>01286     {
<a name="l01287"></a>01287     <a class="code" href="a00001.html#a477851009a1a1ca4e851fdae0ca84ac0" title="internal function to allow modification of data declared as read-only">access::rw</a>(<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>[i]) = val;
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga14876b8ab1f0681ce0d3af3dfec65c30"></a><!-- doxytag: member="Cube::zeros" ref="ga14876b8ab1f0681ce0d3af3dfec65c30" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::zeros </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l01296">1296</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01281">Cube&lt; eT &gt;::fill()</a>.</p>

<p>Referenced by <a class="el" href="a00549_source.html#l00035">op_zeros::apply()</a>, and <a class="el" href="a00576_source.html#l01104">subview_cube&lt; eT &gt;::minus_inplace()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01297"></a>01297   {
<a name="l01298"></a>01298   arma_extra_debug_sigprint();
<a name="l01299"></a>01299   
<a name="l01300"></a>01300   <a class="code" href="a00605.html#ga4bcefd621084689a02805acfa696cecb" title="fill the cube with the specified value">fill</a>(eT(0));
<a name="l01301"></a>01301   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab451e891732c7bddf9829ca042ce25a7"></a><!-- doxytag: member="Cube::zeros" ref="gab451e891732c7bddf9829ca042ce25a7" args="(const u32 in_rows, const u32 in_cols, const u32 in_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::zeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l01308">1308</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01281">Cube&lt; eT &gt;::fill()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01309"></a>01309   {
<a name="l01310"></a>01310   arma_extra_debug_sigprint( <a class="code" href="a00045.html">arma_boost::format</a>(<span class="stringliteral">&quot;in_rows = %d, in_cols = %d, in_slices = %d&quot;</span>) % in_rows % in_cols % in_slices );
<a name="l01311"></a>01311 
<a name="l01312"></a>01312   <a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(in_rows, in_cols, in_slices);
<a name="l01313"></a>01313   <a class="code" href="a00605.html#ga4bcefd621084689a02805acfa696cecb" title="fill the cube with the specified value">fill</a>(eT(0));
<a name="l01314"></a>01314   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga32914e3bd1cfaebee179d41f382e1159"></a><!-- doxytag: member="Cube::ones" ref="ga32914e3bd1cfaebee179d41f382e1159" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::ones </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l01321">1321</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01281">Cube&lt; eT &gt;::fill()</a>.</p>

<p>Referenced by <a class="el" href="a00518_source.html#l00034">op_ones_full::apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01322"></a>01322   {
<a name="l01323"></a>01323   arma_extra_debug_sigprint();
<a name="l01324"></a>01324   
<a name="l01325"></a>01325   <a class="code" href="a00605.html#ga4bcefd621084689a02805acfa696cecb" title="fill the cube with the specified value">fill</a>(eT(1));
<a name="l01326"></a>01326   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga080bc34e734a22d505e310f070871e40"></a><!-- doxytag: member="Cube::ones" ref="ga080bc34e734a22d505e310f070871e40" args="(const u32 in_rows, const u32 in_cols, const u32 in_slices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::ones </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>in_slices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l01333">1333</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01281">Cube&lt; eT &gt;::fill()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01334"></a>01334   {
<a name="l01335"></a>01335   arma_extra_debug_sigprint( <a class="code" href="a00045.html">arma_boost::format</a>(<span class="stringliteral">&quot;in_rows = %d, in_cols = %d, in_slices = %d&quot;</span>) % in_rows % in_cols % in_slices );
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   <a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(in_rows, in_cols, in_slices);
<a name="l01338"></a>01338   <a class="code" href="a00605.html#ga4bcefd621084689a02805acfa696cecb" title="fill the cube with the specified value">fill</a>(eT(1));
<a name="l01339"></a>01339   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaba9b3dcaf9379fc802c0bdb8b5db4bc9"></a><!-- doxytag: member="Cube::reset" ref="gaba9b3dcaf9379fc802c0bdb8b5db4bc9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l01346">1346</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l00095">Cube&lt; eT &gt;::init()</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l01437">diskio::load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l01518">diskio::load_arma_binary()</a>, <a class="el" href="a00406_source.html#l01575">diskio::load_auto_detect()</a>, and <a class="el" href="a00406_source.html#l01943">diskio::load_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01347"></a>01347   {
<a name="l01348"></a>01348   arma_extra_debug_sigprint();
<a name="l01349"></a>01349   
<a name="l01350"></a>01350   <a class="code" href="a00605.html#ga3d00c0a819c450a9dc7d09abaf95dd83" title="internal cube construction; if the requested size is small enough, memory from the...">init</a>(0,0,0);
<a name="l01351"></a>01351   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9cba3b9de9a7b32c7d7b7c836b306c65"></a><!-- doxytag: member="Cube::save" ref="ga9cba3b9de9a7b32c7d7b7c836b306c65" args="(const std::string name, const file_type type=arma_binary) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>arma_binary</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>save the cube to a file </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01359">1359</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00452_source.html#l00089">arma_ascii</a>, <a class="el" href="a00452_source.html#l00090">arma_binary</a>, <a class="el" href="a00403_source.html#l00640">arma_stop()</a>, <a class="el" href="a00452_source.html#l00092">ppm_binary</a>, <a class="el" href="a00452_source.html#l00088">raw_ascii</a>, <a class="el" href="a00406_source.html#l00509">diskio::save_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00593">diskio::save_arma_binary()</a>, <a class="el" href="a00042.html#af845ebd21d586efa4d5589e8f40ac877">diskio::save_ppm_binary()</a>, and <a class="el" href="a00406_source.html#l00445">diskio::save_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01360"></a>01360   {
<a name="l01361"></a>01361   arma_extra_debug_sigprint();
<a name="l01362"></a>01362   
<a name="l01363"></a>01363   <span class="keywordflow">switch</span>(type)
<a name="l01364"></a>01364     {
<a name="l01365"></a>01365     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>:
<a name="l01366"></a>01366       <a class="code" href="a00608.html#ga6bdf26f1c22b7e62ae83333ba613fcc1" title="Save a matrix as raw text (no header, human readable). Matrices can be loaded in...">diskio::save_raw_ascii</a>(*<span class="keyword">this</span>, name);
<a name="l01367"></a>01367       <span class="keywordflow">break</span>;
<a name="l01368"></a>01368     
<a name="l01369"></a>01369     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>:
<a name="l01370"></a>01370       <a class="code" href="a00608.html#ga00d2191a8f08a1a10926273bb91a766a" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(*<span class="keyword">this</span>, name);
<a name="l01371"></a>01371       <span class="keywordflow">break</span>;
<a name="l01372"></a>01372     
<a name="l01373"></a>01373     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>:
<a name="l01374"></a>01374       <a class="code" href="a00608.html#gaffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(*<span class="keyword">this</span>, name);
<a name="l01375"></a>01375       <span class="keywordflow">break</span>;
<a name="l01376"></a>01376       
<a name="l01377"></a>01377     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" title="Portable Pixel Map (colour image), used by the field class only.">ppm_binary</a>:
<a name="l01378"></a>01378       <a class="code" href="a00042.html#af845ebd21d586efa4d5589e8f40ac877">diskio::save_ppm_binary</a>(*<span class="keyword">this</span>, name);
<a name="l01379"></a>01379       <span class="keywordflow">break</span>;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381     <span class="keywordflow">default</span>:
<a name="l01382"></a>01382       <a class="code" href="a00606.html#ga83f583af567c74f81c35a8011a0ed0e0" title="throw a run-time error exception">arma_stop</a>(<span class="stringliteral">&quot;Cube::save(): unsupported file type&quot;</span>);
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384   
<a name="l01385"></a>01385   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2c92a3f78b5c4b2026739b77e0e5a1a6"></a><!-- doxytag: member="Cube::load" ref="ga2c92a3f78b5c4b2026739b77e0e5a1a6" args="(const std::string name, const file_type type=auto_detect)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00031.html">Cube</a>&lt; eT &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>auto_detect</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>load a cube from a file </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01393">1393</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00452_source.html#l00089">arma_ascii</a>, <a class="el" href="a00452_source.html#l00090">arma_binary</a>, <a class="el" href="a00403_source.html#l00640">arma_stop()</a>, <a class="el" href="a00452_source.html#l00087">auto_detect</a>, <a class="el" href="a00406_source.html#l00828">diskio::load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00905">diskio::load_arma_binary()</a>, <a class="el" href="a00406_source.html#l01131">diskio::load_auto_detect()</a>, <a class="el" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">diskio::load_ppm_binary()</a>, <a class="el" href="a00406_source.html#l00722">diskio::load_raw_ascii()</a>, <a class="el" href="a00452_source.html#l00092">ppm_binary</a>, and <a class="el" href="a00452_source.html#l00088">raw_ascii</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01394"></a>01394   {
<a name="l01395"></a>01395   arma_extra_debug_sigprint();
<a name="l01396"></a>01396   
<a name="l01397"></a>01397   <span class="keywordflow">switch</span>(type)
<a name="l01398"></a>01398     {
<a name="l01399"></a>01399     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41" title="Automatically detect the file type (file must be one of the following types).">auto_detect</a>:
<a name="l01400"></a>01400       <a class="code" href="a00608.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" title="Try to load a matrix by automatically determining its type.">diskio::load_auto_detect</a>(*<span class="keyword">this</span>, name);
<a name="l01401"></a>01401       <span class="keywordflow">break</span>;
<a name="l01402"></a>01402     
<a name="l01403"></a>01403     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>:
<a name="l01404"></a>01404       <a class="code" href="a00608.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">diskio::load_raw_ascii</a>(*<span class="keyword">this</span>, name);
<a name="l01405"></a>01405       <span class="keywordflow">break</span>;
<a name="l01406"></a>01406     
<a name="l01407"></a>01407     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>:
<a name="l01408"></a>01408       <a class="code" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(*<span class="keyword">this</span>, name);
<a name="l01409"></a>01409       <span class="keywordflow">break</span>;
<a name="l01410"></a>01410     
<a name="l01411"></a>01411     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>:
<a name="l01412"></a>01412       <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(*<span class="keyword">this</span>, name);
<a name="l01413"></a>01413       <span class="keywordflow">break</span>;
<a name="l01414"></a>01414       
<a name="l01415"></a>01415     <span class="keywordflow">case</span> <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" title="Portable Pixel Map (colour image), used by the field class only.">ppm_binary</a>:
<a name="l01416"></a>01416       <a class="code" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">diskio::load_ppm_binary</a>(*<span class="keyword">this</span>, name);
<a name="l01417"></a>01417       <span class="keywordflow">break</span>;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419     <span class="keywordflow">default</span>:
<a name="l01420"></a>01420       <a class="code" href="a00606.html#ga83f583af567c74f81c35a8011a0ed0e0" title="throw a run-time error exception">arma_stop</a>(<span class="stringliteral">&quot;Cube::load(): unsupported file type&quot;</span>);
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422   
<a name="l01423"></a>01423   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa0ebb575427635df9dad21d2bd0457f3"></a><!-- doxytag: member="Cube_aux::prefix_pp" ref="gaa0ebb575427635df9dad21d2bd0457f3" args="(Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::prefix_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix ++ </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01431">1431</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01040">Cube&lt; eT &gt;::operator++()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01432"></a>01432   {
<a name="l01433"></a>01433         eT* memptr = x.<a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>();
<a name="l01434"></a>01434   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l01437"></a>01437     {
<a name="l01438"></a>01438     ++(memptr[i]);
<a name="l01439"></a>01439     }
<a name="l01440"></a>01440   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga94cb50acaf1e4360e6325f325ba096bd"></a><!-- doxytag: member="Cube_aux::prefix_pp" ref="ga94cb50acaf1e4360e6325f325ba096bd" args="(Cube&lt; std::complex&lt; T &gt; &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::prefix_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix ++ for complex numbers (work around for limitations of the std::complex class) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01448">1448</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01449"></a>01449   {
<a name="l01450"></a>01450   x += T(1);
<a name="l01451"></a>01451   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4e73d6e46a8d79e6c6b40607154e7b1b"></a><!-- doxytag: member="Cube_aux::postfix_pp" ref="ga4e73d6e46a8d79e6c6b40607154e7b1b" args="(Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::postfix_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix ++ </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01459">1459</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01052">Cube&lt; eT &gt;::operator++()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01460"></a>01460   {
<a name="l01461"></a>01461         eT* memptr = x.<a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>();
<a name="l01462"></a>01462   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>;
<a name="l01463"></a>01463 
<a name="l01464"></a>01464   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l01465"></a>01465     {
<a name="l01466"></a>01466     (memptr[i])++;
<a name="l01467"></a>01467     }
<a name="l01468"></a>01468   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2ff885c12d4c334ae827157ddbed71b0"></a><!-- doxytag: member="Cube_aux::postfix_pp" ref="ga2ff885c12d4c334ae827157ddbed71b0" args="(Cube&lt; std::complex&lt; T &gt; &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::postfix_pp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix ++ for complex numbers (work around for limitations of the std::complex class) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01476">1476</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01477"></a>01477   {
<a name="l01478"></a>01478   x += T(1);
<a name="l01479"></a>01479   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4d72f270fd218a69d79adecac7e9fc5c"></a><!-- doxytag: member="Cube_aux::prefix_mm" ref="ga4d72f270fd218a69d79adecac7e9fc5c" args="(Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::prefix_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix -- </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01487">1487</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01063">Cube&lt; eT &gt;::operator--()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01488"></a>01488   {
<a name="l01489"></a>01489         eT* memptr = x.<a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>();
<a name="l01490"></a>01490   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l01493"></a>01493     {
<a name="l01494"></a>01494     --(memptr[i]);
<a name="l01495"></a>01495     }
<a name="l01496"></a>01496   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab4485a579abb88757b7f8e83805ec2f4"></a><!-- doxytag: member="Cube_aux::prefix_mm" ref="gab4485a579abb88757b7f8e83805ec2f4" args="(Cube&lt; std::complex&lt; T &gt; &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::prefix_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>prefix -- for complex numbers (work around for limitations of the std::complex class) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01504">1504</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01505"></a>01505   {
<a name="l01506"></a>01506   x -= T(1);
<a name="l01507"></a>01507   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae95e218a4268fbcee637e80b56e1e6f6"></a><!-- doxytag: member="Cube_aux::postfix_mm" ref="gae95e218a4268fbcee637e80b56e1e6f6" args="(Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::postfix_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix -- </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01515">1515</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, and <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00401_source.html#l01075">Cube&lt; eT &gt;::operator--()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01516"></a>01516   {
<a name="l01517"></a>01517         eT* memptr = x.<a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>();
<a name="l01518"></a>01518   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l01521"></a>01521     {
<a name="l01522"></a>01522     (memptr[i])--;
<a name="l01523"></a>01523     }
<a name="l01524"></a>01524   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae2e53de87e71bb5b874bfbe95f4e380c"></a><!-- doxytag: member="Cube_aux::postfix_mm" ref="gae2e53de87e71bb5b874bfbe95f4e380c" args="(Cube&lt; std::complex&lt; T &gt; &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline void Cube_aux::postfix_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>postfix ++ for complex numbers (work around for limitations of the std::complex class) </p>

<p>Definition at line <a class="el" href="a00401_source.html#l01532">1532</a> of file <a class="el" href="a00401_source.html">Cube_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01533"></a>01533   {
<a name="l01534"></a>01534   x -= T(1);
<a name="l01535"></a>01535   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
