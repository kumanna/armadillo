<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: diskio Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>diskio Class Reference<br/>
<small>
[<a class="el" href="a00621.html">Diskio</a>]</small>
</h1><!-- doxytag: class="diskio" -->
<p>class for saving and loading matrices and fields  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00419_source.html">diskio_proto.hpp</a>&gt;</code></p>

<p><a href="a00796.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">is_supported_type</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gade8fe65bb50cb3e7bb9129ff4af773ed">load_ppm_binary</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga287ba6a07f728ff3e54db5a1fe8bfd16">save_ppm_binary</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gaa99252a20f066762a161ca8ceb9b2c29">gen_txt_header</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00621.html#gaa99252a20f066762a161ca8ceb9b2c29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gafea81731918e03aedf946fafceda27b5">gen_bin_header</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00621.html#gafea81731918e03aedf946fafceda27b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gacc59f2968b7cc76c746183cb61dcfe04">gen_txt_header</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00621.html#gacc59f2968b7cc76c746183cb61dcfe04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gae12c3543c4168cd7a2fade35eeee82b4">gen_bin_header</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00621.html#gae12c3543c4168cd7a2fade35eeee82b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a> (const <a class="el" href="a00743.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a> (char *out, const <a class="el" href="a00743.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#ga81ac9508b1ee96fd24338a9701aeda71">gen_tmp_name</a> (const std::string &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00648.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00648.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="a00621.html#ga81ac9508b1ee96fd24338a9701aeda71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#ga21a278d6cee27f2800429aadceaff8b1">safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="a00621.html#ga21a278d6cee27f2800429aadceaff8b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga6bdf26f1c22b7e62ae83333ba613fcc1">save_raw_ascii</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="a00621.html#ga6bdf26f1c22b7e62ae83333ba613fcc1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga00d2191a8f08a1a10926273bb91a766a">save_arma_ascii</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00621.html#ga00d2191a8f08a1a10926273bb91a766a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga49a77a6aae221a4ba7e5e882777e0fd9">save_arma_ascii</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00621.html#ga49a77a6aae221a4ba7e5e882777e0fd9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gaffe954d2c7ad14e7d5cc1be747cb2a63">save_arma_binary</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00621.html#gaffe954d2c7ad14e7d5cc1be747cb2a63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gae9f09785dc6a18edd49fc074514fc6c7">save_arma_binary</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00621.html#gae9f09785dc6a18edd49fc074514fc6c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga9fe8365235e562f75bdcf48826dc656a">save_pgm_binary</a> (const <a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00621.html#ga9fe8365235e562f75bdcf48826dc656a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gad88e7d784105a99ba8666b2cc05af0a3">save_pgm_binary</a> (const <a class="el" href="a00176.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00621.html#gad88e7d784105a99ba8666b2cc05af0a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga400632d14748572e5faeecb30e7915c7">load_raw_ascii</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="a00621.html#ga400632d14748572e5faeecb30e7915c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga81f825e8e6474ff560b71cb1e144dbd7">load_arma_ascii</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00621.html#ga81f825e8e6474ff560b71cb1e144dbd7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga4a8295cacc94eb458cfb09703b4f9c25">load_arma_ascii</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00621.html#ga4a8295cacc94eb458cfb09703b4f9c25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga8e0731ede58797f7638eda2a50af240f">load_arma_binary</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="a00621.html#ga8e0731ede58797f7638eda2a50af240f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga72d7772ca9cd9007571c986c2052fefc">load_arma_binary</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga114a20791e59f5a1ad076c0a6153c634">load_pgm_binary</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00621.html#ga114a20791e59f5a1ad076c0a6153c634"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga672f562ded628be461b769c7110264b3">load_pgm_binary</a> (<a class="el" href="a00176.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00621.html#ga672f562ded628be461b769c7110264b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gad236bb1f44446de130054ea0a4b85152">load_pgm_binary</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00621.html#gad236bb1f44446de130054ea0a4b85152"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d">load_auto_detect</a> (<a class="el" href="a00176.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="a00621.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#ga49b5a9c169b0cb638a029af61f922c97">pnm_skip_comments</a> (std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga174fcb65d0726a0b074cb638cf09d6b0">save_raw_ascii</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="a00621.html#ga174fcb65d0726a0b074cb638cf09d6b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga144d1cf32717082303ca3507398f495a">save_arma_ascii</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00621.html#ga144d1cf32717082303ca3507398f495a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gab27bd44f095e1c68e8a52bebd2900802">save_arma_ascii</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00621.html#gab27bd44f095e1c68e8a52bebd2900802"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga26ac154aece92b7be2247de51e1f7d66">save_arma_binary</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="a00621.html#ga26ac154aece92b7be2247de51e1f7d66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gaeb415f13cdadc3c8b35db264a600005e">save_arma_binary</a> (const <a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="a00621.html#gaeb415f13cdadc3c8b35db264a600005e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga35f015b5569d09e69d1562f3c087811e">load_raw_ascii</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="a00621.html#ga35f015b5569d09e69d1562f3c087811e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga8c671488b92ad364dbc2c4cba859f718">load_arma_ascii</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00621.html#ga8c671488b92ad364dbc2c4cba859f718"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gaf0e1e21459b992bef79c0cb714cbbde9">load_arma_ascii</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00621.html#gaf0e1e21459b992bef79c0cb714cbbde9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga089f7fe67d64e445cd716cae5d4aad65">load_arma_binary</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in binary format, with a header that indicates the cube type as well as its dimensions.  <a href="a00621.html#ga089f7fe67d64e445cd716cae5d4aad65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gab91a1e9d8c23aaa07474af24731e3d3d">load_arma_binary</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gae1a42ba07bf3a86e11ab082cb96a45e9">load_auto_detect</a> (<a class="el" href="a00043.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="a00621.html#gae1a42ba07bf3a86e11ab082cb96a45e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga2c60a2f31130b27a3cb1ad020660cc21">save_arma_binary</a> (const <a class="el" href="a00055.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga97df7a8f223054be0b5135ff783ab7d4">load_arma_binary</a> (<a class="el" href="a00055.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#ga83f09e96c16bb21f7185d867c9845efe">save_std_string</a> (const <a class="el" href="a00055.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html#ga6026e50ca294ce23eb2bef6f4e3765e4">load_std_string</a> (<a class="el" href="a00055.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#gac66e6e0cc9f7ef2a6bb1fadab19e90f9">load_auto_detect</a> (<a class="el" href="a00055.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00055.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="a00621.html#gac66e6e0cc9f7ef2a6bb1fadab19e90f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#af845ebd21d586efa4d5589e8f40ac877">save_ppm_binary</a> (const <a class="el" href="a00043.html">Cube</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00054.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary</a> (<a class="el" href="a00043.html">Cube</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga23d4e3f45a86ec0440b4d99450f38b20">save_ppm_binary</a> (const <a class="el" href="a00055.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00621.html#ga589a30dc9494f1b2780682cf78757f0e">load_ppm_binary</a> (<a class="el" href="a00055.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>class for saving and loading matrices and fields </p>

<p>Definition at line <a class="el" href="a00419_source.html#l00021">21</a> of file <a class="el" href="a00419_source.html">diskio_proto.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af845ebd21d586efa4d5589e8f40ac877"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="af845ebd21d586efa4d5589e8f40ac877" args="(const Cube&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="a00420_source.html#l00826">field_aux::save()</a>, and <a class="el" href="a00413_source.html#l01359">Cube&lt; eT &gt;::save()</a>.</p>

</div>
</div>
<a class="anchor" id="af99253ff5b74b240b49de9be42a5569d"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="af99253ff5b74b240b49de9be42a5569d" args="(Cube&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="a00420_source.html#l00850">field_aux::load()</a>, <a class="el" href="a00413_source.html#l01393">Cube&lt; eT &gt;::load()</a>, and <a class="el" href="a00418_source.html#l01575">load_auto_detect()</a>.</p>

</div>
</div>
</div>
</BODY>
</HTML>
