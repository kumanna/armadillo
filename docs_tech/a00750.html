<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Diskio</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Diskio</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">diskio</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class for saving and loading matrices and fields  <a href="a00081.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>, 
<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3">raw_ascii</a>, 
<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c">arma_ascii</a>, 
<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda">pgm_binary</a>, 
<a class="el" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08">ppm_binary</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>file types supported by Armadillo </p>
 <a href="a00750.html#gaaf047b6ce458f7c55fd215920656d128">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaa99252a20f066762a161ca8ceb9b2c29">diskio::gen_txt_header</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gaa99252a20f066762a161ca8ceb9b2c29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gafea81731918e03aedf946fafceda27b5">diskio::gen_bin_header</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gafea81731918e03aedf946fafceda27b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gacc59f2968b7cc76c746183cb61dcfe04">diskio::gen_txt_header</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gacc59f2968b7cc76c746183cb61dcfe04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gae12c3543c4168cd7a2fade35eeee82b4">diskio::gen_bin_header</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gae12c3543c4168cd7a2fade35eeee82b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#gaf1b98a9e26843fbaad5a12d626053023">diskio::conv_to_hex_char</a> (const <a class="el" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#gae1927b3ea8735a7d1e77d89405f592e3">diskio::conv_to_hex</a> (char *out, const <a class="el" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71">diskio::gen_tmp_name</a> (const std::string &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00796.html#gabbba00b92b2a32c3a5cf5cf15cef1ea5" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00796.html#gabbba00b92b2a32c3a5cf5cf15cef1ea5" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="#ga81ac9508b1ee96fd24338a9701aeda71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1">diskio::safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="#ga21a278d6cee27f2800429aadceaff8b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga8a6a29012670b812a16dcfca30312b4b">diskio::save_raw_ascii</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="#ga8a6a29012670b812a16dcfca30312b4b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gabe09de156d009f839e45f33954ce387a">diskio::save_raw_ascii</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="#gabe09de156d009f839e45f33954ce387a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaa8932912b23cef92f20393a203cc9e74">diskio::save_arma_ascii</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#gaa8932912b23cef92f20393a203cc9e74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaa2d6aee91cc9bede8234852af659c4af">diskio::save_arma_ascii</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#gaa2d6aee91cc9bede8234852af659c4af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga405dbdcfcbfe838f75d7be72e37b0e07">diskio::save_arma_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#ga405dbdcfcbfe838f75d7be72e37b0e07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaea6df57b8dfce4a5a854c38c99bc49d0">diskio::save_arma_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gaea6df57b8dfce4a5a854c38c99bc49d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga708f7e84f7aae00a027e7026c5b16292">diskio::save_pgm_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_nname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#ga708f7e84f7aae00a027e7026c5b16292"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga4a103f843e958c4162dd0107ffea5724">diskio::save_pgm_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#ga4a103f843e958c4162dd0107ffea5724"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga8f433ab032357ad0aa454c4fca6d6257">diskio::save_pgm_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#ga8f433ab032357ad0aa454c4fca6d6257"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga639316b7a73d03c62380562ca005d25a">diskio::save_pgm_binary</a> (const <a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#ga639316b7a73d03c62380562ca005d25a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga400632d14748572e5faeecb30e7915c7">diskio::load_raw_ascii</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="#ga400632d14748572e5faeecb30e7915c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaa2e2c93c23b86c1d57444d51fae2042b">diskio::load_raw_ascii</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="#gaa2e2c93c23b86c1d57444d51fae2042b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga81f825e8e6474ff560b71cb1e144dbd7">diskio::load_arma_ascii</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga81f825e8e6474ff560b71cb1e144dbd7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga0b3c538d085fc0cbace61d20e5a08ffe">diskio::load_arma_ascii</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga0b3c538d085fc0cbace61d20e5a08ffe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f">diskio::load_arma_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="#ga8e0731ede58797f7638eda2a50af240f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga45f83986731c0c0f63daa9c7895a2fd2">diskio::load_arma_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a> (std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga114a20791e59f5a1ad076c0a6153c634">diskio::load_pgm_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#ga114a20791e59f5a1ad076c0a6153c634"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gad236bb1f44446de130054ea0a4b85152">diskio::load_pgm_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#gad236bb1f44446de130054ea0a4b85152"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga672f562ded628be461b769c7110264b3">diskio::load_pgm_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#ga672f562ded628be461b769c7110264b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaadd01b28b36aadd1efe3fed7f8f7f5af">diskio::load_pgm_binary</a> (<a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#gaadd01b28b36aadd1efe3fed7f8f7f5af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d">diskio::load_auto_detect</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga2ff4ab7b425bdb0d0d07fdb6a6b7fae6">diskio::load_auto_detect</a> (<a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="#ga2ff4ab7b425bdb0d0d07fdb6a6b7fae6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga174fcb65d0726a0b074cb638cf09d6b0">diskio::save_raw_ascii</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="#ga174fcb65d0726a0b074cb638cf09d6b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga0490dd220114352462b5dab3b321e9f2">diskio::save_raw_ascii</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="#ga0490dd220114352462b5dab3b321e9f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga144d1cf32717082303ca3507398f495a">diskio::save_arma_ascii</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga144d1cf32717082303ca3507398f495a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga49c98268e07839c2def405e6254a141b">diskio::save_arma_ascii</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga49c98268e07839c2def405e6254a141b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga26ac154aece92b7be2247de51e1f7d66">diskio::save_arma_binary</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="#ga26ac154aece92b7be2247de51e1f7d66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaf13c5d05ac5e92956d16777c7d95512c">diskio::save_arma_binary</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="#gaf13c5d05ac5e92956d16777c7d95512c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga35f015b5569d09e69d1562f3c087811e">diskio::load_raw_ascii</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="#ga35f015b5569d09e69d1562f3c087811e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga086967dd6f5fa3e2a0bf9afd044a3480">diskio::load_raw_ascii</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="#ga086967dd6f5fa3e2a0bf9afd044a3480"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga8c671488b92ad364dbc2c4cba859f718">diskio::load_arma_ascii</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga8c671488b92ad364dbc2c4cba859f718"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga13c9a7326ba62eb3b03bb4f4d01a8ba4">diskio::load_arma_ascii</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga13c9a7326ba62eb3b03bb4f4d01a8ba4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga089f7fe67d64e445cd716cae5d4aad65">diskio::load_arma_binary</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in binary format, with a header that indicates the cube type as well as its dimensions.  <a href="#ga089f7fe67d64e445cd716cae5d4aad65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gab839d0c3053d445f6be3577ca3ae7bb7">diskio::load_arma_binary</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gae1a42ba07bf3a86e11ab082cb96a45e9">diskio::load_auto_detect</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="#gae1a42ba07bf3a86e11ab082cb96a45e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga0a05510e718e95647374183d8462df0a">diskio::load_auto_detect</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="#ga0a05510e718e95647374183d8462df0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga2c60a2f31130b27a3cb1ad020660cc21">diskio::save_arma_binary</a> (const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga630d37aeb08fc23a184eb8ec33124bb2">diskio::save_arma_binary</a> (const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga97df7a8f223054be0b5135ff783ab7d4">diskio::load_arma_binary</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaa4fd56fac339537f897a13be9f846a87">diskio::load_arma_binary</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga83f09e96c16bb21f7185d867c9845efe">diskio::save_std_string</a> (const <a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga444dcaee9bc0a3211e55faf808126071">diskio::save_std_string</a> (const <a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga6026e50ca294ce23eb2bef6f4e3765e4">diskio::load_std_string</a> (<a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00750.html#ga88c8465f9470e0b80f0abb1c4ca6ca1f">diskio::load_std_string</a> (<a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gac66e6e0cc9f7ef2a6bb1fadab19e90f9">diskio::load_auto_detect</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00174.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="#gac66e6e0cc9f7ef2a6bb1fadab19e90f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gac311a46b9e74a0c08efee514e70d2832">diskio::load_auto_detect</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00174.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="#gac311a46b9e74a0c08efee514e70d2832"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gade8fe65bb50cb3e7bb9129ff4af773ed">diskio::load_ppm_binary</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gaee968268402aa8ff924b4930d86e79c8">diskio::load_ppm_binary</a> (<a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga287ba6a07f728ff3e54db5a1fe8bfd16">diskio::save_ppm_binary</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#gab538f2fab00fbd59001b2a957994f5a4">diskio::save_ppm_binary</a> (const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga589a30dc9494f1b2780682cf78757f0e">diskio::load_ppm_binary</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga36dd686cde27c25a4cfb2025dfd80620">diskio::load_ppm_binary</a> (<a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga23d4e3f45a86ec0440b4d99450f38b20">diskio::save_ppm_binary</a> (const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00750.html#ga95b13bdcabd10a5e72270d52d134cc76">diskio::save_ppm_binary</a> (const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::ostream &amp;f)</td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaaf047b6ce458f7c55fd215920656d128"></a><!-- doxytag: member="forward_proto.hpp::file_type" ref="gaaf047b6ce458f7c55fd215920656d128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00750.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>file types supported by Armadillo </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41"></a><!-- doxytag: member="auto_detect" ref="ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41" args="" -->auto_detect</em>&nbsp;</td><td>
<p>Automatically detect the file type (file must be one of the following types). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3"></a><!-- doxytag: member="raw_ascii" ref="ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" args="" -->raw_ascii</em>&nbsp;</td><td>
<p>ASCII format (text), without any other information. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c"></a><!-- doxytag: member="arma_ascii" ref="ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" args="" -->arma_ascii</em>&nbsp;</td><td>
<p>Armadillo ASCII format (text), with information about matrix type and size. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6"></a><!-- doxytag: member="arma_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" args="" -->arma_binary</em>&nbsp;</td><td>
<p>Armadillo binary format. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda"></a><!-- doxytag: member="pgm_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda" args="" -->pgm_binary</em>&nbsp;</td><td>
<p>Portable Grey Map (greyscale image). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08"></a><!-- doxytag: member="ppm_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" args="" -->ppm_binary</em>&nbsp;</td><td>
<p>Portable Pixel Map (colour image), used by the <a class="el" href="a00174.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> and cube classes. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00609_source.html#l00076">76</a> of file <a class="el" href="a00609_source.html">forward_proto.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00077"></a>00077   {
<a name="l00078"></a>00078   <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41" title="Automatically detect the file type (file must be one of the following types).">auto_detect</a>,  <span class="comment">//!&lt; Automatically detect the file type (file must be one of the following types)</span>
<a name="l00079"></a>00079 <span class="comment"></span>  <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>,    <span class="comment">//!&lt; ASCII format (text), without any other information.</span>
<a name="l00080"></a>00080 <span class="comment"></span>  <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>,   <span class="comment">//!&lt; Armadillo ASCII format (text), with information about matrix type and size</span>
<a name="l00081"></a>00081 <span class="comment"></span>  <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>,  <span class="comment">//!&lt; Armadillo binary format</span>
<a name="l00082"></a>00082 <span class="comment"></span>  <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda" title="Portable Grey Map (greyscale image).">pgm_binary</a>,   <span class="comment">//!&lt; Portable Grey Map (greyscale image)</span>
<a name="l00083"></a>00083 <span class="comment"></span>  <a class="code" href="a00750.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" title="Portable Pixel Map (colour image), used by the field and cube classes.">ppm_binary</a>    <span class="comment">//!&lt; Portable Pixel Map (colour image), used by the field and cube classes</span>
<a name="l00084"></a>00084 <span class="comment"></span>  };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa99252a20f066762a161ca8ceb9b2c29"></a><!-- doxytag: member="diskio::gen_txt_header" ref="gaa99252a20f066762a161ca8ceb9b2c29" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00030">30</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00901">load_arma_ascii()</a>, and <a class="el" href="a00535_source.html#l00560">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031   {
<a name="l00032"></a>00032   <a class="code" href="a00043.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00033"></a>00033 
<a name="l00034"></a>00034   <span class="keywordflow">if</span>(<a class="code" href="a00284.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00035"></a>00035     {
<a name="l00036"></a>00036     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU001&quot;</span>);
<a name="l00037"></a>00037     }
<a name="l00038"></a>00038   <span class="keywordflow">else</span>
<a name="l00039"></a>00039   <span class="keywordflow">if</span>(<a class="code" href="a00262.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00040"></a>00040     {
<a name="l00041"></a>00041     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS001&quot;</span>);
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043   <span class="keywordflow">else</span>
<a name="l00044"></a>00044   <span class="keywordflow">if</span>(<a class="code" href="a00280.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00045"></a>00045     {
<a name="l00046"></a>00046     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU002&quot;</span>);
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048   <span class="keywordflow">else</span>
<a name="l00049"></a>00049   <span class="keywordflow">if</span>(<a class="code" href="a00258.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00050"></a>00050     {
<a name="l00051"></a>00051     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS002&quot;</span>);
<a name="l00052"></a>00052     }
<a name="l00053"></a>00053   <span class="keywordflow">else</span>
<a name="l00054"></a>00054   <span class="keywordflow">if</span>(<a class="code" href="a00282.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00055"></a>00055     {
<a name="l00056"></a>00056     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU004&quot;</span>);
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058   <span class="keywordflow">else</span>
<a name="l00059"></a>00059   <span class="keywordflow">if</span>(<a class="code" href="a00260.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS004&quot;</span>);
<a name="l00062"></a>00062     }
<a name="l00063"></a>00063   <span class="keywordflow">else</span>
<a name="l00064"></a>00064   <span class="keywordflow">if</span>(<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00065"></a>00065     {
<a name="l00066"></a>00066     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FN004&quot;</span>);
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068   <span class="keywordflow">else</span>
<a name="l00069"></a>00069   <span class="keywordflow">if</span>(<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00070"></a>00070     {
<a name="l00071"></a>00071     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FN008&quot;</span>);
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073   <span class="keywordflow">else</span>
<a name="l00074"></a>00074   <span class="keywordflow">if</span>(<a class="code" href="a00212.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FC008&quot;</span>);
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078   <span class="keywordflow">else</span>
<a name="l00079"></a>00079   <span class="keywordflow">if</span>(<a class="code" href="a00210.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00080"></a>00080     {
<a name="l00081"></a>00081     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FC016&quot;</span>);
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083   <span class="keywordflow">else</span>
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085     <span class="keywordflow">return</span> std::string();
<a name="l00086"></a>00086     }
<a name="l00087"></a>00087   
<a name="l00088"></a>00088   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafea81731918e03aedf946fafceda27b5"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gafea81731918e03aedf946fafceda27b5" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00100">100</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00976">load_arma_binary()</a>, and <a class="el" href="a00535_source.html#l00644">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00101"></a>00101   {
<a name="l00102"></a>00102   <a class="code" href="a00043.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00103"></a>00103   
<a name="l00104"></a>00104   <span class="keywordflow">if</span>(<a class="code" href="a00284.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00105"></a>00105     {
<a name="l00106"></a>00106     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU001&quot;</span>);
<a name="l00107"></a>00107     }
<a name="l00108"></a>00108   <span class="keywordflow">else</span>
<a name="l00109"></a>00109   <span class="keywordflow">if</span>(<a class="code" href="a00262.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00110"></a>00110     {
<a name="l00111"></a>00111     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS001&quot;</span>);
<a name="l00112"></a>00112     }
<a name="l00113"></a>00113   <span class="keywordflow">else</span>
<a name="l00114"></a>00114   <span class="keywordflow">if</span>(<a class="code" href="a00280.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00115"></a>00115     {
<a name="l00116"></a>00116     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU002&quot;</span>);
<a name="l00117"></a>00117     }
<a name="l00118"></a>00118   <span class="keywordflow">else</span>
<a name="l00119"></a>00119   <span class="keywordflow">if</span>(<a class="code" href="a00258.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00120"></a>00120     {
<a name="l00121"></a>00121     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS002&quot;</span>);
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123   <span class="keywordflow">else</span>
<a name="l00124"></a>00124   <span class="keywordflow">if</span>(<a class="code" href="a00282.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00125"></a>00125     {
<a name="l00126"></a>00126     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU004&quot;</span>);
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128   <span class="keywordflow">else</span>
<a name="l00129"></a>00129   <span class="keywordflow">if</span>(<a class="code" href="a00260.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS004&quot;</span>);
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133   <span class="keywordflow">else</span>
<a name="l00134"></a>00134   <span class="keywordflow">if</span>(<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00135"></a>00135     {
<a name="l00136"></a>00136     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FN004&quot;</span>);
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138   <span class="keywordflow">else</span>
<a name="l00139"></a>00139   <span class="keywordflow">if</span>(<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00140"></a>00140     {
<a name="l00141"></a>00141     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FN008&quot;</span>);
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143   <span class="keywordflow">else</span>
<a name="l00144"></a>00144   <span class="keywordflow">if</span>(<a class="code" href="a00212.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00145"></a>00145     {
<a name="l00146"></a>00146     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FC008&quot;</span>);
<a name="l00147"></a>00147     }
<a name="l00148"></a>00148   <span class="keywordflow">else</span>
<a name="l00149"></a>00149   <span class="keywordflow">if</span>(<a class="code" href="a00210.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FC016&quot;</span>);
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153   <span class="keywordflow">else</span>
<a name="l00154"></a>00154     {
<a name="l00155"></a>00155     <span class="keywordflow">return</span> std::string();
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157   
<a name="l00158"></a>00158   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gacc59f2968b7cc76c746183cb61dcfe04"></a><!-- doxytag: member="diskio::gen_txt_header" ref="gacc59f2968b7cc76c746183cb61dcfe04" args="(const Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00170">170</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00171"></a>00171   {
<a name="l00172"></a>00172   <a class="code" href="a00043.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00173"></a>00173 
<a name="l00174"></a>00174   <span class="keywordflow">if</span>(<a class="code" href="a00284.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00175"></a>00175     {
<a name="l00176"></a>00176     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU001&quot;</span>);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178   <span class="keywordflow">else</span>
<a name="l00179"></a>00179   <span class="keywordflow">if</span>(<a class="code" href="a00262.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS001&quot;</span>);
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183   <span class="keywordflow">else</span>
<a name="l00184"></a>00184   <span class="keywordflow">if</span>(<a class="code" href="a00280.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00185"></a>00185     {
<a name="l00186"></a>00186     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU002&quot;</span>);
<a name="l00187"></a>00187     }
<a name="l00188"></a>00188   <span class="keywordflow">else</span>
<a name="l00189"></a>00189   <span class="keywordflow">if</span>(<a class="code" href="a00258.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS002&quot;</span>);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193   <span class="keywordflow">else</span>
<a name="l00194"></a>00194   <span class="keywordflow">if</span>(<a class="code" href="a00282.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU004&quot;</span>);
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198   <span class="keywordflow">else</span>
<a name="l00199"></a>00199   <span class="keywordflow">if</span>(<a class="code" href="a00260.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS004&quot;</span>);
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203   <span class="keywordflow">else</span>
<a name="l00204"></a>00204   <span class="keywordflow">if</span>(<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00205"></a>00205     {
<a name="l00206"></a>00206     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FN004&quot;</span>);
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208   <span class="keywordflow">else</span>
<a name="l00209"></a>00209   <span class="keywordflow">if</span>(<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00210"></a>00210     {
<a name="l00211"></a>00211     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FN008&quot;</span>);
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213   <span class="keywordflow">else</span>
<a name="l00214"></a>00214   <span class="keywordflow">if</span>(<a class="code" href="a00212.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00215"></a>00215     {
<a name="l00216"></a>00216     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FC008&quot;</span>);
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218   <span class="keywordflow">else</span>
<a name="l00219"></a>00219   <span class="keywordflow">if</span>(<a class="code" href="a00210.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00220"></a>00220     {
<a name="l00221"></a>00221     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FC016&quot;</span>);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223   <span class="keywordflow">else</span>
<a name="l00224"></a>00224     {
<a name="l00225"></a>00225     <span class="keywordflow">return</span> std::string();
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227   
<a name="l00228"></a>00228   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae12c3543c4168cd7a2fade35eeee82b4"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gae12c3543c4168cd7a2fade35eeee82b4" args="(const Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00240">240</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00241"></a>00241   {
<a name="l00242"></a>00242   <a class="code" href="a00043.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00243"></a>00243   
<a name="l00244"></a>00244   <span class="keywordflow">if</span>(<a class="code" href="a00284.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU001&quot;</span>);
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248   <span class="keywordflow">else</span>
<a name="l00249"></a>00249   <span class="keywordflow">if</span>(<a class="code" href="a00262.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00250"></a>00250     {
<a name="l00251"></a>00251     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS001&quot;</span>);
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253   <span class="keywordflow">else</span>
<a name="l00254"></a>00254   <span class="keywordflow">if</span>(<a class="code" href="a00280.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00255"></a>00255     {
<a name="l00256"></a>00256     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU002&quot;</span>);
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258   <span class="keywordflow">else</span>
<a name="l00259"></a>00259   <span class="keywordflow">if</span>(<a class="code" href="a00258.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS002&quot;</span>);
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263   <span class="keywordflow">else</span>
<a name="l00264"></a>00264   <span class="keywordflow">if</span>(<a class="code" href="a00282.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU004&quot;</span>);
<a name="l00267"></a>00267     }
<a name="l00268"></a>00268   <span class="keywordflow">else</span>
<a name="l00269"></a>00269   <span class="keywordflow">if</span>(<a class="code" href="a00260.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00270"></a>00270     {
<a name="l00271"></a>00271     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS004&quot;</span>);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273   <span class="keywordflow">else</span>
<a name="l00274"></a>00274   <span class="keywordflow">if</span>(<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00275"></a>00275     {
<a name="l00276"></a>00276     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FN004&quot;</span>);
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278   <span class="keywordflow">else</span>
<a name="l00279"></a>00279   <span class="keywordflow">if</span>(<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00280"></a>00280     {
<a name="l00281"></a>00281     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FN008&quot;</span>);
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283   <span class="keywordflow">else</span>
<a name="l00284"></a>00284   <span class="keywordflow">if</span>(<a class="code" href="a00212.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00285"></a>00285     {
<a name="l00286"></a>00286     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FC008&quot;</span>);
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288   <span class="keywordflow">else</span>
<a name="l00289"></a>00289   <span class="keywordflow">if</span>(<a class="code" href="a00210.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FC016&quot;</span>);
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293   <span class="keywordflow">else</span>
<a name="l00294"></a>00294     {
<a name="l00295"></a>00295     <span class="keywordflow">return</span> std::string();
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297   
<a name="l00298"></a>00298   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf1b98a9e26843fbaad5a12d626053023"></a><!-- doxytag: member="diskio::conv_to_hex_char" ref="gaf1b98a9e26843fbaad5a12d626053023" args="(const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char diskio::conv_to_hex_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l00304">304</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00336">conv_to_hex()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00305"></a>00305   {
<a name="l00306"></a>00306   <span class="keywordtype">char</span> out;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">switch</span>(x)
<a name="l00309"></a>00309     {
<a name="l00310"></a>00310     <span class="keywordflow">case</span>  0: out = <span class="charliteral">&apos;0&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00311"></a>00311     <span class="keywordflow">case</span>  1: out = <span class="charliteral">&apos;1&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00312"></a>00312     <span class="keywordflow">case</span>  2: out = <span class="charliteral">&apos;2&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00313"></a>00313     <span class="keywordflow">case</span>  3: out = <span class="charliteral">&apos;3&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00314"></a>00314     <span class="keywordflow">case</span>  4: out = <span class="charliteral">&apos;4&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00315"></a>00315     <span class="keywordflow">case</span>  5: out = <span class="charliteral">&apos;5&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00316"></a>00316     <span class="keywordflow">case</span>  6: out = <span class="charliteral">&apos;6&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00317"></a>00317     <span class="keywordflow">case</span>  7: out = <span class="charliteral">&apos;7&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00318"></a>00318     <span class="keywordflow">case</span>  8: out = <span class="charliteral">&apos;8&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00319"></a>00319     <span class="keywordflow">case</span>  9: out = <span class="charliteral">&apos;9&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00320"></a>00320     <span class="keywordflow">case</span> 10: out = <span class="charliteral">&apos;a&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00321"></a>00321     <span class="keywordflow">case</span> 11: out = <span class="charliteral">&apos;b&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00322"></a>00322     <span class="keywordflow">case</span> 12: out = <span class="charliteral">&apos;c&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00323"></a>00323     <span class="keywordflow">case</span> 13: out = <span class="charliteral">&apos;d&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00324"></a>00324     <span class="keywordflow">case</span> 14: out = <span class="charliteral">&apos;e&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00325"></a>00325     <span class="keywordflow">case</span> 15: out = <span class="charliteral">&apos;f&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00326"></a>00326     <span class="keywordflow">default</span>: out = <span class="charliteral">&apos;-&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="keywordflow">return</span> out;  
<a name="l00330"></a>00330   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae1927b3ea8735a7d1e77d89405f592e3"></a><!-- doxytag: member="diskio::conv_to_hex" ref="gae1927b3ea8735a7d1e77d89405f592e3" args="(char *out, const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::conv_to_hex </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l00336">336</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00304">conv_to_hex_char()</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00337"></a>00337   {
<a name="l00338"></a>00338   <span class="keyword">const</span> <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> a = x / 16;
<a name="l00339"></a>00339   <span class="keyword">const</span> <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> b = x - 16*a;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   out[0] = <a class="code" href="a00750.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(a);
<a name="l00342"></a>00342   out[1] = <a class="code" href="a00750.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(b);
<a name="l00343"></a>00343   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga81ac9508b1ee96fd24338a9701aeda71"></a><!-- doxytag: member="diskio::gen_tmp_name" ref="ga81ac9508b1ee96fd24338a9701aeda71" args="(const std::string &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_tmp_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a quasi-random string to the given filename. The <a class="el" href="a00796.html#gabbba00b92b2a32c3a5cf5cf15cef1ea5" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00796.html#gabbba00b92b2a32c3a5cf5cf15cef1ea5" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00356">356</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00336">conv_to_hex()</a>, and <a class="el" href="a00601_source.html#l00032">sum()</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00523">save_arma_ascii()</a>, <a class="el" href="a00535_source.html#l00607">save_arma_binary()</a>, <a class="el" href="a00535_source.html#l00660">save_pgm_binary()</a>, <a class="el" href="a00535_source.html#l02248">save_ppm_binary()</a>, <a class="el" href="a00535_source.html#l00447">save_raw_ascii()</a>, and <a class="el" href="a00535_source.html#l01887">save_std_string()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00357"></a>00357   {
<a name="l00358"></a>00358   <span class="keyword">const</span> std::string* ptr_x     = &amp;x;
<a name="l00359"></a>00359   <span class="keyword">const</span> <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*          ptr_ptr_x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*<span class="keyword">&gt;</span>(&amp;ptr_x);
<a name="l00360"></a>00360   
<a name="l00361"></a>00361   <span class="keyword">const</span> <span class="keywordtype">char</span>* extra      = <span class="stringliteral">&quot;.tmp_&quot;</span>;
<a name="l00362"></a>00362   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   extra_size = 5;
<a name="l00363"></a>00363   
<a name="l00364"></a>00364   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   tmp_size   = 2*<span class="keyword">sizeof</span>(<a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*) + 2*2;
<a name="l00365"></a>00365         <span class="keywordtype">char</span>  tmp[tmp_size];
<a name="l00366"></a>00366   
<a name="l00367"></a>00367   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> char_count = 0;
<a name="l00368"></a>00368   
<a name="l00369"></a>00369   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<span class="keyword">sizeof</span>(<a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*); ++i)
<a name="l00370"></a>00370     {
<a name="l00371"></a>00371     <a class="code" href="a00750.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], ptr_ptr_x[i]);
<a name="l00372"></a>00372     char_count += 2;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374   
<a name="l00375"></a>00375   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> x_size = x.size();
<a name="l00376"></a>00376   <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> <a class="code" href="a00806.html#ga294778a7cda1288c1d01572b5eb0f081" title="Delayed sum of elements of a matrix along a specified dimension (either rows or columns)...">sum</a> = 0;
<a name="l00377"></a>00377   
<a name="l00378"></a>00378   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00379"></a>00379     {
<a name="l00380"></a>00380     sum += <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x[i]);
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382   
<a name="l00383"></a>00383   <a class="code" href="a00750.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], sum);
<a name="l00384"></a>00384   char_count += 2;
<a name="l00385"></a>00385   
<a name="l00386"></a>00386   <a class="code" href="a00750.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x_size));
<a name="l00387"></a>00387   
<a name="l00388"></a>00388   
<a name="l00389"></a>00389   std::string out;
<a name="l00390"></a>00390   out.resize(x_size + extra_size + tmp_size);
<a name="l00391"></a>00391   
<a name="l00392"></a>00392   
<a name="l00393"></a>00393   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395     out[i] = x[i];
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397   
<a name="l00398"></a>00398   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;extra_size; ++i)
<a name="l00399"></a>00399     {
<a name="l00400"></a>00400     out[x_size + i] = extra[i];
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402   
<a name="l00403"></a>00403   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;tmp_size; ++i)
<a name="l00404"></a>00404     {
<a name="l00405"></a>00405     out[x_size + extra_size + i] = tmp[i];
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407   
<a name="l00408"></a>00408   <span class="keywordflow">return</span> out;
<a name="l00409"></a>00409   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga21a278d6cee27f2800429aadceaff8b1"></a><!-- doxytag: member="diskio::safe_rename" ref="ga21a278d6cee27f2800429aadceaff8b1" args="(const std::string &amp;old_name, const std::string &amp;new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::safe_rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>new_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00420">420</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l00523">save_arma_ascii()</a>, <a class="el" href="a00535_source.html#l00607">save_arma_binary()</a>, <a class="el" href="a00535_source.html#l00660">save_pgm_binary()</a>, <a class="el" href="a00535_source.html#l02248">save_ppm_binary()</a>, <a class="el" href="a00535_source.html#l00447">save_raw_ascii()</a>, and <a class="el" href="a00535_source.html#l01887">save_std_string()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00421"></a>00421   {
<a name="l00422"></a>00422   std::fstream f(new_name.c_str(), std::fstream::out | std::fstream::app);
<a name="l00423"></a>00423   f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00424"></a>00424   
<a name="l00425"></a>00425   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00426"></a>00426   f.close();
<a name="l00427"></a>00427   
<a name="l00428"></a>00428   <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, new_name );
<a name="l00429"></a>00429   
<a name="l00430"></a>00430   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00431"></a>00431     {
<a name="l00432"></a>00432     std::remove(new_name.c_str());
<a name="l00433"></a>00433     
<a name="l00434"></a>00434     <span class="keyword">const</span> <span class="keywordtype">int</span> mv_result = std::rename(old_name.c_str(), new_name.c_str());
<a name="l00435"></a>00435     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( (mv_result != 0), <span class="stringliteral">&quot;trouble writing &quot;</span>, new_name );
<a name="l00436"></a>00436     }
<a name="l00437"></a>00437   
<a name="l00438"></a>00438   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8a6a29012670b812a16dcfca30312b4b"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="ga8a6a29012670b812a16dcfca30312b4b" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00447">447</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, and <a class="el" href="a00535_source.html#l00420">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02384">Mat&lt; eT &gt;::save()</a>, <a class="el" href="a00529_source.html#l01727">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00535_source.html#l01271">save_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00448"></a>00448   {
<a name="l00449"></a>00449   arma_extra_debug_sigprint();
<a name="l00450"></a>00450   
<a name="l00451"></a>00451   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00452"></a>00452   
<a name="l00453"></a>00453   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l00454"></a>00454   
<a name="l00455"></a>00455   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00456"></a>00456     {
<a name="l00457"></a>00457     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00458"></a>00458     }
<a name="l00459"></a>00459   <span class="keywordflow">else</span>
<a name="l00460"></a>00460     {
<a name="l00461"></a>00461     <a class="code" href="a00750.html#ga8a6a29012670b812a16dcfca30312b4b" title="Save a matrix as raw text (no header, human readable). Matrices can be loaded in...">diskio::save_raw_ascii</a>(x, tmp_name, f);
<a name="l00462"></a>00462     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00463"></a>00463     
<a name="l00464"></a>00464     f.flush();
<a name="l00465"></a>00465     f.close();
<a name="l00466"></a>00466     
<a name="l00467"></a>00467     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name);
<a name="l00468"></a>00468     
<a name="l00469"></a>00469     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00470"></a>00470       {
<a name="l00471"></a>00471       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00472"></a>00472       }
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gabe09de156d009f839e45f33954ce387a"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="gabe09de156d009f839e45f33954ce387a" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00483">483</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00484"></a>00484   {
<a name="l00485"></a>00485   arma_extra_debug_sigprint();
<a name="l00486"></a>00486   
<a name="l00487"></a>00487   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00488"></a>00488   
<a name="l00489"></a>00489   <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00490"></a>00490   
<a name="l00491"></a>00491   <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00492"></a>00492     {
<a name="l00493"></a>00493     f.setf(ios::scientific);
<a name="l00494"></a>00494     f.precision(8);
<a name="l00495"></a>00495     cell_width = 16;
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497   
<a name="l00498"></a>00498   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00499"></a>00499     {
<a name="l00500"></a>00500     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00501"></a>00501       {
<a name="l00502"></a>00502       f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00503"></a>00503       
<a name="l00504"></a>00504       <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00505"></a>00505         {
<a name="l00506"></a>00506         f.width(cell_width);
<a name="l00507"></a>00507         }
<a name="l00508"></a>00508       
<a name="l00509"></a>00509       f &lt;&lt; x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00510"></a>00510       }
<a name="l00511"></a>00511       
<a name="l00512"></a>00512     f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa8932912b23cef92f20393a203cc9e74"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="gaa8932912b23cef92f20393a203cc9e74" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00523">523</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, and <a class="el" href="a00535_source.html#l00420">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02384">Mat&lt; eT &gt;::save()</a>, <a class="el" href="a00529_source.html#l01727">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00535_source.html#l01350">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00524"></a>00524   {
<a name="l00525"></a>00525   arma_extra_debug_sigprint();
<a name="l00526"></a>00526   
<a name="l00527"></a>00527   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00528"></a>00528   
<a name="l00529"></a>00529   std::ofstream f(tmp_name.c_str());
<a name="l00530"></a>00530   
<a name="l00531"></a>00531   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00532"></a>00532     {
<a name="l00533"></a>00533     arma_debug_print(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535   <span class="keywordflow">else</span>
<a name="l00536"></a>00536     {
<a name="l00537"></a>00537     <a class="code" href="a00750.html#gaa8932912b23cef92f20393a203cc9e74" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l00538"></a>00538     
<a name="l00539"></a>00539     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00540"></a>00540     
<a name="l00541"></a>00541     f.flush();
<a name="l00542"></a>00542     f.close();
<a name="l00543"></a>00543     
<a name="l00544"></a>00544     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00545"></a>00545     
<a name="l00546"></a>00546     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00547"></a>00547       {
<a name="l00548"></a>00548       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00549"></a>00549       }
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa2d6aee91cc9bede8234852af659c4af"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="gaa2d6aee91cc9bede8234852af659c4af" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00560">560</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00535_source.html#l00030">gen_txt_header()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00561"></a>00561   {
<a name="l00562"></a>00562   arma_extra_debug_sigprint();
<a name="l00563"></a>00563   
<a name="l00564"></a>00564   <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l00565"></a>00565   
<a name="l00566"></a>00566   f &lt;&lt; <a class="code" href="a00750.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00567"></a>00567   f &lt;&lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00568"></a>00568   
<a name="l00569"></a>00569   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00570"></a>00570   
<a name="l00571"></a>00571   <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00572"></a>00572   
<a name="l00573"></a>00573   <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00574"></a>00574     {
<a name="l00575"></a>00575     f.setf(ios::scientific);
<a name="l00576"></a>00576     f.precision(8);
<a name="l00577"></a>00577     cell_width = 16;
<a name="l00578"></a>00578     }
<a name="l00579"></a>00579     
<a name="l00580"></a>00580   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00581"></a>00581     {
<a name="l00582"></a>00582     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00583"></a>00583       {
<a name="l00584"></a>00584       f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00585"></a>00585       
<a name="l00586"></a>00586       <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l00587"></a>00587         {
<a name="l00588"></a>00588         f.width(cell_width);
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590       
<a name="l00591"></a>00591       f &lt;&lt; x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00592"></a>00592       }
<a name="l00593"></a>00593     
<a name="l00594"></a>00594     f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596   
<a name="l00597"></a>00597   f.flags(orig_flags);
<a name="l00598"></a>00598   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga405dbdcfcbfe838f75d7be72e37b0e07"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga405dbdcfcbfe838f75d7be72e37b0e07" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00607">607</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, and <a class="el" href="a00535_source.html#l00420">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02384">Mat&lt; eT &gt;::save()</a>, <a class="el" href="a00556_source.html#l01110">field_aux::save()</a>, <a class="el" href="a00529_source.html#l01727">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00535_source.html#l01437">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00608"></a>00608   {
<a name="l00609"></a>00609   arma_extra_debug_sigprint();
<a name="l00610"></a>00610   
<a name="l00611"></a>00611   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00612"></a>00612   
<a name="l00613"></a>00613   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l00614"></a>00614   
<a name="l00615"></a>00615   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00616"></a>00616     {
<a name="l00617"></a>00617     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00618"></a>00618     }
<a name="l00619"></a>00619   <span class="keywordflow">else</span>
<a name="l00620"></a>00620     {  
<a name="l00621"></a>00621     <a class="code" href="a00750.html#ga405dbdcfcbfe838f75d7be72e37b0e07" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l00622"></a>00622     
<a name="l00623"></a>00623     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00624"></a>00624     
<a name="l00625"></a>00625     f.flush();
<a name="l00626"></a>00626     f.close();
<a name="l00627"></a>00627     
<a name="l00628"></a>00628     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00629"></a>00629     
<a name="l00630"></a>00630     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00631"></a>00631       {
<a name="l00632"></a>00632       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00633"></a>00633       }
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaea6df57b8dfce4a5a854c38c99bc49d0"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gaea6df57b8dfce4a5a854c38c99bc49d0" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00644">644</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00100">gen_bin_header()</a>, <a class="el" href="a00633_source.html#l00035">Mat&lt; eT &gt;::mem</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00645"></a>00645   {
<a name="l00646"></a>00646   arma_extra_debug_sigprint();
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   f &lt;&lt; <a class="code" href="a00750.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00649"></a>00649   f &lt;&lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00650"></a>00650   
<a name="l00651"></a>00651   f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="a00308.html#a14a6badc8098d810e5decb22272a07b0" title="pointer to the memory used by the matrix (memory is read-only)">mem</a>), x.<a class="code" href="a00308.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00652"></a>00652   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga708f7e84f7aae00a027e7026c5b16292"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="ga708f7e84f7aae00a027e7026c5b16292" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;final_nname)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_nname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00660">660</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, and <a class="el" href="a00535_source.html#l00420">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02384">Mat&lt; eT &gt;::save()</a>, and <a class="el" href="a00535_source.html#l00732">save_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00661"></a>00661   {
<a name="l00662"></a>00662   arma_extra_debug_sigprint();
<a name="l00663"></a>00663   
<a name="l00664"></a>00664   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00665"></a>00665   
<a name="l00666"></a>00666   std::fstream f(tmp_name.c_str(), std::fstream::out | std::fstream::binary);
<a name="l00667"></a>00667   
<a name="l00668"></a>00668   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00669"></a>00669     {
<a name="l00670"></a>00670     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672   <span class="keywordflow">else</span>
<a name="l00673"></a>00673     {
<a name="l00674"></a>00674     <a class="code" href="a00750.html#ga708f7e84f7aae00a027e7026c5b16292" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(x, tmp_name, f);
<a name="l00675"></a>00675     
<a name="l00676"></a>00676     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00677"></a>00677     
<a name="l00678"></a>00678     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00679"></a>00679     
<a name="l00680"></a>00680     f.flush();
<a name="l00681"></a>00681     f.close();
<a name="l00682"></a>00682     
<a name="l00683"></a>00683     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00684"></a>00684       {
<a name="l00685"></a>00685       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00686"></a>00686       }
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4a103f843e958c4162dd0107ffea5724"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="ga4a103f843e958c4162dd0107ffea5724" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00701">701</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00702_source.html#l00030">podarray&lt; eT &gt;::mem</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00702"></a>00702   {
<a name="l00703"></a>00703   arma_extra_debug_sigprint();
<a name="l00704"></a>00704   
<a name="l00705"></a>00705   f &lt;&lt; <span class="stringliteral">&quot;P5&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00706"></a>00706   f &lt;&lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00707"></a>00707   f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00708"></a>00708   
<a name="l00709"></a>00709   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l00710"></a>00710   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00711"></a>00711   
<a name="l00712"></a>00712   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00713"></a>00713   
<a name="l00714"></a>00714   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00715"></a>00715     {
<a name="l00716"></a>00716     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00717"></a>00717       {
<a name="l00718"></a>00718       tmp[i] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x(row,col) );  <span class="comment">// TODO: add round() ?</span>
<a name="l00719"></a>00719       ++i;
<a name="l00720"></a>00720       }
<a name="l00721"></a>00721     }
<a name="l00722"></a>00722   
<a name="l00723"></a>00723   f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l00724"></a>00724   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8f433ab032357ad0aa454c4fca6d6257"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="ga8f433ab032357ad0aa454c4fca6d6257" args="(const Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00732">732</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00660">save_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00733"></a>00733   {
<a name="l00734"></a>00734   arma_extra_debug_sigprint();
<a name="l00735"></a>00735   
<a name="l00736"></a>00736   <span class="keyword">const</span> <a class="code" href="a00308.html" title="Dense matrix class.">uchar_mat</a> tmp = <a class="code" href="a00061.html">conv_to&lt;uchar_mat&gt;::from</a>(x);
<a name="l00737"></a>00737   <a class="code" href="a00750.html#ga708f7e84f7aae00a027e7026c5b16292" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(tmp, final_name);
<a name="l00738"></a>00738   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga639316b7a73d03c62380562ca005d25a"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="ga639316b7a73d03c62380562ca005d25a" args="(const Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00746">746</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00660">save_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00747"></a>00747   {
<a name="l00748"></a>00748   arma_extra_debug_sigprint();
<a name="l00749"></a>00749   
<a name="l00750"></a>00750   <span class="keyword">const</span> <a class="code" href="a00308.html" title="Dense matrix class.">uchar_mat</a> tmp = <a class="code" href="a00061.html">conv_to&lt;uchar_mat&gt;::from</a>(x);
<a name="l00751"></a>00751   <a class="code" href="a00750.html#ga708f7e84f7aae00a027e7026c5b16292" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(tmp, name, f);
<a name="l00752"></a>00752   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga400632d14748572e5faeecb30e7915c7"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="ga400632d14748572e5faeecb30e7915c7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00762">762</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02452">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00529_source.html#l01795">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00535_source.html#l01221">load_auto_detect()</a>, and <a class="el" href="a00535_source.html#l01490">load_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00763"></a>00763   {
<a name="l00764"></a>00764   arma_extra_debug_sigprint();
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   std::fstream f;
<a name="l00767"></a>00767   f.open(name.c_str(), std::fstream::in);
<a name="l00768"></a>00768   
<a name="l00769"></a>00769   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00770"></a>00770     {
<a name="l00771"></a>00771     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00772"></a>00772     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00773"></a>00773     }
<a name="l00774"></a>00774   <span class="keywordflow">else</span>
<a name="l00775"></a>00775     {
<a name="l00776"></a>00776     <a class="code" href="a00750.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">diskio::load_raw_ascii</a>(x, name, f);
<a name="l00777"></a>00777     f.close();
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa2e2c93c23b86c1d57444d51fae2042b"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="gaa2e2c93c23b86c1d57444d51fae2042b" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00787">787</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00632_source.html#l02267">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00788"></a>00788   {
<a name="l00789"></a>00789   arma_extra_debug_sigprint();
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00792"></a>00792   
<a name="l00793"></a>00793   <span class="comment">//std::fstream::pos_type start = f.tellg();</span>
<a name="l00794"></a>00794   
<a name="l00795"></a>00795   <span class="comment">//</span>
<a name="l00796"></a>00796   <span class="comment">// work out the size</span>
<a name="l00797"></a>00797   
<a name="l00798"></a>00798   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l00799"></a>00799   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l00800"></a>00800   
<a name="l00801"></a>00801   <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l00802"></a>00802   
<a name="l00803"></a>00803   std::string line_string;
<a name="l00804"></a>00804   std::string token;
<a name="l00805"></a>00805   
<a name="l00806"></a>00806   <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l00807"></a>00807     {
<a name="l00808"></a>00808     std::getline(f, line_string);
<a name="l00809"></a>00809     <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l00810"></a>00810       <span class="keywordflow">break</span>;
<a name="l00811"></a>00811     
<a name="l00812"></a>00812     std::stringstream line_stream(line_string);
<a name="l00813"></a>00813     
<a name="l00814"></a>00814     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l00815"></a>00815     <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l00816"></a>00816       line_n_cols++;
<a name="l00817"></a>00817     
<a name="l00818"></a>00818     <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l00819"></a>00819       {
<a name="l00820"></a>00820       f_n_cols = line_n_cols;
<a name="l00821"></a>00821       f_n_cols_found = <span class="keyword">true</span>;
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823     <span class="keywordflow">else</span>
<a name="l00824"></a>00824       {
<a name="l00825"></a>00825       <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l00826"></a>00826         {
<a name="l00827"></a>00827         <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;inconsistent number of columns in &quot;</span>, name );
<a name="l00828"></a>00828         load_okay = <span class="keyword">false</span>;
<a name="l00829"></a>00829         }
<a name="l00830"></a>00830       }
<a name="l00831"></a>00831     
<a name="l00832"></a>00832     ++f_n_rows;
<a name="l00833"></a>00833     }
<a name="l00834"></a>00834     
<a name="l00835"></a>00835   <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l00836"></a>00836     {
<a name="l00837"></a>00837     f.clear();
<a name="l00838"></a>00838     f.seekg(0, ios::beg);
<a name="l00839"></a>00839     <span class="comment">//f.seekg(start);</span>
<a name="l00840"></a>00840     
<a name="l00841"></a>00841     x.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00842"></a>00842   
<a name="l00843"></a>00843     eT val;
<a name="l00844"></a>00844     
<a name="l00845"></a>00845     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00846"></a>00846       {
<a name="l00847"></a>00847       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00848"></a>00848         {
<a name="l00849"></a>00849         <span class="comment">// f &gt;&gt; token;</span>
<a name="l00850"></a>00850         <span class="comment">// x.at(row,col) = eT( strtod(token.c_str(), 0) );</span>
<a name="l00851"></a>00851         
<a name="l00852"></a>00852         f &gt;&gt; val;
<a name="l00853"></a>00853         x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = val;
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855       }
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857   
<a name="l00858"></a>00858   <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00859"></a>00859     {
<a name="l00860"></a>00860     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name );
<a name="l00861"></a>00861     load_okay = <span class="keyword">false</span>; 
<a name="l00862"></a>00862     }
<a name="l00863"></a>00863   
<a name="l00864"></a>00864   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00865"></a>00865     {
<a name="l00866"></a>00866     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00867"></a>00867     }
<a name="l00868"></a>00868   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga81f825e8e6474ff560b71cb1e144dbd7"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga81f825e8e6474ff560b71cb1e144dbd7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00877">877</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02452">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00529_source.html#l01795">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00535_source.html#l01534">load_arma_ascii()</a>, and <a class="el" href="a00535_source.html#l01221">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00878"></a>00878   {
<a name="l00879"></a>00879   arma_extra_debug_sigprint();
<a name="l00880"></a>00880   
<a name="l00881"></a>00881   std::ifstream f(name.c_str());
<a name="l00882"></a>00882   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00883"></a>00883     {
<a name="l00884"></a>00884     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00885"></a>00885     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00886"></a>00886     }
<a name="l00887"></a>00887   <span class="keywordflow">else</span>
<a name="l00888"></a>00888     {
<a name="l00889"></a>00889     <a class="code" href="a00750.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l00890"></a>00890     f.close();
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0b3c538d085fc0cbace61d20e5a08ffe"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga0b3c538d085fc0cbace61d20e5a08ffe" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00901">901</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00535_source.html#l00030">gen_txt_header()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00632_source.html#l02267">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00902"></a>00902   {
<a name="l00903"></a>00903   arma_extra_debug_sigprint();
<a name="l00904"></a>00904   
<a name="l00905"></a>00905   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00906"></a>00906   
<a name="l00907"></a>00907   std::string f_header;
<a name="l00908"></a>00908   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00909"></a>00909   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00910"></a>00910   
<a name="l00911"></a>00911   f &gt;&gt; f_header;
<a name="l00912"></a>00912   f &gt;&gt; f_n_rows;
<a name="l00913"></a>00913   f &gt;&gt; f_n_cols;
<a name="l00914"></a>00914   
<a name="l00915"></a>00915   <span class="keywordflow">if</span>(f_header == <a class="code" href="a00750.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x))
<a name="l00916"></a>00916     {
<a name="l00917"></a>00917     x.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00918"></a>00918     
<a name="l00919"></a>00919     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00920"></a>00920       {
<a name="l00921"></a>00921       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00922"></a>00922         {
<a name="l00923"></a>00923         f &gt;&gt; x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00924"></a>00924         }
<a name="l00925"></a>00925       }
<a name="l00926"></a>00926     
<a name="l00927"></a>00927     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00928"></a>00928       {
<a name="l00929"></a>00929       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l00930"></a>00930       load_okay = <span class="keyword">false</span>;
<a name="l00931"></a>00931       }
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933   <span class="keywordflow">else</span>
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name );
<a name="l00936"></a>00936     load_okay = <span class="keyword">false</span>;
<a name="l00937"></a>00937     } 
<a name="l00938"></a>00938   
<a name="l00939"></a>00939   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00940"></a>00940     {
<a name="l00941"></a>00941     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00942"></a>00942     }
<a name="l00943"></a>00943   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8e0731ede58797f7638eda2a50af240f"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga8e0731ede58797f7638eda2a50af240f" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l00952">952</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02452">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00556_source.html#l01158">field_aux::load()</a>, <a class="el" href="a00529_source.html#l01795">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00535_source.html#l01614">load_arma_binary()</a>, and <a class="el" href="a00535_source.html#l01221">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00953"></a>00953   {
<a name="l00954"></a>00954   arma_extra_debug_sigprint();
<a name="l00955"></a>00955   
<a name="l00956"></a>00956   std::ifstream f;
<a name="l00957"></a>00957   f.open(name.c_str(), std::fstream::binary);
<a name="l00958"></a>00958   
<a name="l00959"></a>00959   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00960"></a>00960     {
<a name="l00961"></a>00961     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00962"></a>00962     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00963"></a>00963     }
<a name="l00964"></a>00964   <span class="keywordflow">else</span>
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l00967"></a>00967     f.close();
<a name="l00968"></a>00968     }
<a name="l00969"></a>00969   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga45f83986731c0c0f63daa9c7895a2fd2"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga45f83986731c0c0f63daa9c7895a2fd2" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l00976">976</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00100">gen_bin_header()</a>, <a class="el" href="a00632_source.html#l02069">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>, and <a class="el" href="a00632_source.html#l02267">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00977"></a>00977   {
<a name="l00978"></a>00978   arma_extra_debug_sigprint();
<a name="l00979"></a>00979   
<a name="l00980"></a>00980   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00981"></a>00981   
<a name="l00982"></a>00982   std::string f_header;
<a name="l00983"></a>00983   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00984"></a>00984   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00985"></a>00985   
<a name="l00986"></a>00986   f &gt;&gt; f_header;
<a name="l00987"></a>00987   f &gt;&gt; f_n_rows;
<a name="l00988"></a>00988   f &gt;&gt; f_n_cols;
<a name="l00989"></a>00989   
<a name="l00990"></a>00990   <span class="keywordflow">if</span>(f_header == <a class="code" href="a00750.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x))
<a name="l00991"></a>00991     {
<a name="l00992"></a>00992     <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l00993"></a>00993     f.get();
<a name="l00994"></a>00994     
<a name="l00995"></a>00995     x.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00996"></a>00996     f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="a00827.html#ga78bb1eef0619bccb2a13f3dfafee19bf" title="returns a pointer to array of eTs used by the matrix">memptr</a>()), x.<a class="code" href="a00308.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00997"></a>00997     
<a name="l00998"></a>00998     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00999"></a>00999       {
<a name="l01000"></a>01000       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01001"></a>01001       load_okay = <span class="keyword">false</span>;
<a name="l01002"></a>01002       }
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004   <span class="keywordflow">else</span>
<a name="l01005"></a>01005     {
<a name="l01006"></a>01006     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name);
<a name="l01007"></a>01007     load_okay = <span class="keyword">false</span>;
<a name="l01008"></a>01008     }
<a name="l01009"></a>01009   
<a name="l01010"></a>01010   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01011"></a>01011     {
<a name="l01012"></a>01012     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga49b5a9c169b0cb638a029af61f922c97"></a><!-- doxytag: member="diskio::pnm_skip_comments" ref="ga49b5a9c169b0cb638a029af61f922c97" args="(std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::pnm_skip_comments </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01020">1020</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00535_source.html#l01070">load_pgm_binary()</a>, and <a class="el" href="a00535_source.html#l02144">load_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01021"></a>01021   {
<a name="l01022"></a>01022   <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l01023"></a>01023     {
<a name="l01024"></a>01024     <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l01025"></a>01025       {
<a name="l01026"></a>01026       f.get();
<a name="l01027"></a>01027       }
<a name="l01028"></a>01028   
<a name="l01029"></a>01029     <span class="keywordflow">if</span>(f.peek() == <span class="charliteral">&apos;#&apos;</span>)
<a name="l01030"></a>01030       {
<a name="l01031"></a>01031       <span class="keywordflow">while</span>( (f.peek() != <span class="charliteral">&apos;\r&apos;</span>) &amp;&amp; (f.peek()!=<span class="charliteral">&apos;\n&apos;</span>) )
<a name="l01032"></a>01032         {
<a name="l01033"></a>01033         f.get();
<a name="l01034"></a>01034         }
<a name="l01035"></a>01035       }
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga114a20791e59f5a1ad076c0a6153c634"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="ga114a20791e59f5a1ad076c0a6153c634" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01045">1045</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02452">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00535_source.html#l01221">load_auto_detect()</a>, and <a class="el" href="a00535_source.html#l01167">load_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01046"></a>01046   {
<a name="l01047"></a>01047   arma_extra_debug_sigprint();
<a name="l01048"></a>01048   
<a name="l01049"></a>01049   std::fstream f;
<a name="l01050"></a>01050   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01051"></a>01051   
<a name="l01052"></a>01052   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01053"></a>01053     {
<a name="l01054"></a>01054     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01055"></a>01055     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057   <span class="keywordflow">else</span>
<a name="l01058"></a>01058     {
<a name="l01059"></a>01059     <a class="code" href="a00750.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">diskio::load_pgm_binary</a>(x, name, f); <span class="comment">// Do the actual load</span>
<a name="l01060"></a>01060     f.close();
<a name="l01061"></a>01061     }
<a name="l01062"></a>01062   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad236bb1f44446de130054ea0a4b85152"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="gad236bb1f44446de130054ea0a4b85152" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01070">1070</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00701_source.html#l00209">podarray&lt; eT &gt;::memptr()</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00535_source.html#l01020">pnm_skip_comments()</a>, <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00632_source.html#l02267">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01071"></a>01071   {
<a name="l01072"></a>01072   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01073"></a>01073   
<a name="l01074"></a>01074   std::string f_header;
<a name="l01075"></a>01075   f &gt;&gt; f_header;
<a name="l01076"></a>01076   
<a name="l01077"></a>01077   <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P5&quot;</span>)
<a name="l01078"></a>01078     {
<a name="l01079"></a>01079     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01080"></a>01080     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01081"></a>01081     <span class="keywordtype">int</span> f_maxval = 0;
<a name="l01082"></a>01082   
<a name="l01083"></a>01083     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01084"></a>01084   
<a name="l01085"></a>01085     f &gt;&gt; f_n_cols;
<a name="l01086"></a>01086     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01087"></a>01087   
<a name="l01088"></a>01088     f &gt;&gt; f_n_rows;
<a name="l01089"></a>01089     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01090"></a>01090   
<a name="l01091"></a>01091     f &gt;&gt; f_maxval;
<a name="l01092"></a>01092     f.get();
<a name="l01093"></a>01093     
<a name="l01094"></a>01094     <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l01095"></a>01095       {
<a name="l01096"></a>01096       x.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l01097"></a>01097       
<a name="l01098"></a>01098       <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l01099"></a>01099         {
<a name="l01100"></a>01100         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l01101"></a>01101         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l01102"></a>01102         
<a name="l01103"></a>01103         f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l01104"></a>01104         
<a name="l01105"></a>01105         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01106"></a>01106         
<a name="l01107"></a>01107         <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l01108"></a>01108         <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l01109"></a>01109         
<a name="l01110"></a>01110         
<a name="l01111"></a>01111         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01112"></a>01112           {
<a name="l01113"></a>01113           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01114"></a>01114             {
<a name="l01115"></a>01115             x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l01116"></a>01116             ++i;
<a name="l01117"></a>01117             }
<a name="l01118"></a>01118           }
<a name="l01119"></a>01119           
<a name="l01120"></a>01120         }
<a name="l01121"></a>01121       <span class="keywordflow">else</span>
<a name="l01122"></a>01122         {
<a name="l01123"></a>01123         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l01124"></a>01124         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l01125"></a>01125         
<a name="l01126"></a>01126         f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), n_elem*2);
<a name="l01127"></a>01127         
<a name="l01128"></a>01128         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01129"></a>01129         
<a name="l01130"></a>01130         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01131"></a>01131           {
<a name="l01132"></a>01132           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01133"></a>01133             {
<a name="l01134"></a>01134             x.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l01135"></a>01135             ++i;
<a name="l01136"></a>01136             }
<a name="l01137"></a>01137           }
<a name="l01138"></a>01138         
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140       
<a name="l01141"></a>01141       }
<a name="l01142"></a>01142     
<a name="l01143"></a>01143     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01144"></a>01144       {
<a name="l01145"></a>01145       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01146"></a>01146       load_okay = <span class="keyword">false</span>;
<a name="l01147"></a>01147       }
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149   <span class="keywordflow">else</span>
<a name="l01150"></a>01150     {
<a name="l01151"></a>01151     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l01152"></a>01152     load_okay = <span class="keyword">false</span>;
<a name="l01153"></a>01153     }
<a name="l01154"></a>01154   
<a name="l01155"></a>01155   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01156"></a>01156     {
<a name="l01157"></a>01157     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01158"></a>01158     }
<a name="l01159"></a>01159   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga672f562ded628be461b769c7110264b3"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="ga672f562ded628be461b769c7110264b3" args="(Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01167">1167</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l01045">load_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01168"></a>01168   {
<a name="l01169"></a>01169   arma_extra_debug_sigprint();
<a name="l01170"></a>01170   
<a name="l01171"></a>01171   <a class="code" href="a00308.html" title="Dense matrix class.">uchar_mat</a> tmp;
<a name="l01172"></a>01172   <a class="code" href="a00750.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">diskio::load_pgm_binary</a>(tmp, name);
<a name="l01173"></a>01173   x = <a class="code" href="a00061.html">conv_to&lt; Mat&lt; std::complex&lt;T&gt;</a> &gt; &gt;::from(tmp);
<a name="l01174"></a>01174   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaadd01b28b36aadd1efe3fed7f8f7f5af"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="gaadd01b28b36aadd1efe3fed7f8f7f5af" args="(Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01182">1182</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l01045">load_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01183"></a>01183   {
<a name="l01184"></a>01184   arma_extra_debug_sigprint();
<a name="l01185"></a>01185   
<a name="l01186"></a>01186   <a class="code" href="a00308.html" title="Dense matrix class.">uchar_mat</a> tmp;
<a name="l01187"></a>01187   <a class="code" href="a00750.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">diskio::load_pgm_binary</a>(tmp, name, is);
<a name="l01188"></a>01188   x = <a class="code" href="a00061.html">conv_to&lt; Mat&lt; std::complex&lt;T&gt;</a> &gt; &gt;::from(tmp);
<a name="l01189"></a>01189   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><!-- doxytag: member="diskio::load_auto_detect" ref="ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a matrix by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01197">1197</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00632_source.html#l02371">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00632_source.html#l02452">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00556_source.html#l01158">field_aux::load()</a>, <a class="el" href="a00529_source.html#l01795">Cube&lt; eT &gt;::load()</a>, and <a class="el" href="a00535_source.html#l01685">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01198"></a>01198   {
<a name="l01199"></a>01199   arma_extra_debug_sigprint();
<a name="l01200"></a>01200   
<a name="l01201"></a>01201   std::fstream f;
<a name="l01202"></a>01202   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01203"></a>01203   
<a name="l01204"></a>01204   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01205"></a>01205     {
<a name="l01206"></a>01206     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01207"></a>01207     x.<a class="code" href="a00827.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01208"></a>01208     }
<a name="l01209"></a>01209   <span class="keywordflow">else</span>
<a name="l01210"></a>01210     {
<a name="l01211"></a>01211     <a class="code" href="a00750.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" title="Try to load a matrix by automatically determining its type.">diskio::load_auto_detect</a>(x, name, f); <span class="comment">// Do the actual load</span>
<a name="l01212"></a>01212     f.close();
<a name="l01213"></a>01213     }
<a name="l01214"></a>01214   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2ff4ab7b425bdb0d0d07fdb6a6b7fae6"></a><!-- doxytag: member="diskio::load_auto_detect" ref="ga2ff4ab7b425bdb0d0d07fdb6a6b7fae6" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00308.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a matrix by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01221">1221</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00877">load_arma_ascii()</a>, <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>, <a class="el" href="a00535_source.html#l01045">load_pgm_binary()</a>, and <a class="el" href="a00535_source.html#l00762">load_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01222"></a>01222   {
<a name="l01223"></a>01223   arma_extra_debug_sigprint();
<a name="l01224"></a>01224   
<a name="l01225"></a>01225   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_TXT = <span class="stringliteral">&quot;ARMA_MAT_TXT&quot;</span>;
<a name="l01226"></a>01226   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_BIN = <span class="stringliteral">&quot;ARMA_MAT_BIN&quot;</span>;
<a name="l01227"></a>01227   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P5 = <span class="stringliteral">&quot;P5&quot;</span>;
<a name="l01228"></a>01228   
<a name="l01229"></a>01229   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_MAT_TXT.length() + 1);
<a name="l01230"></a>01230   
<a name="l01231"></a>01231   std::streampos pos = f.tellg();
<a name="l01232"></a>01232     
<a name="l01233"></a>01233   f.read(raw_header.memptr(), ARMA_MAT_TXT.length());
<a name="l01234"></a>01234   raw_header[ARMA_MAT_TXT.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01235"></a>01235   
<a name="l01236"></a>01236   f.clear();
<a name="l01237"></a>01237   f.seekg(pos);
<a name="l01238"></a>01238   
<a name="l01239"></a>01239   <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01240"></a>01240   
<a name="l01241"></a>01241   <span class="keywordflow">if</span>(ARMA_MAT_TXT == header.substr(0,ARMA_MAT_TXT.length()))
<a name="l01242"></a>01242     {
<a name="l01243"></a>01243     <a class="code" href="a00750.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name, f);
<a name="l01244"></a>01244     }
<a name="l01245"></a>01245   <span class="keywordflow">else</span>
<a name="l01246"></a>01246   <span class="keywordflow">if</span>(ARMA_MAT_BIN == header.substr(0,ARMA_MAT_BIN.length()))
<a name="l01247"></a>01247     {
<a name="l01248"></a>01248     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name, f);
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250   <span class="keywordflow">else</span>
<a name="l01251"></a>01251   <span class="keywordflow">if</span>(P5 == header.substr(0,P5.length()))
<a name="l01252"></a>01252     {
<a name="l01253"></a>01253     <a class="code" href="a00750.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">load_pgm_binary</a>(x, name, f);
<a name="l01254"></a>01254     }
<a name="l01255"></a>01255   <span class="keywordflow">else</span>
<a name="l01256"></a>01256     {
<a name="l01257"></a>01257     <a class="code" href="a00750.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name, f);
<a name="l01258"></a>01258     }
<a name="l01259"></a>01259   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga174fcb65d0726a0b074cb638cf09d6b0"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="ga174fcb65d0726a0b074cb638cf09d6b0" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube as raw text (no header, human readable). </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01271">1271</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00535_source.html#l00447">save_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01272"></a>01272   {
<a name="l01273"></a>01273   arma_extra_debug_sigprint();
<a name="l01274"></a>01274   
<a name="l01275"></a>01275   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01276"></a>01276   
<a name="l01277"></a>01277   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l01278"></a>01278   
<a name="l01279"></a>01279   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01280"></a>01280     {
<a name="l01281"></a>01281     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283   <span class="keywordflow">else</span>
<a name="l01284"></a>01284     {
<a name="l01285"></a>01285     <a class="code" href="a00750.html#ga8a6a29012670b812a16dcfca30312b4b" title="Save a matrix as raw text (no header, human readable). Matrices can be loaded in...">save_raw_ascii</a>(x, tmp_name, f);
<a name="l01286"></a>01286     
<a name="l01287"></a>01287     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01288"></a>01288     
<a name="l01289"></a>01289     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01290"></a>01290     
<a name="l01291"></a>01291     f.flush();
<a name="l01292"></a>01292     f.close();
<a name="l01293"></a>01293     
<a name="l01294"></a>01294     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01295"></a>01295       {
<a name="l01296"></a>01296       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01297"></a>01297       }
<a name="l01298"></a>01298     }
<a name="l01299"></a>01299   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0490dd220114352462b5dab3b321e9f2"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="ga0490dd220114352462b5dab3b321e9f2" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube as raw text (no header, human readable). </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01307">1307</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00529_source.html#l01375">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00530_source.html#l00031">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00530_source.html#l00030">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01308"></a>01308   {
<a name="l01309"></a>01309   arma_extra_debug_sigprint();
<a name="l01310"></a>01310   
<a name="l01311"></a>01311   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l01312"></a>01312   
<a name="l01313"></a>01313   <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l01314"></a>01314   
<a name="l01315"></a>01315   <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01316"></a>01316     {
<a name="l01317"></a>01317     f.setf(ios::scientific);
<a name="l01318"></a>01318     f.precision(8);
<a name="l01319"></a>01319     cell_width = 16;
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321   
<a name="l01322"></a>01322   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01323"></a>01323     {
<a name="l01324"></a>01324     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01325"></a>01325       {
<a name="l01326"></a>01326       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01327"></a>01327         {
<a name="l01328"></a>01328         f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l01329"></a>01329         
<a name="l01330"></a>01330         <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01331"></a>01331           {
<a name="l01332"></a>01332           f.width(cell_width);
<a name="l01333"></a>01333           }
<a name="l01334"></a>01334         
<a name="l01335"></a>01335         f &lt;&lt; x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01336"></a>01336         }
<a name="l01337"></a>01337         
<a name="l01338"></a>01338       f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l01339"></a>01339       }
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga144d1cf32717082303ca3507398f495a"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="ga144d1cf32717082303ca3507398f495a" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01350">1350</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00535_source.html#l00523">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01351"></a>01351   {
<a name="l01352"></a>01352   arma_extra_debug_sigprint();
<a name="l01353"></a>01353   
<a name="l01354"></a>01354   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01355"></a>01355   
<a name="l01356"></a>01356   std::ofstream f(tmp_name.c_str());
<a name="l01357"></a>01357   
<a name="l01358"></a>01358   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01359"></a>01359     {
<a name="l01360"></a>01360     arma_debug_print(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l01361"></a>01361     }
<a name="l01362"></a>01362   <span class="keywordflow">else</span>
<a name="l01363"></a>01363     {
<a name="l01364"></a>01364     <a class="code" href="a00750.html#gaa8932912b23cef92f20393a203cc9e74" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l01365"></a>01365     
<a name="l01366"></a>01366     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01367"></a>01367     
<a name="l01368"></a>01368     f.flush();
<a name="l01369"></a>01369     f.close();
<a name="l01370"></a>01370     
<a name="l01371"></a>01371     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01372"></a>01372     
<a name="l01373"></a>01373     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01374"></a>01374       {
<a name="l01375"></a>01375       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01376"></a>01376       }
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga49c98268e07839c2def405e6254a141b"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="ga49c98268e07839c2def405e6254a141b" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01387">1387</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00529_source.html#l01375">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00535_source.html#l00030">gen_txt_header()</a>, <a class="el" href="a00530_source.html#l00031">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00530_source.html#l00030">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01388"></a>01388   {
<a name="l01389"></a>01389   arma_extra_debug_sigprint();
<a name="l01390"></a>01390   
<a name="l01391"></a>01391   <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l01392"></a>01392   
<a name="l01393"></a>01393   f &lt;&lt; <a class="code" href="a00750.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01394"></a>01394   f &lt;&lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01395"></a>01395   
<a name="l01396"></a>01396   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l01397"></a>01397   
<a name="l01398"></a>01398   <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l01399"></a>01399   
<a name="l01400"></a>01400   <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01401"></a>01401     {
<a name="l01402"></a>01402     f.setf(ios::scientific);
<a name="l01403"></a>01403     f.precision(8);
<a name="l01404"></a>01404     cell_width = 16;
<a name="l01405"></a>01405     }
<a name="l01406"></a>01406     
<a name="l01407"></a>01407   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01408"></a>01408     {
<a name="l01409"></a>01409     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01410"></a>01410       {
<a name="l01411"></a>01411       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01412"></a>01412         {
<a name="l01413"></a>01413         f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l01414"></a>01414         
<a name="l01415"></a>01415         <span class="keywordflow">if</span>( (<a class="code" href="a00228.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00222.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l01416"></a>01416           {
<a name="l01417"></a>01417           f.width(cell_width);
<a name="l01418"></a>01418           }
<a name="l01419"></a>01419         
<a name="l01420"></a>01420         f &lt;&lt; x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01421"></a>01421         }
<a name="l01422"></a>01422       
<a name="l01423"></a>01423       f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l01424"></a>01424       }
<a name="l01425"></a>01425     }
<a name="l01426"></a>01426   
<a name="l01427"></a>01427   f.flags(orig_flags);
<a name="l01428"></a>01428   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga26ac154aece92b7be2247de51e1f7d66"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga26ac154aece92b7be2247de51e1f7d66" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in binary format, with a header that stores the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01437">1437</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00535_source.html#l00607">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01438"></a>01438   {
<a name="l01439"></a>01439   arma_extra_debug_sigprint();
<a name="l01440"></a>01440   
<a name="l01441"></a>01441   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01442"></a>01442   
<a name="l01443"></a>01443   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l01444"></a>01444   
<a name="l01445"></a>01445   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01446"></a>01446     {
<a name="l01447"></a>01447     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449   <span class="keywordflow">else</span>
<a name="l01450"></a>01450     {
<a name="l01451"></a>01451     <a class="code" href="a00750.html#ga405dbdcfcbfe838f75d7be72e37b0e07" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l01452"></a>01452     
<a name="l01453"></a>01453     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01454"></a>01454     
<a name="l01455"></a>01455     f.flush();
<a name="l01456"></a>01456     f.close();
<a name="l01457"></a>01457     
<a name="l01458"></a>01458     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01459"></a>01459     
<a name="l01460"></a>01460     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01461"></a>01461       {
<a name="l01462"></a>01462       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01463"></a>01463       }
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf13c5d05ac5e92956d16777c7d95512c"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gaf13c5d05ac5e92956d16777c7d95512c" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in binary format, with a header that stores the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01474">1474</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00100">gen_bin_header()</a>, <a class="el" href="a00530_source.html#l00038">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00530_source.html#l00031">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00530_source.html#l00034">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00530_source.html#l00030">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01475"></a>01475   {
<a name="l01476"></a>01476   arma_extra_debug_sigprint();
<a name="l01477"></a>01477   f &lt;&lt; <a class="code" href="a00750.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01478"></a>01478   f &lt;&lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01479"></a>01479   
<a name="l01480"></a>01480   f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="a00068.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>), x.<a class="code" href="a00068.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l01481"></a>01481   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga35f015b5569d09e69d1562f3c087811e"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="ga35f015b5569d09e69d1562f3c087811e" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01490">1490</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00762">load_raw_ascii()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00529_source.html#l01611">Cube&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00529_source.html#l00720">Cube&lt; eT &gt;::slice()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01491"></a>01491   {
<a name="l01492"></a>01492   arma_extra_debug_sigprint();
<a name="l01493"></a>01493 
<a name="l01494"></a>01494   <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a> tmp;
<a name="l01495"></a>01495   <a class="code" href="a00750.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">diskio::load_raw_ascii</a>(tmp, name);
<a name="l01496"></a>01496   
<a name="l01497"></a>01497   x.<a class="code" href="a00746.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(tmp.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>, tmp.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>, 1);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499   <span class="keywordflow">if</span>(x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &gt; 0)
<a name="l01500"></a>01500     {
<a name="l01501"></a>01501     x.<a class="code" href="a00746.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>(0) = tmp;
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga086967dd6f5fa3e2a0bf9afd044a3480"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="ga086967dd6f5fa3e2a0bf9afd044a3480" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01512">1512</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00762">load_raw_ascii()</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00529_source.html#l01611">Cube&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00529_source.html#l00720">Cube&lt; eT &gt;::slice()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01513"></a>01513   {
<a name="l01514"></a>01514   arma_extra_debug_sigprint();
<a name="l01515"></a>01515 
<a name="l01516"></a>01516   <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a> tmp;
<a name="l01517"></a>01517   <a class="code" href="a00750.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">diskio::load_raw_ascii</a>(tmp, name, f);
<a name="l01518"></a>01518   
<a name="l01519"></a>01519   x.<a class="code" href="a00746.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(tmp.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>, tmp.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>, 1);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <span class="keywordflow">if</span>(x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &gt; 0)
<a name="l01522"></a>01522     {
<a name="l01523"></a>01523     x.<a class="code" href="a00746.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>(0) = tmp;
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8c671488b92ad364dbc2c4cba859f718"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga8c671488b92ad364dbc2c4cba859f718" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01534">1534</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00877">load_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01535"></a>01535   {
<a name="l01536"></a>01536   arma_extra_debug_sigprint();
<a name="l01537"></a>01537   
<a name="l01538"></a>01538   std::ifstream f(name.c_str());
<a name="l01539"></a>01539   
<a name="l01540"></a>01540   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01541"></a>01541     {
<a name="l01542"></a>01542     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01543"></a>01543     }
<a name="l01544"></a>01544   <span class="keywordflow">else</span>
<a name="l01545"></a>01545     {
<a name="l01546"></a>01546     <a class="code" href="a00750.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l01547"></a>01547     f.close();
<a name="l01548"></a>01548     }
<a name="l01549"></a>01549   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga13c9a7326ba62eb3b03bb4f4d01a8ba4"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga13c9a7326ba62eb3b03bb4f4d01a8ba4" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01558">1558</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00529_source.html#l01375">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00535_source.html#l00030">gen_txt_header()</a>, <a class="el" href="a00530_source.html#l00031">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00530_source.html#l00030">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00529_source.html#l01714">Cube&lt; eT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00529_source.html#l01611">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01559"></a>01559   {
<a name="l01560"></a>01560   arma_extra_debug_sigprint();
<a name="l01561"></a>01561   
<a name="l01562"></a>01562   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01563"></a>01563   
<a name="l01564"></a>01564   std::string f_header;
<a name="l01565"></a>01565   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01566"></a>01566   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01567"></a>01567   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_slices;
<a name="l01568"></a>01568   
<a name="l01569"></a>01569   f &gt;&gt; f_header;
<a name="l01570"></a>01570   f &gt;&gt; f_n_rows;
<a name="l01571"></a>01571   f &gt;&gt; f_n_cols;
<a name="l01572"></a>01572   f &gt;&gt; f_n_slices;
<a name="l01573"></a>01573   
<a name="l01574"></a>01574   <span class="keywordflow">if</span>(f_header == <a class="code" href="a00750.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x))
<a name="l01575"></a>01575     {
<a name="l01576"></a>01576     x.<a class="code" href="a00746.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, f_n_slices);
<a name="l01577"></a>01577 
<a name="l01578"></a>01578     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01579"></a>01579       {
<a name="l01580"></a>01580       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01581"></a>01581         {
<a name="l01582"></a>01582         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01583"></a>01583           {
<a name="l01584"></a>01584           f &gt;&gt; x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01585"></a>01585           }
<a name="l01586"></a>01586         }
<a name="l01587"></a>01587       }
<a name="l01588"></a>01588     
<a name="l01589"></a>01589     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01590"></a>01590       {
<a name="l01591"></a>01591       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01592"></a>01592       load_okay = <span class="keyword">false</span>;
<a name="l01593"></a>01593       }
<a name="l01594"></a>01594     }
<a name="l01595"></a>01595   <span class="keywordflow">else</span>
<a name="l01596"></a>01596     {
<a name="l01597"></a>01597     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name );
<a name="l01598"></a>01598     load_okay = <span class="keyword">false</span>;
<a name="l01599"></a>01599     }
<a name="l01600"></a>01600   
<a name="l01601"></a>01601   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01602"></a>01602     {
<a name="l01603"></a>01603     x.<a class="code" href="a00746.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga089f7fe67d64e445cd716cae5d4aad65"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga089f7fe67d64e445cd716cae5d4aad65" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in binary format, with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01614">1614</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01615"></a>01615   {
<a name="l01616"></a>01616   arma_extra_debug_sigprint();
<a name="l01617"></a>01617   
<a name="l01618"></a>01618   std::ifstream f;
<a name="l01619"></a>01619   f.open(name.c_str(), std::fstream::binary);
<a name="l01620"></a>01620   
<a name="l01621"></a>01621   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01622"></a>01622     {
<a name="l01623"></a>01623     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01624"></a>01624     }
<a name="l01625"></a>01625   <span class="keywordflow">else</span>
<a name="l01626"></a>01626     {
<a name="l01627"></a>01627     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l01628"></a>01628     f.close();
<a name="l01629"></a>01629     }
<a name="l01630"></a>01630   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab839d0c3053d445f6be3577ca3ae7bb7"></a><!-- doxytag: member="diskio::load_arma_binary" ref="gab839d0c3053d445f6be3577ca3ae7bb7" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01637">1637</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00100">gen_bin_header()</a>, <a class="el" href="a00529_source.html#l01462">Cube&lt; eT &gt;::memptr()</a>, <a class="el" href="a00530_source.html#l00034">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00529_source.html#l01714">Cube&lt; eT &gt;::reset()</a>, and <a class="el" href="a00529_source.html#l01611">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01638"></a>01638   {
<a name="l01639"></a>01639   arma_extra_debug_sigprint();
<a name="l01640"></a>01640   
<a name="l01641"></a>01641   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01642"></a>01642   
<a name="l01643"></a>01643   std::string f_header;
<a name="l01644"></a>01644   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01645"></a>01645   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01646"></a>01646   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_slices;
<a name="l01647"></a>01647   
<a name="l01648"></a>01648   f &gt;&gt; f_header;
<a name="l01649"></a>01649   f &gt;&gt; f_n_rows;
<a name="l01650"></a>01650   f &gt;&gt; f_n_cols;
<a name="l01651"></a>01651   f &gt;&gt; f_n_slices;
<a name="l01652"></a>01652   
<a name="l01653"></a>01653   <span class="keywordflow">if</span>(f_header == <a class="code" href="a00750.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x))
<a name="l01654"></a>01654     {
<a name="l01655"></a>01655     <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l01656"></a>01656     f.get();
<a name="l01657"></a>01657     
<a name="l01658"></a>01658     x.<a class="code" href="a00746.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, f_n_slices);
<a name="l01659"></a>01659     f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="a00746.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>()), x.<a class="code" href="a00068.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l01660"></a>01660     
<a name="l01661"></a>01661     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01662"></a>01662       {
<a name="l01663"></a>01663       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01664"></a>01664       load_okay = <span class="keyword">false</span>;
<a name="l01665"></a>01665       }
<a name="l01666"></a>01666     }
<a name="l01667"></a>01667   <span class="keywordflow">else</span>
<a name="l01668"></a>01668     {
<a name="l01669"></a>01669     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name);
<a name="l01670"></a>01670     load_okay = <span class="keyword">false</span>;
<a name="l01671"></a>01671     }
<a name="l01672"></a>01672   
<a name="l01673"></a>01673   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01674"></a>01674     {
<a name="l01675"></a>01675     x.<a class="code" href="a00746.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01676"></a>01676     }
<a name="l01677"></a>01677   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae1a42ba07bf3a86e11ab082cb96a45e9"></a><!-- doxytag: member="diskio::load_auto_detect" ref="gae1a42ba07bf3a86e11ab082cb96a45e9" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a cube by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01685">1685</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l01197">load_auto_detect()</a>, and <a class="el" href="a00529_source.html#l01714">Cube&lt; eT &gt;::reset()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01686"></a>01686   {
<a name="l01687"></a>01687   arma_extra_debug_sigprint();
<a name="l01688"></a>01688   
<a name="l01689"></a>01689   std::fstream f;
<a name="l01690"></a>01690   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01691"></a>01691   
<a name="l01692"></a>01692   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01693"></a>01693     {
<a name="l01694"></a>01694     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01695"></a>01695     x.<a class="code" href="a00746.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01696"></a>01696     }
<a name="l01697"></a>01697   <span class="keywordflow">else</span>
<a name="l01698"></a>01698     {
<a name="l01699"></a>01699     <a class="code" href="a00750.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" title="Try to load a matrix by automatically determining its type.">diskio::load_auto_detect</a>(x, name, f); <span class="comment">// Do the actual load</span>
<a name="l01700"></a>01700     f.close();
<a name="l01701"></a>01701     }
<a name="l01702"></a>01702   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0a05510e718e95647374183d8462df0a"></a><!-- doxytag: member="diskio::load_auto_detect" ref="ga0a05510e718e95647374183d8462df0a" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a cube by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l01710">1710</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00877">load_arma_ascii()</a>, <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>, <a class="el" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>, and <a class="el" href="a00535_source.html#l00762">load_raw_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01711"></a>01711   {
<a name="l01712"></a>01712   arma_extra_debug_sigprint();
<a name="l01713"></a>01713   
<a name="l01714"></a>01714   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_CUB_TXT = <span class="stringliteral">&quot;ARMA_CUB_TXT&quot;</span>;
<a name="l01715"></a>01715   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_CUB_BIN = <span class="stringliteral">&quot;ARMA_CUB_BIN&quot;</span>;
<a name="l01716"></a>01716   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P6 = <span class="stringliteral">&quot;P6&quot;</span>;
<a name="l01717"></a>01717   
<a name="l01718"></a>01718   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_CUB_TXT.length() + 1);
<a name="l01719"></a>01719   
<a name="l01720"></a>01720   std::streampos pos = f.tellg();
<a name="l01721"></a>01721   
<a name="l01722"></a>01722   f.read(raw_header.memptr(), ARMA_CUB_TXT.length());
<a name="l01723"></a>01723   raw_header[ARMA_CUB_TXT.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01724"></a>01724   
<a name="l01725"></a>01725   f.clear();
<a name="l01726"></a>01726   f.seekg(pos);
<a name="l01727"></a>01727   
<a name="l01728"></a>01728   <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01729"></a>01729   
<a name="l01730"></a>01730   <span class="keywordflow">if</span>(ARMA_CUB_TXT == header.substr(0, ARMA_CUB_TXT.length()))
<a name="l01731"></a>01731     {
<a name="l01732"></a>01732     <a class="code" href="a00750.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name, f);
<a name="l01733"></a>01733     }
<a name="l01734"></a>01734   <span class="keywordflow">else</span>
<a name="l01735"></a>01735   <span class="keywordflow">if</span>(ARMA_CUB_BIN == header.substr(0, ARMA_CUB_BIN.length()))
<a name="l01736"></a>01736     {
<a name="l01737"></a>01737     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name, f);
<a name="l01738"></a>01738     }
<a name="l01739"></a>01739   <span class="keywordflow">else</span>
<a name="l01740"></a>01740   <span class="keywordflow">if</span>(P6 == header.substr(0,P6.length()))
<a name="l01741"></a>01741     {
<a name="l01742"></a>01742     <a class="code" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary</a>(x, name, f);
<a name="l01743"></a>01743     }
<a name="l01744"></a>01744   <span class="keywordflow">else</span>
<a name="l01745"></a>01745     {
<a name="l01746"></a>01746     <a class="code" href="a00750.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name, f);
<a name="l01747"></a>01747     }
<a name="l01748"></a>01748   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2c60a2f31130b27a3cb1ad020660cc21"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga2c60a2f31130b27a3cb1ad020660cc21" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01761">1761</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00535_source.html#l00607">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01762"></a>01762   {
<a name="l01763"></a>01763   arma_extra_debug_sigprint();
<a name="l01764"></a>01764   
<a name="l01765"></a>01765   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01766"></a>01766   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01767"></a>01767   
<a name="l01768"></a>01768   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01769"></a>01769     {
<a name="l01770"></a>01770     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l01771"></a>01771     }
<a name="l01772"></a>01772   <span class="keywordflow">else</span>
<a name="l01773"></a>01773     {
<a name="l01774"></a>01774     <a class="code" href="a00750.html#ga405dbdcfcbfe838f75d7be72e37b0e07" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l01775"></a>01775 
<a name="l01776"></a>01776     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01777"></a>01777 
<a name="l01778"></a>01778     <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     f.flush();
<a name="l01781"></a>01781     f.close();
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01784"></a>01784       {
<a name="l01785"></a>01785       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01786"></a>01786       }
<a name="l01787"></a>01787     }
<a name="l01788"></a>01788   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga630d37aeb08fc23a184eb8ec33124bb2"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga630d37aeb08fc23a184eb8ec33124bb2" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01793">1793</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00557_source.html#l00034">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00557_source.html#l00035">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00557_source.html#l00033">field&lt; oT &gt;::n_rows</a>, and <a class="el" href="a00535_source.html#l00607">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01794"></a>01794   {
<a name="l01795"></a>01795   arma_extra_debug_sigprint();
<a name="l01796"></a>01796   
<a name="l01797"></a>01797   <a class="code" href="a00043.html">arma_type_check&lt; (is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &amp;&amp; (<a class="code" href="a00213.html">is_Cube&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &gt;::apply();
<a name="l01798"></a>01798   
<a name="l01799"></a>01799   f &lt;&lt; <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01800"></a>01800   f &lt;&lt; x.<a class="code" href="a00174.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01801"></a>01801   f &lt;&lt; x.<a class="code" href="a00174.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01802"></a>01802   
<a name="l01803"></a>01803   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00174.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01804"></a>01804     {
<a name="l01805"></a>01805     <a class="code" href="a00750.html#ga405dbdcfcbfe838f75d7be72e37b0e07" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x[i], name, f);
<a name="l01806"></a>01806     }
<a name="l01807"></a>01807   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga97df7a8f223054be0b5135ff783ab7d4"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga97df7a8f223054be0b5135ff783ab7d4" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01814">1814</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01815"></a>01815   {
<a name="l01816"></a>01816   arma_extra_debug_sigprint();
<a name="l01817"></a>01817   
<a name="l01818"></a>01818   std::ifstream f( name.c_str(), std::fstream::binary );
<a name="l01819"></a>01819   
<a name="l01820"></a>01820   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01821"></a>01821     {
<a name="l01822"></a>01822     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824   <span class="keywordflow">else</span>
<a name="l01825"></a>01825     {
<a name="l01826"></a>01826     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l01827"></a>01827     f.close();
<a name="l01828"></a>01828     }
<a name="l01829"></a>01829   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa4fd56fac339537f897a13be9f846a87"></a><!-- doxytag: member="diskio::load_arma_binary" ref="gaa4fd56fac339537f897a13be9f846a87" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01836">1836</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>, <a class="el" href="a00557_source.html#l00035">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00556_source.html#l00536">field&lt; oT &gt;::reset()</a>, and <a class="el" href="a00556_source.html#l00158">field&lt; oT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01837"></a>01837   {
<a name="l01838"></a>01838   arma_extra_debug_sigprint();
<a name="l01839"></a>01839   
<a name="l01840"></a>01840   <a class="code" href="a00043.html">arma_type_check&lt; (is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &amp;&amp; (<a class="code" href="a00213.html">is_Cube&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &gt;::apply();
<a name="l01841"></a>01841   
<a name="l01842"></a>01842   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01843"></a>01843   
<a name="l01844"></a>01844   std::string f_type;
<a name="l01845"></a>01845   f &gt;&gt; f_type;
<a name="l01846"></a>01846   
<a name="l01847"></a>01847   <span class="keywordflow">if</span>(f_type != <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span>)
<a name="l01848"></a>01848     {
<a name="l01849"></a>01849     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported field type in &quot;</span>, name);
<a name="l01850"></a>01850     load_okay = <span class="keyword">false</span>;
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852   <span class="keywordflow">else</span>
<a name="l01853"></a>01853     {
<a name="l01854"></a>01854     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01855"></a>01855     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01856"></a>01856   
<a name="l01857"></a>01857     f &gt;&gt; f_n_rows;
<a name="l01858"></a>01858     f &gt;&gt; f_n_cols;
<a name="l01859"></a>01859     
<a name="l01860"></a>01860     x.<a class="code" href="a00762.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01861"></a>01861     
<a name="l01862"></a>01862     f.get();      
<a name="l01863"></a>01863     
<a name="l01864"></a>01864     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00174.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01865"></a>01865       {
<a name="l01866"></a>01866       <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x[i], name, f);
<a name="l01867"></a>01867       
<a name="l01868"></a>01868       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01869"></a>01869         {
<a name="l01870"></a>01870         <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01871"></a>01871         load_okay = <span class="keyword">false</span>;
<a name="l01872"></a>01872         <span class="keywordflow">break</span>;
<a name="l01873"></a>01873         }
<a name="l01874"></a>01874       }
<a name="l01875"></a>01875     }
<a name="l01876"></a>01876 
<a name="l01877"></a>01877   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01878"></a>01878     {
<a name="l01879"></a>01879     x.<a class="code" href="a00762.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01880"></a>01880     }
<a name="l01881"></a>01881   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga83f09e96c16bb21f7185d867c9845efe"></a><!-- doxytag: member="diskio::save_std_string" ref="ga83f09e96c16bb21f7185d867c9845efe" args="(const field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_std_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01887">1887</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, and <a class="el" href="a00535_source.html#l00420">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00556_source.html#l01525">field_aux::save()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01888"></a>01888   {
<a name="l01889"></a>01889   arma_extra_debug_sigprint();
<a name="l01890"></a>01890   
<a name="l01891"></a>01891   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01892"></a>01892   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01893"></a>01893   
<a name="l01894"></a>01894   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01895"></a>01895     {
<a name="l01896"></a>01896     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l01897"></a>01897     }
<a name="l01898"></a>01898   <span class="keywordflow">else</span>
<a name="l01899"></a>01899     {
<a name="l01900"></a>01900     <a class="code" href="a00750.html#ga83f09e96c16bb21f7185d867c9845efe">diskio::save_std_string</a>(x, tmp_name, f);
<a name="l01901"></a>01901     
<a name="l01902"></a>01902     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01903"></a>01903     
<a name="l01904"></a>01904     f.flush();
<a name="l01905"></a>01905     f.close();
<a name="l01906"></a>01906     
<a name="l01907"></a>01907     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01908"></a>01908       {
<a name="l01909"></a>01909       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01910"></a>01910       }
<a name="l01911"></a>01911     }
<a name="l01912"></a>01912   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga444dcaee9bc0a3211e55faf808126071"></a><!-- doxytag: member="diskio::save_std_string" ref="ga444dcaee9bc0a3211e55faf808126071" args="(const field&lt; std::string &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_std_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01918">1918</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00556_source.html#l00267">field&lt; oT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00557_source.html#l00034">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00557_source.html#l00033">field&lt; oT &gt;::n_rows</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01919"></a>01919   {
<a name="l01920"></a>01920   arma_extra_debug_sigprint();
<a name="l01921"></a>01921   
<a name="l01922"></a>01922   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row&lt;x.<a class="code" href="a00174.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l01923"></a>01923   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col&lt;x.<a class="code" href="a00174.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l01924"></a>01924     {
<a name="l01925"></a>01925     f &lt;&lt; x.<a class="code" href="a00762.html#ga0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l01926"></a>01926     
<a name="l01927"></a>01927     <span class="keywordflow">if</span>(col &lt; x.<a class="code" href="a00174.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>-1)
<a name="l01928"></a>01928       {
<a name="l01929"></a>01929       f &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l01930"></a>01930       }
<a name="l01931"></a>01931     <span class="keywordflow">else</span>
<a name="l01932"></a>01932       {
<a name="l01933"></a>01933       f &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01934"></a>01934       }
<a name="l01935"></a>01935     }
<a name="l01936"></a>01936   
<a name="l01937"></a>01937   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01938"></a>01938   
<a name="l01939"></a>01939   <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, name );
<a name="l01940"></a>01940   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6026e50ca294ce23eb2bef6f4e3765e4"></a><!-- doxytag: member="diskio::load_std_string" ref="ga6026e50ca294ce23eb2bef6f4e3765e4" args="(field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_std_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01946">1946</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>.</p>

<p>Referenced by <a class="el" href="a00556_source.html#l01547">field_aux::load()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01947"></a>01947   {
<a name="l01948"></a>01948   arma_extra_debug_sigprint();
<a name="l01949"></a>01949   
<a name="l01950"></a>01950   std::ifstream f( name.c_str() );
<a name="l01951"></a>01951   
<a name="l01952"></a>01952   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01953"></a>01953     {
<a name="l01954"></a>01954     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01955"></a>01955     }
<a name="l01956"></a>01956   <span class="keywordflow">else</span>
<a name="l01957"></a>01957     {
<a name="l01958"></a>01958     <a class="code" href="a00750.html#ga6026e50ca294ce23eb2bef6f4e3765e4">diskio::load_std_string</a>(x, name, f);
<a name="l01959"></a>01959     
<a name="l01960"></a>01960     f.close();
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga88c8465f9470e0b80f0abb1c4ca6ca1f"></a><!-- doxytag: member="diskio::load_std_string" ref="ga88c8465f9470e0b80f0abb1c4ca6ca1f" args="(field&lt; std::string &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_std_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l01968">1968</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00556_source.html#l00267">field&lt; oT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00557_source.html#l00034">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00557_source.html#l00033">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00556_source.html#l00536">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00556_source.html#l00158">field&lt; oT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01969"></a>01969   {
<a name="l01970"></a>01970   arma_extra_debug_sigprint();
<a name="l01971"></a>01971   
<a name="l01972"></a>01972   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01973"></a>01973   
<a name="l01974"></a>01974   <span class="comment">//</span>
<a name="l01975"></a>01975   <span class="comment">// work out the size</span>
<a name="l01976"></a>01976   
<a name="l01977"></a>01977   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01978"></a>01978   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01979"></a>01979   
<a name="l01980"></a>01980   <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l01981"></a>01981   
<a name="l01982"></a>01982   std::string line_string;
<a name="l01983"></a>01983   std::string token;
<a name="l01984"></a>01984   
<a name="l01985"></a>01985   <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l01986"></a>01986     {
<a name="l01987"></a>01987     std::getline(f, line_string);
<a name="l01988"></a>01988     <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l01989"></a>01989       <span class="keywordflow">break</span>;
<a name="l01990"></a>01990     
<a name="l01991"></a>01991     std::stringstream line_stream(line_string);
<a name="l01992"></a>01992     
<a name="l01993"></a>01993     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l01994"></a>01994     <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l01995"></a>01995       line_n_cols++;
<a name="l01996"></a>01996     
<a name="l01997"></a>01997     <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l01998"></a>01998       {
<a name="l01999"></a>01999       f_n_cols = line_n_cols;
<a name="l02000"></a>02000       f_n_cols_found = <span class="keyword">true</span>;
<a name="l02001"></a>02001       }
<a name="l02002"></a>02002     <span class="keywordflow">else</span>
<a name="l02003"></a>02003       {
<a name="l02004"></a>02004       <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l02005"></a>02005         {
<a name="l02006"></a>02006         load_okay = <span class="keyword">false</span>;
<a name="l02007"></a>02007         <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;inconsistent number of columns in &quot;</span>, name );
<a name="l02008"></a>02008         }
<a name="l02009"></a>02009       }
<a name="l02010"></a>02010     
<a name="l02011"></a>02011     ++f_n_rows;
<a name="l02012"></a>02012     }
<a name="l02013"></a>02013     
<a name="l02014"></a>02014   <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l02015"></a>02015     {
<a name="l02016"></a>02016     f.clear();
<a name="l02017"></a>02017     f.seekg(0, ios::beg);
<a name="l02018"></a>02018     <span class="comment">//f.seekg(start);</span>
<a name="l02019"></a>02019     
<a name="l02020"></a>02020     x.<a class="code" href="a00762.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l02021"></a>02021   
<a name="l02022"></a>02022     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00174.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l02023"></a>02023       {
<a name="l02024"></a>02024       <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00174.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l02025"></a>02025         {
<a name="l02026"></a>02026         f &gt;&gt; x.<a class="code" href="a00762.html#ga0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l02027"></a>02027         }
<a name="l02028"></a>02028       }
<a name="l02029"></a>02029     }
<a name="l02030"></a>02030   
<a name="l02031"></a>02031   <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l02032"></a>02032     {
<a name="l02033"></a>02033     load_okay = <span class="keyword">false</span>; 
<a name="l02034"></a>02034     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name );
<a name="l02035"></a>02035     }
<a name="l02036"></a>02036   
<a name="l02037"></a>02037   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l02038"></a>02038     {
<a name="l02039"></a>02039     x.<a class="code" href="a00762.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l02040"></a>02040     }
<a name="l02041"></a>02041   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac66e6e0cc9f7ef2a6bb1fadab19e90f9"></a><!-- doxytag: member="diskio::load_auto_detect" ref="gac66e6e0cc9f7ef2a6bb1fadab19e90f9" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a <a class="el" href="a00174.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l02049">2049</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00535_source.html#l01197">load_auto_detect()</a>, and <a class="el" href="a00556_source.html#l00536">field&lt; oT &gt;::reset()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02050"></a>02050   {
<a name="l02051"></a>02051   arma_extra_debug_sigprint();
<a name="l02052"></a>02052   
<a name="l02053"></a>02053   std::fstream f;
<a name="l02054"></a>02054   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l02055"></a>02055   
<a name="l02056"></a>02056   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02057"></a>02057     {
<a name="l02058"></a>02058     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l02059"></a>02059     x.<a class="code" href="a00762.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l02060"></a>02060     }
<a name="l02061"></a>02061   <span class="keywordflow">else</span>
<a name="l02062"></a>02062     {
<a name="l02063"></a>02063     <a class="code" href="a00750.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" title="Try to load a matrix by automatically determining its type.">diskio::load_auto_detect</a>(x, name, f); <span class="comment">// Do the actual load</span>
<a name="l02064"></a>02064     f.close();
<a name="l02065"></a>02065     }
<a name="l02066"></a>02066   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac311a46b9e74a0c08efee514e70d2832"></a><!-- doxytag: member="diskio::load_auto_detect" ref="gac311a46b9e74a0c08efee514e70d2832" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a <a class="el" href="a00174.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00535_source.html#l02074">2074</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00952">load_arma_binary()</a>, <a class="el" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>, and <a class="el" href="a00556_source.html#l00536">field&lt; oT &gt;::reset()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02075"></a>02075   {
<a name="l02076"></a>02076   arma_extra_debug_sigprint();
<a name="l02077"></a>02077   
<a name="l02078"></a>02078   <a class="code" href="a00043.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l02079"></a>02079   
<a name="l02080"></a>02080   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_FLD_BIN = <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span>;
<a name="l02081"></a>02081   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P6 = <span class="stringliteral">&quot;P6&quot;</span>;
<a name="l02082"></a>02082   
<a name="l02083"></a>02083   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_FLD_BIN.length() + 1);
<a name="l02084"></a>02084   
<a name="l02085"></a>02085   std::streampos pos = f.tellg();
<a name="l02086"></a>02086   
<a name="l02087"></a>02087   f.read(raw_header.memptr(), ARMA_FLD_BIN.length());
<a name="l02088"></a>02088   
<a name="l02089"></a>02089   f.clear();
<a name="l02090"></a>02090   f.seekg(pos);
<a name="l02091"></a>02091   
<a name="l02092"></a>02092   raw_header[ARMA_FLD_BIN.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l02093"></a>02093   
<a name="l02094"></a>02094   <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l02095"></a>02095   
<a name="l02096"></a>02096   <span class="keywordflow">if</span>(ARMA_FLD_BIN == header.substr(0,ARMA_FLD_BIN.length()))
<a name="l02097"></a>02097     {
<a name="l02098"></a>02098     <a class="code" href="a00750.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name, f);
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100   <span class="keywordflow">else</span>
<a name="l02101"></a>02101   <span class="keywordflow">if</span>(P6 == header.substr(0,P6.length()))
<a name="l02102"></a>02102     {
<a name="l02103"></a>02103     <a class="code" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary</a>(x, name, f);
<a name="l02104"></a>02104     }
<a name="l02105"></a>02105   <span class="keywordflow">else</span>
<a name="l02106"></a>02106     {
<a name="l02107"></a>02107     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l02108"></a>02108     x.<a class="code" href="a00762.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l02109"></a>02109     }
<a name="l02110"></a>02110   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gade8fe65bb50cb3e7bb9129ff4af773ed"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="gade8fe65bb50cb3e7bb9129ff4af773ed" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02121">2121</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02122"></a>02122   {
<a name="l02123"></a>02123   arma_extra_debug_sigprint();
<a name="l02124"></a>02124   
<a name="l02125"></a>02125   std::fstream f;
<a name="l02126"></a>02126   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l02127"></a>02127   
<a name="l02128"></a>02128   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02129"></a>02129     {
<a name="l02130"></a>02130     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l02131"></a>02131     }
<a name="l02132"></a>02132   <span class="keywordflow">else</span>
<a name="l02133"></a>02133     {
<a name="l02134"></a>02134     <a class="code" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">diskio::load_ppm_binary</a>(x, name, f);
<a name="l02135"></a>02135     f.close();
<a name="l02136"></a>02136     }
<a name="l02137"></a>02137   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaee968268402aa8ff924b4930d86e79c8"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="gaee968268402aa8ff924b4930d86e79c8" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02144">2144</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00529_source.html#l01375">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00701_source.html#l00209">podarray&lt; eT &gt;::memptr()</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00535_source.html#l01020">pnm_skip_comments()</a>, <a class="el" href="a00529_source.html#l01714">Cube&lt; eT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00529_source.html#l01611">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02145"></a>02145   {
<a name="l02146"></a>02146   arma_extra_debug_sigprint();
<a name="l02147"></a>02147   
<a name="l02148"></a>02148   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l02149"></a>02149   
<a name="l02150"></a>02150   std::string f_header;
<a name="l02151"></a>02151   f &gt;&gt; f_header;
<a name="l02152"></a>02152   
<a name="l02153"></a>02153   <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P6&quot;</span>)
<a name="l02154"></a>02154     {
<a name="l02155"></a>02155     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l02156"></a>02156     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l02157"></a>02157     <span class="keywordtype">int</span> f_maxval = 0;
<a name="l02158"></a>02158   
<a name="l02159"></a>02159     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02160"></a>02160   
<a name="l02161"></a>02161     f &gt;&gt; f_n_cols;
<a name="l02162"></a>02162     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02163"></a>02163   
<a name="l02164"></a>02164     f &gt;&gt; f_n_rows;
<a name="l02165"></a>02165     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02166"></a>02166   
<a name="l02167"></a>02167     f &gt;&gt; f_maxval;
<a name="l02168"></a>02168     f.get();
<a name="l02169"></a>02169     
<a name="l02170"></a>02170     <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l02171"></a>02171       {
<a name="l02172"></a>02172       x.<a class="code" href="a00746.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, 3);
<a name="l02173"></a>02173       
<a name="l02174"></a>02174       <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l02175"></a>02175         {
<a name="l02176"></a>02176         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02177"></a>02177         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02178"></a>02178         
<a name="l02179"></a>02179         f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l02180"></a>02180         
<a name="l02181"></a>02181         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02182"></a>02182         
<a name="l02183"></a>02183         <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l02184"></a>02184         <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l02185"></a>02185         
<a name="l02186"></a>02186         
<a name="l02187"></a>02187         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02188"></a>02188           {
<a name="l02189"></a>02189           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02190"></a>02190             {
<a name="l02191"></a>02191             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) = eT(tmp[i+0]);
<a name="l02192"></a>02192             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) = eT(tmp[i+1]);
<a name="l02193"></a>02193             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) = eT(tmp[i+2]);
<a name="l02194"></a>02194             i+=3;
<a name="l02195"></a>02195             }
<a name="l02196"></a>02196           
<a name="l02197"></a>02197           }
<a name="l02198"></a>02198         }
<a name="l02199"></a>02199       <span class="keywordflow">else</span>
<a name="l02200"></a>02200         {
<a name="l02201"></a>02201         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02202"></a>02202         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l02203"></a>02203         
<a name="l02204"></a>02204         f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), 2*n_elem);
<a name="l02205"></a>02205         
<a name="l02206"></a>02206         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02207"></a>02207         
<a name="l02208"></a>02208         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02209"></a>02209           {
<a name="l02210"></a>02210           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02211"></a>02211             {
<a name="l02212"></a>02212             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) = eT(tmp[i+0]);
<a name="l02213"></a>02213             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) = eT(tmp[i+1]);
<a name="l02214"></a>02214             x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) = eT(tmp[i+2]);
<a name="l02215"></a>02215             i+=3;
<a name="l02216"></a>02216             }
<a name="l02217"></a>02217           
<a name="l02218"></a>02218           }
<a name="l02219"></a>02219         
<a name="l02220"></a>02220         }
<a name="l02221"></a>02221       
<a name="l02222"></a>02222       }
<a name="l02223"></a>02223     
<a name="l02224"></a>02224     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l02225"></a>02225       {
<a name="l02226"></a>02226       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l02227"></a>02227       load_okay = <span class="keyword">false</span>;
<a name="l02228"></a>02228       }
<a name="l02229"></a>02229     
<a name="l02230"></a>02230     }
<a name="l02231"></a>02231   <span class="keywordflow">else</span>
<a name="l02232"></a>02232     {
<a name="l02233"></a>02233     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l02234"></a>02234     load_okay = <span class="keyword">false</span>;
<a name="l02235"></a>02235     }
<a name="l02236"></a>02236   
<a name="l02237"></a>02237   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l02238"></a>02238     {
<a name="l02239"></a>02239     x.<a class="code" href="a00746.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l02240"></a>02240     }
<a name="l02241"></a>02241   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga287ba6a07f728ff3e54db5a1fe8bfd16"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ga287ba6a07f728ff3e54db5a1fe8bfd16" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02248">2248</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00081.html#af845ebd21d586efa4d5589e8f40ac877">save_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02249"></a>02249   {
<a name="l02250"></a>02250   arma_extra_debug_sigprint();
<a name="l02251"></a>02251 
<a name="l02252"></a>02252   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l02253"></a>02253   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l02254"></a>02254   
<a name="l02255"></a>02255   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02256"></a>02256     {
<a name="l02257"></a>02257     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l02258"></a>02258     }
<a name="l02259"></a>02259   <span class="keywordflow">else</span>
<a name="l02260"></a>02260     {
<a name="l02261"></a>02261     <a class="code" href="a00081.html#af845ebd21d586efa4d5589e8f40ac877">diskio::save_ppm_binary</a>(x, tmp_name, f);
<a name="l02262"></a>02262     
<a name="l02263"></a>02263     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02264"></a>02264     f.flush();
<a name="l02265"></a>02265     f.close();
<a name="l02266"></a>02266     
<a name="l02267"></a>02267     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l02268"></a>02268       {
<a name="l02269"></a>02269       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l02270"></a>02270       }
<a name="l02271"></a>02271     }
<a name="l02272"></a>02272   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab538f2fab00fbd59001b2a957994f5a4"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="gab538f2fab00fbd59001b2a957994f5a4" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00068.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02279">2279</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00529_source.html#l01375">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00702_source.html#l00030">podarray&lt; eT &gt;::mem</a>, <a class="el" href="a00530_source.html#l00031">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00530_source.html#l00030">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00530_source.html#l00033">Cube&lt; eT &gt;::n_slices</a>, and <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02280"></a>02280   {
<a name="l02281"></a>02281   arma_extra_debug_sigprint();
<a name="l02282"></a>02282   
<a name="l02283"></a>02283   arma_debug_check( (x.<a class="code" href="a00068.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> != 3), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given cube must have exactly 3 slices&quot;</span> );
<a name="l02284"></a>02284   
<a name="l02285"></a>02285   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3 * x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> * x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>;
<a name="l02286"></a>02286   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02287"></a>02287 
<a name="l02288"></a>02288   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02289"></a>02289   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l02290"></a>02290     {
<a name="l02291"></a>02291     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l02292"></a>02292       {
<a name="l02293"></a>02293       tmp[i+0] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) );
<a name="l02294"></a>02294       tmp[i+1] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) );
<a name="l02295"></a>02295       tmp[i+2] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00746.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) );
<a name="l02296"></a>02296       
<a name="l02297"></a>02297       i+=3;
<a name="l02298"></a>02298       }
<a name="l02299"></a>02299     }
<a name="l02300"></a>02300   
<a name="l02301"></a>02301   f &lt;&lt; <span class="stringliteral">&quot;P6&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02302"></a>02302   f &lt;&lt; x.<a class="code" href="a00068.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02303"></a>02303   f &lt;&lt; x.<a class="code" href="a00068.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02304"></a>02304   f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02305"></a>02305 
<a name="l02306"></a>02306   f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l02307"></a>02307   
<a name="l02308"></a>02308   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02309"></a>02309   
<a name="l02310"></a>02310   <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, name );
<a name="l02311"></a>02311   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga589a30dc9494f1b2780682cf78757f0e"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="ga589a30dc9494f1b2780682cf78757f0e" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02318">2318</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02319"></a>02319   {
<a name="l02320"></a>02320   arma_extra_debug_sigprint();
<a name="l02321"></a>02321   
<a name="l02322"></a>02322   std::fstream f;
<a name="l02323"></a>02323   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l02324"></a>02324   
<a name="l02325"></a>02325   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02326"></a>02326     {
<a name="l02327"></a>02327     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l02328"></a>02328     }
<a name="l02329"></a>02329   <span class="keywordflow">else</span>
<a name="l02330"></a>02330     {
<a name="l02331"></a>02331     <a class="code" href="a00081.html#af99253ff5b74b240b49de9be42a5569d">diskio::load_ppm_binary</a>(x, name, f);
<a name="l02332"></a>02332     f.close();
<a name="l02333"></a>02333     }
<a name="l02334"></a>02334   }  
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga36dd686cde27c25a4cfb2025dfd80620"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="ga36dd686cde27c25a4cfb2025dfd80620" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02341">2341</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00701_source.html#l00209">podarray&lt; eT &gt;::memptr()</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00535_source.html#l01020">pnm_skip_comments()</a>, <a class="el" href="a00556_source.html#l00536">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, <a class="el" href="a00632_source.html#l02267">Mat&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00556_source.html#l00158">field&lt; oT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02342"></a>02342   {
<a name="l02343"></a>02343   arma_extra_debug_sigprint();
<a name="l02344"></a>02344   
<a name="l02345"></a>02345   <a class="code" href="a00043.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l02346"></a>02346   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l02347"></a>02347   
<a name="l02348"></a>02348   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l02349"></a>02349   
<a name="l02350"></a>02350   std::string f_header;
<a name="l02351"></a>02351   f &gt;&gt; f_header;
<a name="l02352"></a>02352   
<a name="l02353"></a>02353   <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P6&quot;</span>)
<a name="l02354"></a>02354     {
<a name="l02355"></a>02355     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l02356"></a>02356     <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l02357"></a>02357     <span class="keywordtype">int</span> f_maxval = 0;
<a name="l02358"></a>02358   
<a name="l02359"></a>02359     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02360"></a>02360   
<a name="l02361"></a>02361     f &gt;&gt; f_n_cols;
<a name="l02362"></a>02362     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02363"></a>02363   
<a name="l02364"></a>02364     f &gt;&gt; f_n_rows;
<a name="l02365"></a>02365     <a class="code" href="a00750.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02366"></a>02366   
<a name="l02367"></a>02367     f &gt;&gt; f_maxval;
<a name="l02368"></a>02368     f.get();
<a name="l02369"></a>02369     
<a name="l02370"></a>02370     <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l02371"></a>02371       {
<a name="l02372"></a>02372       x.<a class="code" href="a00762.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(3);
<a name="l02373"></a>02373       <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l02374"></a>02374       <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l02375"></a>02375       <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l02376"></a>02376       
<a name="l02377"></a>02377       R.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02378"></a>02378       G.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02379"></a>02379       B.<a class="code" href="a00827.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02380"></a>02380       
<a name="l02381"></a>02381       <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l02382"></a>02382         {
<a name="l02383"></a>02383         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02384"></a>02384         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02385"></a>02385         
<a name="l02386"></a>02386         f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l02387"></a>02387         
<a name="l02388"></a>02388         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02389"></a>02389         
<a name="l02390"></a>02390         <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l02391"></a>02391         <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l02392"></a>02392         
<a name="l02393"></a>02393         
<a name="l02394"></a>02394         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02395"></a>02395           {
<a name="l02396"></a>02396           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02397"></a>02397             {
<a name="l02398"></a>02398             R.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l02399"></a>02399             G.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l02400"></a>02400             B.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l02401"></a>02401             i+=3;
<a name="l02402"></a>02402             }
<a name="l02403"></a>02403           
<a name="l02404"></a>02404           }
<a name="l02405"></a>02405         }
<a name="l02406"></a>02406       <span class="keywordflow">else</span>
<a name="l02407"></a>02407         {
<a name="l02408"></a>02408         <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02409"></a>02409         <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l02410"></a>02410         
<a name="l02411"></a>02411         f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), 2*n_elem);
<a name="l02412"></a>02412         
<a name="l02413"></a>02413         <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02414"></a>02414         
<a name="l02415"></a>02415         <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02416"></a>02416           {
<a name="l02417"></a>02417           <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02418"></a>02418             {
<a name="l02419"></a>02419             R.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l02420"></a>02420             G.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l02421"></a>02421             B.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l02422"></a>02422             i+=3;
<a name="l02423"></a>02423             }
<a name="l02424"></a>02424           
<a name="l02425"></a>02425           }
<a name="l02426"></a>02426         
<a name="l02427"></a>02427         }
<a name="l02428"></a>02428       
<a name="l02429"></a>02429       }
<a name="l02430"></a>02430     
<a name="l02431"></a>02431     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l02432"></a>02432       {
<a name="l02433"></a>02433       <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l02434"></a>02434       load_okay = <span class="keyword">false</span>;
<a name="l02435"></a>02435       }
<a name="l02436"></a>02436     
<a name="l02437"></a>02437     }
<a name="l02438"></a>02438   <span class="keywordflow">else</span>
<a name="l02439"></a>02439     {
<a name="l02440"></a>02440     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l02441"></a>02441     load_okay = <span class="keyword">false</span>;
<a name="l02442"></a>02442     }
<a name="l02443"></a>02443   
<a name="l02444"></a>02444   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l02445"></a>02445     {
<a name="l02446"></a>02446     x.<a class="code" href="a00762.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l02447"></a>02447     }
<a name="l02448"></a>02448   
<a name="l02449"></a>02449   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga23d4e3f45a86ec0440b4d99450f38b20"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ga23d4e3f45a86ec0440b4d99450f38b20" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02456">2456</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00049">arma_print()</a>, <a class="el" href="a00535_source.html#l00356">gen_tmp_name()</a>, <a class="el" href="a00535_source.html#l00420">safe_rename()</a>, and <a class="el" href="a00081.html#af845ebd21d586efa4d5589e8f40ac877">save_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02457"></a>02457   {
<a name="l02458"></a>02458   arma_extra_debug_sigprint();
<a name="l02459"></a>02459   
<a name="l02460"></a>02460   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00750.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l02461"></a>02461   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l02462"></a>02462   
<a name="l02463"></a>02463   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02464"></a>02464     {
<a name="l02465"></a>02465     <a class="code" href="a00747.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l02466"></a>02466     }
<a name="l02467"></a>02467   <span class="keywordflow">else</span>
<a name="l02468"></a>02468     {
<a name="l02469"></a>02469     <a class="code" href="a00081.html#af845ebd21d586efa4d5589e8f40ac877">diskio::save_ppm_binary</a>(x, tmp_name, f);
<a name="l02470"></a>02470     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02471"></a>02471     
<a name="l02472"></a>02472     f.flush();
<a name="l02473"></a>02473     f.close();
<a name="l02474"></a>02474     
<a name="l02475"></a>02475     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l02476"></a>02476       {
<a name="l02477"></a>02477       <a class="code" href="a00750.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l02478"></a>02478       }
<a name="l02479"></a>02479     }
<a name="l02480"></a>02480   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga95b13bdcabd10a5e72270d52d134cc76"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ga95b13bdcabd10a5e72270d52d134cc76" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00174.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00535_source.html#l02487">2487</a> of file <a class="el" href="a00535_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00531_source.html#l00183">arma_warn()</a>, <a class="el" href="a00632_source.html#l01938">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00632_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00702_source.html#l00030">podarray&lt; eT &gt;::mem</a>, <a class="el" href="a00633_source.html#l00031">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00633_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00557_source.html#l00035">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00633_source.html#l00030">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00632_source.html#l01042">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00512_source.html#l00029">access::tmp_real()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02488"></a>02488   {
<a name="l02489"></a>02489   arma_extra_debug_sigprint();
<a name="l02490"></a>02490   
<a name="l02491"></a>02491   <a class="code" href="a00043.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l02492"></a>02492   
<a name="l02493"></a>02493   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l02494"></a>02494   
<a name="l02495"></a>02495   arma_debug_check( (x.<a class="code" href="a00174.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a> != 3), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given field must have exactly 3 matrices of equal size&quot;</span> );
<a name="l02496"></a>02496   
<a name="l02497"></a>02497   <span class="keywordtype">bool</span> same_size = <span class="keyword">true</span>;
<a name="l02498"></a>02498   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=1; i&lt;3; ++i)
<a name="l02499"></a>02499     {
<a name="l02500"></a>02500     <span class="keywordflow">if</span>( (x(0).n_rows != x(i).n_rows) || (x(0).n_cols != x(i).n_cols) )
<a name="l02501"></a>02501       {
<a name="l02502"></a>02502       same_size = <span class="keyword">false</span>;
<a name="l02503"></a>02503       <span class="keywordflow">break</span>;
<a name="l02504"></a>02504       }
<a name="l02505"></a>02505     }
<a name="l02506"></a>02506   
<a name="l02507"></a>02507   arma_debug_check( (same_size != <span class="keyword">true</span>), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given field must have exactly 3 matrices of equal size&quot;</span> );
<a name="l02508"></a>02508   
<a name="l02509"></a>02509   <span class="keyword">const</span> <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l02510"></a>02510   <span class="keyword">const</span> <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l02511"></a>02511   <span class="keyword">const</span> <a class="code" href="a00308.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l02512"></a>02512   
<a name="l02513"></a>02513   f &lt;&lt; <span class="stringliteral">&quot;P6&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02514"></a>02514   f &lt;&lt; R.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02515"></a>02515   f &lt;&lt; R.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02516"></a>02516   f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02517"></a>02517 
<a name="l02518"></a>02518   <span class="keyword">const</span> <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3 * R.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * R.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l02519"></a>02519   <a class="code" href="a00375.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02520"></a>02520 
<a name="l02521"></a>02521   <a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02522"></a>02522   <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; R.<a class="code" href="a00308.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l02523"></a>02523     {
<a name="l02524"></a>02524     <span class="keywordflow">for</span>(<a class="code" href="a00883.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; R.<a class="code" href="a00308.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l02525"></a>02525       {
<a name="l02526"></a>02526       tmp[i+0] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( <a class="code" href="a00001.html#aac9636dfb53af3f6e459c4e4a9029c69" title="internal function to obtain the real part of either a plain number or a complex number...">access::tmp_real</a>( R.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) ) );
<a name="l02527"></a>02527       tmp[i+1] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( <a class="code" href="a00001.html#aac9636dfb53af3f6e459c4e4a9029c69" title="internal function to obtain the real part of either a plain number or a complex number...">access::tmp_real</a>( G.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) ) );
<a name="l02528"></a>02528       tmp[i+2] = <a class="code" href="a00883.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( <a class="code" href="a00001.html#aac9636dfb53af3f6e459c4e4a9029c69" title="internal function to obtain the real part of either a plain number or a complex number...">access::tmp_real</a>( B.<a class="code" href="a00827.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) ) );
<a name="l02529"></a>02529       
<a name="l02530"></a>02530       i+=3;
<a name="l02531"></a>02531       }
<a name="l02532"></a>02532     }
<a name="l02533"></a>02533   
<a name="l02534"></a>02534   f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l02535"></a>02535   
<a name="l02536"></a>02536   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02537"></a>02537   
<a name="l02538"></a>02538   <a class="code" href="a00747.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, name );
<a name="l02539"></a>02539   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
