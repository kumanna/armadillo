<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Op_dot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Op_dot</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.html">op_dot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dot product operation  <a href="a00312.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00322.html">op_norm_dot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">normalised dot product operation  <a href="a00322.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_pure eT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#gad6e8af2a02ebbec85f085882ff3f3d68">op_dot::direct_dot</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem, const eT *const A, const eT *const B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for two arrays  <a href="#gad6e8af2a02ebbec85f085882ff3f3d68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_pure eT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#gaadc393f3b56dc5fc1eb9e832f4bee48d">op_dot::direct_dot</a> (const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem, const eT *const A, const eT *const B, const eT *C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for three arrays  <a href="#gaadc393f3b56dc5fc1eb9e832f4bee48d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline static arma_hot <br class="typebreak"/>
T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#ga0ea530ac5cec37677ffb2913dc5e701d">op_dot::apply</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#gad5ee317edec298d72f10d2c60e82b880">op_dot::apply_unwrap</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#gaf9f7ac52f729be81da8f095d91c2889f">op_dot::apply_proxy</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_inline static arma_hot <br class="typebreak"/>
T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#ga8a7b499f986157d99c2abcc92043f1e9">op_norm_dot::apply</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#ga9b76380ec9ac6e56e80166dc461eae45">op_norm_dot::apply_unwrap</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00812.html#gaa2ba83902c86d2c0b5a016187223d9b3">op_norm_dot::apply_proxy</a> (const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad6e8af2a02ebbec85f085882ff3f3d68"></a><!-- doxytag: member="op_dot::direct_dot" ref="gad6e8af2a02ebbec85f085882ff3f3d68" args="(const u32 n_elem, const eT *const A, const eT *const B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_pure eT op_dot::direct_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>n_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for two arrays </p>

<p>Definition at line <a class="el" href="a00630_source.html#l00028">28</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00555_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00555_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00630_source.html#l00098">apply_unwrap()</a>, <a class="el" href="a00555_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00632_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, and <a class="el" href="a00632_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00029"></a>00029   {
<a name="l00030"></a>00030   arma_extra_debug_sigprint();
<a name="l00031"></a>00031   
<a name="l00032"></a>00032   eT val1 = eT(0);
<a name="l00033"></a>00033   eT val2 = eT(0);
<a name="l00034"></a>00034   
<a name="l00035"></a>00035   <a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i,j;
<a name="l00036"></a>00036   <span class="keywordflow">for</span>(i=0, j=1; j&lt;n_elem; i+=2, j+=2)
<a name="l00037"></a>00037     {
<a name="l00038"></a>00038     val1 += A[i] * B[i];
<a name="l00039"></a>00039     val2 += A[j] * B[j];
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041   
<a name="l00042"></a>00042   <span class="keywordflow">if</span>(i &lt; n_elem)
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044     val1 += A[i] * B[i];
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046   
<a name="l00047"></a>00047   <span class="keywordflow">return</span> val1+val2;
<a name="l00048"></a>00048   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaadc393f3b56dc5fc1eb9e832f4bee48d"></a><!-- doxytag: member="op_dot::direct_dot" ref="gaadc393f3b56dc5fc1eb9e832f4bee48d" args="(const u32 n_elem, const eT *const A, const eT *const B, const eT *C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_pure eT op_dot::direct_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>n_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for three arrays </p>

<p>Definition at line <a class="el" href="a00630_source.html#l00058">58</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00059"></a>00059   {
<a name="l00060"></a>00060   arma_extra_debug_sigprint();
<a name="l00061"></a>00061   
<a name="l00062"></a>00062   eT val = eT(0);
<a name="l00063"></a>00063   
<a name="l00064"></a>00064   <span class="keywordflow">for</span>(<a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00065"></a>00065     {
<a name="l00066"></a>00066     val += A[i] * B[i] * C[i];
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   <span class="keywordflow">return</span> val;
<a name="l00070"></a>00070   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0ea530ac5cec37677ffb2913dc5e701d"></a><!-- doxytag: member="op_dot::apply" ref="ga0ea530ac5cec37677ffb2913dc5e701d" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline arma_hot T1::elem_type op_dot::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00078">78</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00630_source.html#l00121">apply_proxy()</a>, and <a class="el" href="a00630_source.html#l00098">apply_unwrap()</a>.</p>

<p>Referenced by <a class="el" href="a00563_source.html#l00024">dot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00079"></a>00079   {
<a name="l00080"></a>00080   arma_extra_debug_sigprint();
<a name="l00081"></a>00081   
<a name="l00082"></a>00082   <span class="keywordflow">if</span>( (<a class="code" href="a00239.html">is_Mat&lt;T1&gt;::value</a> == <span class="keyword">true</span>) &amp;&amp; (<a class="code" href="a00239.html">is_Mat&lt;T2&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00083"></a>00083     {
<a name="l00084"></a>00084     <span class="keywordflow">return</span> <a class="code" href="a00812.html#gad5ee317edec298d72f10d2c60e82b880">op_dot::apply_unwrap</a>(X,Y);
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086   <span class="keywordflow">else</span>
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088     <span class="keywordflow">return</span> <a class="code" href="a00812.html#gaf9f7ac52f729be81da8f095d91c2889f">op_dot::apply_proxy</a>(X,Y);
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad5ee317edec298d72f10d2c60e82b880"></a><!-- doxytag: member="op_dot::apply_unwrap" ref="gad5ee317edec298d72f10d2c60e82b880" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline arma_hot T1::elem_type op_dot::apply_unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00098">98</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00630_source.html#l00028">direct_dot()</a>, <a class="el" href="a00516_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, <a class="el" href="a00621_source.html#l00035">Mat&lt; eT &gt;::mem</a>, and <a class="el" href="a00621_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00630_source.html#l00078">apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00099"></a>00099   {
<a name="l00100"></a>00100   arma_extra_debug_sigprint();
<a name="l00101"></a>00101   
<a name="l00102"></a>00102   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00103"></a>00103   
<a name="l00104"></a>00104   <span class="keyword">const</span> <a class="code" href="a00484.html">unwrap&lt;T1&gt;</a> tmp1(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00105"></a>00105   <span class="keyword">const</span> <a class="code" href="a00484.html">unwrap&lt;T2&gt;</a> tmp2(Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00106"></a>00106   
<a name="l00107"></a>00107   <span class="keyword">const</span> <a class="code" href="a00303.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; A = tmp1.M;
<a name="l00108"></a>00108   <span class="keyword">const</span> <a class="code" href="a00303.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = tmp2.M;
<a name="l00109"></a>00109   
<a name="l00110"></a>00110   arma_debug_check( (A.n_elem != B.<a class="code" href="a00303.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>), <span class="stringliteral">&quot;dot(): objects must have the same number of elements&quot;</span> );
<a name="l00111"></a>00111   
<a name="l00112"></a>00112   <span class="keywordflow">return</span> <a class="code" href="a00812.html#gad6e8af2a02ebbec85f085882ff3f3d68" title="for two arrays">op_dot::direct_dot</a>(A.n_elem, A.mem, B.<a class="code" href="a00303.html#a14a6badc8098d810e5decb22272a07b0" title="pointer to the memory used by the matrix (memory is read-only)">mem</a>);
<a name="l00113"></a>00113   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf9f7ac52f729be81da8f095d91c2889f"></a><!-- doxytag: member="op_dot::apply_proxy" ref="gaf9f7ac52f729be81da8f095d91c2889f" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_dot::apply_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00121">121</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00516_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p>Referenced by <a class="el" href="a00630_source.html#l00078">apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00122"></a>00122   {
<a name="l00123"></a>00123   arma_extra_debug_sigprint();
<a name="l00124"></a>00124   
<a name="l00125"></a>00125   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00126"></a>00126   
<a name="l00127"></a>00127   <span class="keyword">const</span> <a class="code" href="a00449.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00128"></a>00128   <span class="keyword">const</span> <a class="code" href="a00449.html">Proxy&lt;T2&gt;</a> B(Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00129"></a>00129   
<a name="l00130"></a>00130   arma_debug_check( (A.n_elem != B.n_elem), <span class="stringliteral">&quot;dot(): objects must have the same number of elements&quot;</span> );
<a name="l00131"></a>00131   
<a name="l00132"></a>00132   <span class="keyword">const</span> <a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = A.n_elem;
<a name="l00133"></a>00133   eT val = eT(0);
<a name="l00134"></a>00134   
<a name="l00135"></a>00135   <span class="keywordflow">for</span>(<a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137     val += A[i] * B[i];
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139   
<a name="l00140"></a>00140   <span class="keywordflow">return</span> val;
<a name="l00141"></a>00141   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8a7b499f986157d99c2abcc92043f1e9"></a><!-- doxytag: member="op_norm_dot::apply" ref="ga8a7b499f986157d99c2abcc92043f1e9" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_inline arma_hot T1::elem_type op_norm_dot::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00153">153</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00630_source.html#l00215">op_norm_dot::apply_proxy()</a>, and <a class="el" href="a00630_source.html#l00173">op_norm_dot::apply_unwrap()</a>.</p>

<p>Referenced by <a class="el" href="a00563_source.html#l00036">norm_dot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00154"></a>00154   {
<a name="l00155"></a>00155   arma_extra_debug_sigprint();
<a name="l00156"></a>00156   
<a name="l00157"></a>00157   <span class="keywordflow">if</span>( (<a class="code" href="a00239.html">is_Mat&lt;T1&gt;::value</a> == <span class="keyword">true</span>) &amp;&amp; (<a class="code" href="a00239.html">is_Mat&lt;T2&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159     <span class="keywordflow">return</span> <a class="code" href="a00812.html#ga9b76380ec9ac6e56e80166dc461eae45">op_norm_dot::apply_unwrap</a>(X,Y);
<a name="l00160"></a>00160     }
<a name="l00161"></a>00161   <span class="keywordflow">else</span>
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163     <span class="keywordflow">return</span> <a class="code" href="a00812.html#gaa2ba83902c86d2c0b5a016187223d9b3">op_norm_dot::apply_proxy</a>(X,Y);
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9b76380ec9ac6e56e80166dc461eae45"></a><!-- doxytag: member="op_norm_dot::apply_unwrap" ref="ga9b76380ec9ac6e56e80166dc461eae45" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_norm_dot::apply_unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00173">173</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00516_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, <a class="el" href="a00620_source.html#l02081">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00621_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00576_source.html#l00579">sqrt()</a>.</p>

<p>Referenced by <a class="el" href="a00630_source.html#l00153">op_norm_dot::apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00174"></a>00174   {
<a name="l00175"></a>00175   arma_extra_debug_sigprint();
<a name="l00176"></a>00176   
<a name="l00177"></a>00177   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00178"></a>00178   
<a name="l00179"></a>00179   <span class="keyword">const</span> <a class="code" href="a00484.html">unwrap&lt;T1&gt;</a> tmp1(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00180"></a>00180   <span class="keyword">const</span> <a class="code" href="a00484.html">unwrap&lt;T2&gt;</a> tmp2(Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00181"></a>00181   
<a name="l00182"></a>00182   <span class="keyword">const</span> <a class="code" href="a00303.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; A = tmp1.M;
<a name="l00183"></a>00183   <span class="keyword">const</span> <a class="code" href="a00303.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = tmp2.M;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   arma_debug_check( (A.n_elem != B.<a class="code" href="a00303.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>), <span class="stringliteral">&quot;norm_dot(): objects must have the same number of elements&quot;</span> );
<a name="l00186"></a>00186   
<a name="l00187"></a>00187   <span class="keyword">const</span> eT* A_mem = A.memptr();
<a name="l00188"></a>00188   <span class="keyword">const</span> eT* B_mem = B.<a class="code" href="a00807.html#ga78bb1eef0619bccb2a13f3dfafee19bf" title="returns a pointer to array of eTs used by the matrix">memptr</a>();
<a name="l00189"></a>00189   
<a name="l00190"></a>00190   <span class="keyword">const</span> <a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N = A.n_elem;
<a name="l00191"></a>00191   
<a name="l00192"></a>00192   eT acc1 = eT(0);
<a name="l00193"></a>00193   eT acc2 = eT(0);
<a name="l00194"></a>00194   eT acc3 = eT(0);
<a name="l00195"></a>00195   
<a name="l00196"></a>00196   <span class="keywordflow">for</span>(<a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;N; ++i)
<a name="l00197"></a>00197     {
<a name="l00198"></a>00198     <span class="keyword">const</span> eT tmpA = A_mem[i];
<a name="l00199"></a>00199     <span class="keyword">const</span> eT tmpB = B_mem[i];
<a name="l00200"></a>00200     
<a name="l00201"></a>00201     acc1 += tmpA * tmpA;
<a name="l00202"></a>00202     acc2 += tmpB * tmpB;
<a name="l00203"></a>00203     acc3 += tmpA * tmpB;
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205     
<a name="l00206"></a>00206   <span class="keywordflow">return</span> acc3 / ( <a class="code" href="a00771.html#gae69d28fe1d387bd0823bfe24a5bee315">std::sqrt</a>(acc1 * acc2) );   <span class="comment">// TODO: this only makes sense for eT = float, double or complex</span>
<a name="l00207"></a>00207   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa2ba83902c86d2c0b5a016187223d9b3"></a><!-- doxytag: member="op_norm_dot::apply_proxy" ref="gaa2ba83902c86d2c0b5a016187223d9b3" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_norm_dot::apply_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00054.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00630_source.html#l00215">215</a> of file <a class="el" href="a00630_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00516_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, and <a class="el" href="a00576_source.html#l00579">sqrt()</a>.</p>

<p>Referenced by <a class="el" href="a00630_source.html#l00153">op_norm_dot::apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00216"></a>00216   {
<a name="l00217"></a>00217   arma_extra_debug_sigprint();
<a name="l00218"></a>00218   
<a name="l00219"></a>00219   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00220"></a>00220   
<a name="l00221"></a>00221   <span class="keyword">const</span> <a class="code" href="a00449.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00222"></a>00222   <span class="keyword">const</span> <a class="code" href="a00449.html">Proxy&lt;T2&gt;</a> B(Y.<a class="code" href="a00054.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   arma_debug_check( (A.n_elem != B.n_elem), <span class="stringliteral">&quot;norm_dot(): objects must have the same number of elements&quot;</span> );
<a name="l00225"></a>00225   
<a name="l00226"></a>00226   <span class="keyword">const</span> <a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N = A.n_elem;
<a name="l00227"></a>00227   
<a name="l00228"></a>00228   eT acc1 = eT(0);
<a name="l00229"></a>00229   eT acc2 = eT(0);
<a name="l00230"></a>00230   eT acc3 = eT(0);
<a name="l00231"></a>00231   
<a name="l00232"></a>00232   <span class="keywordflow">for</span>(<a class="code" href="a00862.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;N; ++i)
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234     <span class="keyword">const</span> eT tmpA = A[i];
<a name="l00235"></a>00235     <span class="keyword">const</span> eT tmpB = B[i];
<a name="l00236"></a>00236     
<a name="l00237"></a>00237     acc1 += tmpA * tmpA;
<a name="l00238"></a>00238     acc2 += tmpB * tmpB;
<a name="l00239"></a>00239     acc3 += tmpA * tmpB;
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241     
<a name="l00242"></a>00242   <span class="keywordflow">return</span> acc3 / ( <a class="code" href="a00771.html#gae69d28fe1d387bd0823bfe24a5bee315">std::sqrt</a>(acc1 * acc2) );   <span class="comment">// TODO: this only makes sense for eT = float, double or complex</span>
<a name="l00243"></a>00243   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
