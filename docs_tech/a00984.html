<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Op_dot</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Op_dot</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00408.html">op_dot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dot product operation  <a href="a00408.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00420.html">op_norm_dot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">normalised dot product operation  <a href="a00420.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_pure eT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gafbd9c59a8ccf453b2e3af7b2bc37e0aa">op_dot::direct_dot_arma</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem, const eT *const A, const eT *const B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for two arrays, generic version  <a href="#gafbd9c59a8ccf453b2e3af7b2bc37e0aa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_pure <br class="typebreak"/>
<a class="el" href="a00016.html">arma_float_only</a>&lt; eT &gt;::result&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#ga15a27f35439ac6600cb6a3d10632d95e">op_dot::direct_dot</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem, const eT *const A, const eT *const B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for two arrays, float and double version  <a href="#ga15a27f35439ac6600cb6a3d10632d95e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_pure eT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gaadc393f3b56dc5fc1eb9e832f4bee48d">op_dot::direct_dot</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem, const eT *const A, const eT *const B, const eT *C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for three arrays  <a href="#gaadc393f3b56dc5fc1eb9e832f4bee48d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_inline <br class="typebreak"/>
T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gac80e745d0c70e80d4ce5632f2b886914">op_dot::apply</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#ga486a9ac26f167646721db8637cb6da64">op_dot::apply_unwrap</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gaf9f7ac52f729be81da8f095d91c2889f">op_dot::apply_proxy</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">arma_hot static arma_inline <br class="typebreak"/>
T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gaee9e73773f5c9fd839c788edb18673cb">op_norm_dot::apply</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#ga9b76380ec9ac6e56e80166dc461eae45">op_norm_dot::apply_unwrap</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static arma_hot T1::elem_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00984.html#gaa2ba83902c86d2c0b5a016187223d9b3">op_norm_dot::apply_proxy</a> (const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;X, const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;Y)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafbd9c59a8ccf453b2e3af7b2bc37e0aa"></a><!-- doxytag: member="op_dot::direct_dot_arma" ref="gafbd9c59a8ccf453b2e3af7b2bc37e0aa" args="(const u32 n_elem, const eT *const A, const eT *const B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_pure eT op_dot::direct_dot_arma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>n_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for two arrays, generic version </p>

<p>Definition at line <a class="el" href="a00776_source.html#l00029">29</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00776_source.html#l00060">direct_dot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00030"></a>00030   {
<a name="l00031"></a>00031   arma_extra_debug_sigprint();
<a name="l00032"></a>00032   
<a name="l00033"></a>00033   eT val1 = eT(0);
<a name="l00034"></a>00034   eT val2 = eT(0);
<a name="l00035"></a>00035   
<a name="l00036"></a>00036   <a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i, j;
<a name="l00037"></a>00037   
<a name="l00038"></a>00038   <span class="keywordflow">for</span>(i=0, j=1; j&lt;n_elem; i+=2, j+=2)
<a name="l00039"></a>00039     {
<a name="l00040"></a>00040     val1 += A[i] * B[i];
<a name="l00041"></a>00041     val2 += A[j] * B[j];
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043   
<a name="l00044"></a>00044   <span class="keywordflow">if</span>(i &lt; n_elem)
<a name="l00045"></a>00045     {
<a name="l00046"></a>00046     val1 += A[i] * B[i];
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048   
<a name="l00049"></a>00049   <span class="keywordflow">return</span> val1 + val2;
<a name="l00050"></a>00050   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga15a27f35439ac6600cb6a3d10632d95e"></a><!-- doxytag: member="op_dot::direct_dot" ref="ga15a27f35439ac6600cb6a3d10632d95e" args="(const u32 n_elem, const eT *const A, const eT *const B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_pure <a class="el" href="a00031.html">arma_integral_only</a>&lt; eT &gt;::result op_dot::direct_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>n_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for two arrays, float and double version </p>
<p>for two arrays, integral version</p>
<p>for two arrays, complex version </p>

<p>Definition at line <a class="el" href="a00776_source.html#l00060">60</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00630_source.html#l00064">atlas::cblas_dot()</a>, <a class="el" href="a00776_source.html#l00029">direct_dot_arma()</a>, and <a class="el" href="a00635_source.html#l00049">blas::dot_()</a>.</p>

<p>Referenced by <a class="el" href="a00672_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00776_source.html#l00175">apply_unwrap()</a>, <a class="el" href="a00672_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00778_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, and <a class="el" href="a00778_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00061"></a>00061   {
<a name="l00062"></a>00062   arma_extra_debug_sigprint();
<a name="l00063"></a>00063   
<a name="l00064"></a>00064   <span class="keywordflow">if</span>( n_elem &lt;= (128/<span class="keyword">sizeof</span>(eT)) )
<a name="l00065"></a>00065     {
<a name="l00066"></a>00066     <span class="keywordflow">return</span> <a class="code" href="a00984.html#gafbd9c59a8ccf453b2e3af7b2bc37e0aa" title="for two arrays, generic version">op_dot::direct_dot_arma</a>(n_elem, A, B);
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068   <span class="keywordflow">else</span>
<a name="l00069"></a>00069     {
<a name="l00070"></a>00070 <span class="preprocessor">    #if defined(ARMA_USE_ATLAS)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>      {
<a name="l00072"></a>00072       <span class="keywordflow">return</span> <a class="code" href="a00869.html#afc0a4f7916c2c00cf9bc58cec45e2763">atlas::cblas_dot</a>(n_elem, A, B);
<a name="l00073"></a>00073       }
<a name="l00074"></a>00074 <span class="preprocessor">    #elif defined(ARMA_USE_BLAS)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>      {
<a name="l00076"></a>00076       <span class="keyword">const</span> <span class="keywordtype">int</span> n = n_elem;
<a name="l00077"></a>00077       <span class="keywordflow">return</span> <a class="code" href="a00870.html#afd2cb8844c4721cc83f1370e994a71f6">blas::dot_</a>(&amp;n, A, B);
<a name="l00078"></a>00078       }
<a name="l00079"></a>00079 <span class="preprocessor">    #else</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>      {
<a name="l00081"></a>00081       <span class="keywordflow">return</span> <a class="code" href="a00984.html#gafbd9c59a8ccf453b2e3af7b2bc37e0aa" title="for two arrays, generic version">op_dot::direct_dot_arma</a>(n_elem, A, B);
<a name="l00082"></a>00082       }
<a name="l00083"></a>00083 <span class="preprocessor">    #endif</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span>    }
<a name="l00085"></a>00085   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaadc393f3b56dc5fc1eb9e832f4bee48d"></a><!-- doxytag: member="op_dot::direct_dot" ref="gaadc393f3b56dc5fc1eb9e832f4bee48d" args="(const u32 n_elem, const eT *const A, const eT *const B, const eT *C)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_pure eT op_dot::direct_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td>
          <td class="paramname"> <em>n_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *const &nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const eT *&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>for three arrays </p>

<p>Definition at line <a class="el" href="a00776_source.html#l00135">135</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00136"></a>00136   {
<a name="l00137"></a>00137   arma_extra_debug_sigprint();
<a name="l00138"></a>00138   
<a name="l00139"></a>00139   eT val = eT(0);
<a name="l00140"></a>00140   
<a name="l00141"></a>00141   <span class="keywordflow">for</span>(<a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143     val += A[i] * B[i] * C[i];
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="keywordflow">return</span> val;
<a name="l00147"></a>00147   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac80e745d0c70e80d4ce5632f2b886914"></a><!-- doxytag: member="op_dot::apply" ref="gac80e745d0c70e80d4ce5632f2b886914" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_inline T1::elem_type op_dot::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00155">155</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00776_source.html#l00198">apply_proxy()</a>, and <a class="el" href="a00776_source.html#l00175">apply_unwrap()</a>.</p>

<p>Referenced by <a class="el" href="a00682_source.html#l00026">dot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00156"></a>00156   {
<a name="l00157"></a>00157   arma_extra_debug_sigprint();
<a name="l00158"></a>00158   
<a name="l00159"></a>00159   <span class="keywordflow">if</span>( (<a class="code" href="a00313.html">is_Mat&lt;T1&gt;::value</a> == <span class="keyword">true</span>) &amp;&amp; (<a class="code" href="a00313.html">is_Mat&lt;T2&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161     <span class="keywordflow">return</span> <a class="code" href="a00984.html#ga486a9ac26f167646721db8637cb6da64">op_dot::apply_unwrap</a>(X,Y);
<a name="l00162"></a>00162     }
<a name="l00163"></a>00163   <span class="keywordflow">else</span>
<a name="l00164"></a>00164     {
<a name="l00165"></a>00165     <span class="keywordflow">return</span> <a class="code" href="a00984.html#gaf9f7ac52f729be81da8f095d91c2889f">op_dot::apply_proxy</a>(X,Y);
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga486a9ac26f167646721db8637cb6da64"></a><!-- doxytag: member="op_dot::apply_unwrap" ref="ga486a9ac26f167646721db8637cb6da64" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_inline T1::elem_type op_dot::apply_unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00175">175</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00776_source.html#l00060">direct_dot()</a>, <a class="el" href="a00633_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, <a class="el" href="a00759_source.html#l00035">Mat&lt; eT &gt;::mem</a>, and <a class="el" href="a00759_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>.</p>

<p>Referenced by <a class="el" href="a00776_source.html#l00155">apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00176"></a>00176   {
<a name="l00177"></a>00177   arma_extra_debug_sigprint();
<a name="l00178"></a>00178   
<a name="l00179"></a>00179   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00180"></a>00180   
<a name="l00181"></a>00181   <span class="keyword">const</span> <a class="code" href="a00596.html">unwrap&lt;T1&gt;</a> tmp1(X.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00182"></a>00182   <span class="keyword">const</span> <a class="code" href="a00596.html">unwrap&lt;T2&gt;</a> tmp2(Y.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00183"></a>00183   
<a name="l00184"></a>00184   <span class="keyword">const</span> <a class="code" href="a00389.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; A = tmp1.M;
<a name="l00185"></a>00185   <span class="keyword">const</span> <a class="code" href="a00389.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = tmp2.M;
<a name="l00186"></a>00186   
<a name="l00187"></a>00187   arma_debug_check( (A.n_elem != B.<a class="code" href="a00389.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>), <span class="stringliteral">&quot;dot(): objects must have the same number of elements&quot;</span> );
<a name="l00188"></a>00188   
<a name="l00189"></a>00189   <span class="keywordflow">return</span> <a class="code" href="a00984.html#ga15a27f35439ac6600cb6a3d10632d95e" title="for two arrays, float and double version">op_dot::direct_dot</a>(A.n_elem, A.mem, B.<a class="code" href="a00389.html#a14a6badc8098d810e5decb22272a07b0" title="pointer to the memory used by the matrix (memory is read-only)">mem</a>);
<a name="l00190"></a>00190   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf9f7ac52f729be81da8f095d91c2889f"></a><!-- doxytag: member="op_dot::apply_proxy" ref="gaf9f7ac52f729be81da8f095d91c2889f" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_dot::apply_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00198">198</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00633_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>.</p>

<p>Referenced by <a class="el" href="a00776_source.html#l00155">apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00199"></a>00199   {
<a name="l00200"></a>00200   arma_extra_debug_sigprint();
<a name="l00201"></a>00201   
<a name="l00202"></a>00202   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00203"></a>00203   
<a name="l00204"></a>00204   <span class="keyword">const</span> <a class="code" href="a00559.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00205"></a>00205   <span class="keyword">const</span> <a class="code" href="a00559.html">Proxy&lt;T2&gt;</a> B(Y.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00206"></a>00206   
<a name="l00207"></a>00207   arma_debug_check( (A.n_elem != B.n_elem), <span class="stringliteral">&quot;dot(): objects must have the same number of elements&quot;</span> );
<a name="l00208"></a>00208   
<a name="l00209"></a>00209   <span class="keyword">const</span> <a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = A.n_elem;
<a name="l00210"></a>00210   eT val = eT(0);
<a name="l00211"></a>00211   
<a name="l00212"></a>00212   <span class="keywordflow">for</span>(<a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;n_elem; ++i)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214     val += A[i] * B[i];
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216   
<a name="l00217"></a>00217   <span class="keywordflow">return</span> val;
<a name="l00218"></a>00218   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaee9e73773f5c9fd839c788edb18673cb"></a><!-- doxytag: member="op_norm_dot::apply" ref="gaee9e73773f5c9fd839c788edb18673cb" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot arma_inline T1::elem_type op_norm_dot::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00230">230</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00776_source.html#l00292">op_norm_dot::apply_proxy()</a>, and <a class="el" href="a00776_source.html#l00250">op_norm_dot::apply_unwrap()</a>.</p>

<p>Referenced by <a class="el" href="a00682_source.html#l00043">norm_dot()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00231"></a>00231   {
<a name="l00232"></a>00232   arma_extra_debug_sigprint();
<a name="l00233"></a>00233   
<a name="l00234"></a>00234   <span class="keywordflow">if</span>( (<a class="code" href="a00313.html">is_Mat&lt;T1&gt;::value</a> == <span class="keyword">true</span>) &amp;&amp; (<a class="code" href="a00313.html">is_Mat&lt;T2&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00235"></a>00235     {
<a name="l00236"></a>00236     <span class="keywordflow">return</span> <a class="code" href="a00984.html#ga9b76380ec9ac6e56e80166dc461eae45">op_norm_dot::apply_unwrap</a>(X,Y);
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238   <span class="keywordflow">else</span>
<a name="l00239"></a>00239     {
<a name="l00240"></a>00240     <span class="keywordflow">return</span> <a class="code" href="a00984.html#gaa2ba83902c86d2c0b5a016187223d9b3">op_norm_dot::apply_proxy</a>(X,Y);
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9b76380ec9ac6e56e80166dc461eae45"></a><!-- doxytag: member="op_norm_dot::apply_unwrap" ref="ga9b76380ec9ac6e56e80166dc461eae45" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_norm_dot::apply_unwrap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00250">250</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00633_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, <a class="el" href="a00758_source.html#l02301">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00759_source.html#l00032">Mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00696_source.html#l00507">sqrt()</a>.</p>

<p>Referenced by <a class="el" href="a00776_source.html#l00230">op_norm_dot::apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00251"></a>00251   {
<a name="l00252"></a>00252   arma_extra_debug_sigprint();
<a name="l00253"></a>00253   
<a name="l00254"></a>00254   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00255"></a>00255   
<a name="l00256"></a>00256   <span class="keyword">const</span> <a class="code" href="a00596.html">unwrap&lt;T1&gt;</a> tmp1(X.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00257"></a>00257   <span class="keyword">const</span> <a class="code" href="a00596.html">unwrap&lt;T2&gt;</a> tmp2(Y.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00258"></a>00258   
<a name="l00259"></a>00259   <span class="keyword">const</span> <a class="code" href="a00389.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; A = tmp1.M;
<a name="l00260"></a>00260   <span class="keyword">const</span> <a class="code" href="a00389.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = tmp2.M;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   arma_debug_check( (A.n_elem != B.<a class="code" href="a00389.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>), <span class="stringliteral">&quot;norm_dot(): objects must have the same number of elements&quot;</span> );
<a name="l00263"></a>00263   
<a name="l00264"></a>00264   <span class="keyword">const</span> eT* A_mem = A.memptr();
<a name="l00265"></a>00265   <span class="keyword">const</span> eT* B_mem = B.<a class="code" href="a00975.html#ga78bb1eef0619bccb2a13f3dfafee19bf" title="returns a pointer to array of eTs used by the matrix">memptr</a>();
<a name="l00266"></a>00266   
<a name="l00267"></a>00267   <span class="keyword">const</span> <a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N = A.n_elem;
<a name="l00268"></a>00268   
<a name="l00269"></a>00269   eT acc1 = eT(0);
<a name="l00270"></a>00270   eT acc2 = eT(0);
<a name="l00271"></a>00271   eT acc3 = eT(0);
<a name="l00272"></a>00272   
<a name="l00273"></a>00273   <span class="keywordflow">for</span>(<a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;N; ++i)
<a name="l00274"></a>00274     {
<a name="l00275"></a>00275     <span class="keyword">const</span> eT tmpA = A_mem[i];
<a name="l00276"></a>00276     <span class="keyword">const</span> eT tmpB = B_mem[i];
<a name="l00277"></a>00277     
<a name="l00278"></a>00278     acc1 += tmpA * tmpA;
<a name="l00279"></a>00279     acc2 += tmpB * tmpB;
<a name="l00280"></a>00280     acc3 += tmpA * tmpB;
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     
<a name="l00283"></a>00283   <span class="keywordflow">return</span> acc3 / ( <a class="code" href="a00928.html#gae69d28fe1d387bd0823bfe24a5bee315">std::sqrt</a>(acc1 * acc2) );
<a name="l00284"></a>00284   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaa2ba83902c86d2c0b5a016187223d9b3"></a><!-- doxytag: member="op_norm_dot::apply_proxy" ref="gaa2ba83902c86d2c0b5a016187223d9b3" args="(const Base&lt; typename T1::elem_type, T1 &gt; &amp;X, const Base&lt; typename T1::elem_type, T2 &gt; &amp;Y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_hot T1::elem_type op_norm_dot::apply_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00103.html">Base</a>&lt; typename T1::elem_type, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00776_source.html#l00292">292</a> of file <a class="el" href="a00776_source.html">op_dot_meat.hpp</a>.</p>

<p>References <a class="el" href="a00633_source.html#l00033">Base&lt; elem_type, derived &gt;::get_ref()</a>, and <a class="el" href="a00696_source.html#l00507">sqrt()</a>.</p>

<p>Referenced by <a class="el" href="a00776_source.html#l00230">op_norm_dot::apply()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00293"></a>00293   {
<a name="l00294"></a>00294   arma_extra_debug_sigprint();
<a name="l00295"></a>00295   
<a name="l00296"></a>00296   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l00297"></a>00297   
<a name="l00298"></a>00298   <span class="keyword">const</span> <a class="code" href="a00559.html">Proxy&lt;T1&gt;</a> A(X.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00299"></a>00299   <span class="keyword">const</span> <a class="code" href="a00559.html">Proxy&lt;T2&gt;</a> B(Y.<a class="code" href="a00103.html#a24f552a2ce63f4a9c72fd77ee449f9cc">get_ref</a>());
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   arma_debug_check( (A.n_elem != B.n_elem), <span class="stringliteral">&quot;norm_dot(): objects must have the same number of elements&quot;</span> );
<a name="l00302"></a>00302   
<a name="l00303"></a>00303   <span class="keyword">const</span> <a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> N = A.n_elem;
<a name="l00304"></a>00304   
<a name="l00305"></a>00305   eT acc1 = eT(0);
<a name="l00306"></a>00306   eT acc2 = eT(0);
<a name="l00307"></a>00307   eT acc3 = eT(0);
<a name="l00308"></a>00308   
<a name="l00309"></a>00309   <span class="keywordflow">for</span>(<a class="code" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;N; ++i)
<a name="l00310"></a>00310     {
<a name="l00311"></a>00311     <span class="keyword">const</span> eT tmpA = A[i];
<a name="l00312"></a>00312     <span class="keyword">const</span> eT tmpB = B[i];
<a name="l00313"></a>00313     
<a name="l00314"></a>00314     acc1 += tmpA * tmpA;
<a name="l00315"></a>00315     acc2 += tmpB * tmpB;
<a name="l00316"></a>00316     acc3 += tmpA * tmpB;
<a name="l00317"></a>00317     }
<a name="l00318"></a>00318     
<a name="l00319"></a>00319   <span class="keywordflow">return</span> acc3 / ( <a class="code" href="a00928.html#gae69d28fe1d387bd0823bfe24a5bee315">std::sqrt</a>(acc1 * acc2) );
<a name="l00320"></a>00320   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
