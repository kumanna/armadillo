<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Diskio</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Diskio</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">diskio</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class for saving and loading matrices and fields  <a href="a00042.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> { <br/>
&nbsp;&nbsp;<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41">auto_detect</a>, 
<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3">raw_ascii</a>, 
<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c">arma_ascii</a>, 
<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6">arma_binary</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda">pgm_binary</a>, 
<a class="el" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08">ppm_binary</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>file types supported by Armadillo </p>
 <a href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gaa99252a20f066762a161ca8ceb9b2c29">diskio::gen_txt_header</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gaa99252a20f066762a161ca8ceb9b2c29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gafea81731918e03aedf946fafceda27b5">diskio::gen_bin_header</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gafea81731918e03aedf946fafceda27b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gacc59f2968b7cc76c746183cb61dcfe04">diskio::gen_txt_header</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gacc59f2968b7cc76c746183cb61dcfe04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gae12c3543c4168cd7a2fade35eeee82b4">diskio::gen_bin_header</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="#gae12c3543c4168cd7a2fade35eeee82b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#gaf1b98a9e26843fbaad5a12d626053023">diskio::conv_to_hex_char</a> (const <a class="el" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#gae1927b3ea8735a7d1e77d89405f592e3">diskio::conv_to_hex</a> (char *out, const <a class="el" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71">diskio::gen_tmp_name</a> (const std::string &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00634.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00634.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="#ga81ac9508b1ee96fd24338a9701aeda71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1">diskio::safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="#ga21a278d6cee27f2800429aadceaff8b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga6bdf26f1c22b7e62ae83333ba613fcc1">diskio::save_raw_ascii</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="#ga6bdf26f1c22b7e62ae83333ba613fcc1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga00d2191a8f08a1a10926273bb91a766a">diskio::save_arma_ascii</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga00d2191a8f08a1a10926273bb91a766a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga49a77a6aae221a4ba7e5e882777e0fd9">diskio::save_arma_ascii</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga49a77a6aae221a4ba7e5e882777e0fd9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gaffe954d2c7ad14e7d5cc1be747cb2a63">diskio::save_arma_binary</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gaffe954d2c7ad14e7d5cc1be747cb2a63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gae9f09785dc6a18edd49fc074514fc6c7">diskio::save_arma_binary</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="#gae9f09785dc6a18edd49fc074514fc6c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga9fe8365235e562f75bdcf48826dc656a">diskio::save_pgm_binary</a> (const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#ga9fe8365235e562f75bdcf48826dc656a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gad88e7d784105a99ba8666b2cc05af0a3">diskio::save_pgm_binary</a> (const <a class="el" href="a00164.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="#gad88e7d784105a99ba8666b2cc05af0a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga400632d14748572e5faeecb30e7915c7">diskio::load_raw_ascii</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="#ga400632d14748572e5faeecb30e7915c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7">diskio::load_arma_ascii</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga81f825e8e6474ff560b71cb1e144dbd7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga4a8295cacc94eb458cfb09703b4f9c25">diskio::load_arma_ascii</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="#ga4a8295cacc94eb458cfb09703b4f9c25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f">diskio::load_arma_binary</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="#ga8e0731ede58797f7638eda2a50af240f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga72d7772ca9cd9007571c986c2052fefc">diskio::load_arma_binary</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a> (std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga114a20791e59f5a1ad076c0a6153c634">diskio::load_pgm_binary</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#ga114a20791e59f5a1ad076c0a6153c634"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gad236bb1f44446de130054ea0a4b85152">diskio::load_pgm_binary</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#gad236bb1f44446de130054ea0a4b85152"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga672f562ded628be461b769c7110264b3">diskio::load_pgm_binary</a> (<a class="el" href="a00164.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="#ga672f562ded628be461b769c7110264b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d">diskio::load_auto_detect</a> (<a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="#ga7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga174fcb65d0726a0b074cb638cf09d6b0">diskio::save_raw_ascii</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="#ga174fcb65d0726a0b074cb638cf09d6b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga144d1cf32717082303ca3507398f495a">diskio::save_arma_ascii</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga144d1cf32717082303ca3507398f495a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gab27bd44f095e1c68e8a52bebd2900802">diskio::save_arma_ascii</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#gab27bd44f095e1c68e8a52bebd2900802"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga26ac154aece92b7be2247de51e1f7d66">diskio::save_arma_binary</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="#ga26ac154aece92b7be2247de51e1f7d66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gaeb415f13cdadc3c8b35db264a600005e">diskio::save_arma_binary</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="#gaeb415f13cdadc3c8b35db264a600005e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga35f015b5569d09e69d1562f3c087811e">diskio::load_raw_ascii</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="#ga35f015b5569d09e69d1562f3c087811e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga8c671488b92ad364dbc2c4cba859f718">diskio::load_arma_ascii</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#ga8c671488b92ad364dbc2c4cba859f718"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gaf0e1e21459b992bef79c0cb714cbbde9">diskio::load_arma_ascii</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="#gaf0e1e21459b992bef79c0cb714cbbde9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga089f7fe67d64e445cd716cae5d4aad65">diskio::load_arma_binary</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in binary format, with a header that indicates the cube type as well as its dimensions.  <a href="#ga089f7fe67d64e445cd716cae5d4aad65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gab91a1e9d8c23aaa07474af24731e3d3d">diskio::load_arma_binary</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gae1a42ba07bf3a86e11ab082cb96a45e9">diskio::load_auto_detect</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="#gae1a42ba07bf3a86e11ab082cb96a45e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga2c60a2f31130b27a3cb1ad020660cc21">diskio::save_arma_binary</a> (const <a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga97df7a8f223054be0b5135ff783ab7d4">diskio::load_arma_binary</a> (<a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#ga83f09e96c16bb21f7185d867c9845efe">diskio::save_std_string</a> (const <a class="el" href="a00043.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html#ga6026e50ca294ce23eb2bef6f4e3765e4">diskio::load_std_string</a> (<a class="el" href="a00043.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gac66e6e0cc9f7ef2a6bb1fadab19e90f9">diskio::load_auto_detect</a> (<a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00043.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="#gac66e6e0cc9f7ef2a6bb1fadab19e90f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#gade8fe65bb50cb3e7bb9129ff4af773ed">diskio::load_ppm_binary</a> (<a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga287ba6a07f728ff3e54db5a1fe8bfd16">diskio::save_ppm_binary</a> (const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga589a30dc9494f1b2780682cf78757f0e">diskio::load_ppm_binary</a> (<a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00608.html#ga23d4e3f45a86ec0440b4d99450f38b20">diskio::save_ppm_binary</a> (const <a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaaf047b6ce458f7c55fd215920656d128"></a><!-- doxytag: member="forward_proto.hpp::file_type" ref="gaaf047b6ce458f7c55fd215920656d128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00608.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>file types supported by Armadillo </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41"></a><!-- doxytag: member="auto_detect" ref="ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41" args="" -->auto_detect</em>&nbsp;</td><td>
<p>Automatically detect the file type (file must be one of the following types). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3"></a><!-- doxytag: member="raw_ascii" ref="ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" args="" -->raw_ascii</em>&nbsp;</td><td>
<p>ASCII format (text), without any other information. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c"></a><!-- doxytag: member="arma_ascii" ref="ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" args="" -->arma_ascii</em>&nbsp;</td><td>
<p>Armadillo ASCII format (text), with information about matrix type and size. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6"></a><!-- doxytag: member="arma_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" args="" -->arma_binary</em>&nbsp;</td><td>
<p>Armadillo binary format. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda"></a><!-- doxytag: member="pgm_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda" args="" -->pgm_binary</em>&nbsp;</td><td>
<p>Portable Grey Map (greyscale image). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08"></a><!-- doxytag: member="ppm_binary" ref="ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" args="" -->ppm_binary</em>&nbsp;</td><td>
<p>Portable Pixel Map (colour image), used by the <a class="el" href="a00043.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> class only. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00452_source.html#l00085">85</a> of file <a class="el" href="a00452_source.html">forward_proto.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00086"></a>00086   {
<a name="l00087"></a>00087   <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128ab23ff78608de192c57782353f7562e41" title="Automatically detect the file type (file must be one of the following types).">auto_detect</a>,  <span class="comment">//!&lt; Automatically detect the file type (file must be one of the following types)</span>
<a name="l00088"></a>00088 <span class="comment"></span>  <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a628746bcaf26dfa0c59b37713c27eea3" title="ASCII format (text), without any other information.">raw_ascii</a>,    <span class="comment">//!&lt; ASCII format (text), without any other information.</span>
<a name="l00089"></a>00089 <span class="comment"></span>  <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128aa8404637cbf0a8edb1b2697ed8be514c" title="Armadillo ASCII format (text), with information about matrix type and size.">arma_ascii</a>,   <span class="comment">//!&lt; Armadillo ASCII format (text), with information about matrix type and size</span>
<a name="l00090"></a>00090 <span class="comment"></span>  <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a84c7cef68df29f3a127038737c4cbdb6" title="Armadillo binary format.">arma_binary</a>,  <span class="comment">//!&lt; Armadillo binary format</span>
<a name="l00091"></a>00091 <span class="comment"></span>  <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a0b14fb78700351dca695ede008144dda" title="Portable Grey Map (greyscale image).">pgm_binary</a>,   <span class="comment">//!&lt; Portable Grey Map (greyscale image)</span>
<a name="l00092"></a>00092 <span class="comment"></span>  <a class="code" href="a00608.html#ggaaf047b6ce458f7c55fd215920656d128a152928479a10a889bbde6f10f480ac08" title="Portable Pixel Map (colour image), used by the field class only.">ppm_binary</a>    <span class="comment">//!&lt; Portable Pixel Map (colour image), used by the field class only</span>
<a name="l00093"></a>00093 <span class="comment"></span>  };
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa99252a20f066762a161ca8ceb9b2c29"></a><!-- doxytag: member="diskio::gen_txt_header" ref="gaa99252a20f066762a161ca8ceb9b2c29" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00028">28</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00844">load_arma_ascii()</a>, and <a class="el" href="a00406_source.html#l00539">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00029"></a>00029   {
<a name="l00030"></a>00030   <a class="code" href="a00016.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00031"></a>00031 
<a name="l00032"></a>00032   <span class="keywordflow">if</span>(<a class="code" href="a00140.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00033"></a>00033     {
<a name="l00034"></a>00034     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU001&quot;</span>);
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036   <span class="keywordflow">else</span>
<a name="l00037"></a>00037   <span class="keywordflow">if</span>(<a class="code" href="a00118.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00038"></a>00038     {
<a name="l00039"></a>00039     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS001&quot;</span>);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041   <span class="keywordflow">else</span>
<a name="l00042"></a>00042   <span class="keywordflow">if</span>(<a class="code" href="a00136.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00043"></a>00043     {
<a name="l00044"></a>00044     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU002&quot;</span>);
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046   <span class="keywordflow">else</span>
<a name="l00047"></a>00047   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00048"></a>00048     {
<a name="l00049"></a>00049     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS002&quot;</span>);
<a name="l00050"></a>00050     }
<a name="l00051"></a>00051   <span class="keywordflow">else</span>
<a name="l00052"></a>00052   <span class="keywordflow">if</span>(<a class="code" href="a00138.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IU004&quot;</span>);
<a name="l00055"></a>00055     }
<a name="l00056"></a>00056   <span class="keywordflow">else</span>
<a name="l00057"></a>00057   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_IS004&quot;</span>);
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061   <span class="keywordflow">else</span>
<a name="l00062"></a>00062   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00063"></a>00063     {
<a name="l00064"></a>00064     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FN004&quot;</span>);
<a name="l00065"></a>00065     }
<a name="l00066"></a>00066   <span class="keywordflow">else</span>
<a name="l00067"></a>00067   <span class="keywordflow">if</span>(<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00068"></a>00068     {
<a name="l00069"></a>00069     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FN008&quot;</span>);
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071   <span class="keywordflow">else</span>
<a name="l00072"></a>00072   <span class="keywordflow">if</span>(<a class="code" href="a00086.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00073"></a>00073     {
<a name="l00074"></a>00074     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FC008&quot;</span>);
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076   <span class="keywordflow">else</span>
<a name="l00077"></a>00077   <span class="keywordflow">if</span>(<a class="code" href="a00084.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_TXT_FC016&quot;</span>);
<a name="l00080"></a>00080     }
<a name="l00081"></a>00081   <span class="keywordflow">else</span>
<a name="l00082"></a>00082     {
<a name="l00083"></a>00083     <span class="keywordflow">return</span> std::string();
<a name="l00084"></a>00084     }
<a name="l00085"></a>00085   
<a name="l00086"></a>00086   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gafea81731918e03aedf946fafceda27b5"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gafea81731918e03aedf946fafceda27b5" args="(const Mat&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00098">98</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00920">load_arma_binary()</a>, and <a class="el" href="a00406_source.html#l00623">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00099"></a>00099   {
<a name="l00100"></a>00100   <a class="code" href="a00016.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00101"></a>00101   
<a name="l00102"></a>00102   <span class="keywordflow">if</span>(<a class="code" href="a00140.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU001&quot;</span>);
<a name="l00105"></a>00105     }
<a name="l00106"></a>00106   <span class="keywordflow">else</span>
<a name="l00107"></a>00107   <span class="keywordflow">if</span>(<a class="code" href="a00118.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS001&quot;</span>);
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111   <span class="keywordflow">else</span>
<a name="l00112"></a>00112   <span class="keywordflow">if</span>(<a class="code" href="a00136.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00113"></a>00113     {
<a name="l00114"></a>00114     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU002&quot;</span>);
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116   <span class="keywordflow">else</span>
<a name="l00117"></a>00117   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS002&quot;</span>);
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121   <span class="keywordflow">else</span>
<a name="l00122"></a>00122   <span class="keywordflow">if</span>(<a class="code" href="a00138.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IU004&quot;</span>);
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126   <span class="keywordflow">else</span>
<a name="l00127"></a>00127   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00128"></a>00128     {
<a name="l00129"></a>00129     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_IS004&quot;</span>);
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131   <span class="keywordflow">else</span>
<a name="l00132"></a>00132   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FN004&quot;</span>);
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136   <span class="keywordflow">else</span>
<a name="l00137"></a>00137   <span class="keywordflow">if</span>(<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00138"></a>00138     {
<a name="l00139"></a>00139     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FN008&quot;</span>);
<a name="l00140"></a>00140     }
<a name="l00141"></a>00141   <span class="keywordflow">else</span>
<a name="l00142"></a>00142   <span class="keywordflow">if</span>(<a class="code" href="a00086.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00143"></a>00143     {
<a name="l00144"></a>00144     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FC008&quot;</span>);
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146   <span class="keywordflow">else</span>
<a name="l00147"></a>00147   <span class="keywordflow">if</span>(<a class="code" href="a00084.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_MAT_BIN_FC016&quot;</span>);
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151   <span class="keywordflow">else</span>
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153     <span class="keywordflow">return</span> std::string();
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155   
<a name="l00156"></a>00156   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gacc59f2968b7cc76c746183cb61dcfe04"></a><!-- doxytag: member="diskio::gen_txt_header" ref="gacc59f2968b7cc76c746183cb61dcfe04" args="(const Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_txt_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00168">168</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00169"></a>00169   {
<a name="l00170"></a>00170   <a class="code" href="a00016.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keywordflow">if</span>(<a class="code" href="a00140.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU001&quot;</span>);
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176   <span class="keywordflow">else</span>
<a name="l00177"></a>00177   <span class="keywordflow">if</span>(<a class="code" href="a00118.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00178"></a>00178     {
<a name="l00179"></a>00179     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS001&quot;</span>);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181   <span class="keywordflow">else</span>
<a name="l00182"></a>00182   <span class="keywordflow">if</span>(<a class="code" href="a00136.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00183"></a>00183     {
<a name="l00184"></a>00184     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU002&quot;</span>);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186   <span class="keywordflow">else</span>
<a name="l00187"></a>00187   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00188"></a>00188     {
<a name="l00189"></a>00189     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS002&quot;</span>);
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191   <span class="keywordflow">else</span>
<a name="l00192"></a>00192   <span class="keywordflow">if</span>(<a class="code" href="a00138.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IU004&quot;</span>);
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196   <span class="keywordflow">else</span>
<a name="l00197"></a>00197   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_IS004&quot;</span>);
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201   <span class="keywordflow">else</span>
<a name="l00202"></a>00202   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FN004&quot;</span>);
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206   <span class="keywordflow">else</span>
<a name="l00207"></a>00207   <span class="keywordflow">if</span>(<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FN008&quot;</span>);
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211   <span class="keywordflow">else</span>
<a name="l00212"></a>00212   <span class="keywordflow">if</span>(<a class="code" href="a00086.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FC008&quot;</span>);
<a name="l00215"></a>00215     }
<a name="l00216"></a>00216   <span class="keywordflow">else</span>
<a name="l00217"></a>00217   <span class="keywordflow">if</span>(<a class="code" href="a00084.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00218"></a>00218     {
<a name="l00219"></a>00219     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_TXT_FC016&quot;</span>);
<a name="l00220"></a>00220     }
<a name="l00221"></a>00221   <span class="keywordflow">else</span>
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223     <span class="keywordflow">return</span> std::string();
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225   
<a name="l00226"></a>00226   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae12c3543c4168cd7a2fade35eeee82b4"></a><!-- doxytag: member="diskio::gen_bin_header" ref="gae12c3543c4168cd7a2fade35eeee82b4" args="(const Cube&lt; eT &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_bin_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00238">238</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00239"></a>00239   {
<a name="l00240"></a>00240   <a class="code" href="a00016.html">arma_type_check&lt;diskio::is_supported_type&lt;eT&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l00241"></a>00241   
<a name="l00242"></a>00242   <span class="keywordflow">if</span>(<a class="code" href="a00140.html">is_u8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU001&quot;</span>);
<a name="l00245"></a>00245     }
<a name="l00246"></a>00246   <span class="keywordflow">else</span>
<a name="l00247"></a>00247   <span class="keywordflow">if</span>(<a class="code" href="a00118.html">is_s8&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS001&quot;</span>);
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251   <span class="keywordflow">else</span>
<a name="l00252"></a>00252   <span class="keywordflow">if</span>(<a class="code" href="a00136.html">is_u16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU002&quot;</span>);
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256   <span class="keywordflow">else</span>
<a name="l00257"></a>00257   <span class="keywordflow">if</span>(<a class="code" href="a00114.html">is_s16&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS002&quot;</span>);
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261   <span class="keywordflow">else</span>
<a name="l00262"></a>00262   <span class="keywordflow">if</span>(<a class="code" href="a00138.html">is_u32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IU004&quot;</span>);
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266   <span class="keywordflow">else</span>
<a name="l00267"></a>00267   <span class="keywordflow">if</span>(<a class="code" href="a00116.html">is_s32&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00268"></a>00268     {
<a name="l00269"></a>00269     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_IS004&quot;</span>);
<a name="l00270"></a>00270     }
<a name="l00271"></a>00271   <span class="keywordflow">else</span>
<a name="l00272"></a>00272   <span class="keywordflow">if</span>(<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FN004&quot;</span>);
<a name="l00275"></a>00275     }
<a name="l00276"></a>00276   <span class="keywordflow">else</span>
<a name="l00277"></a>00277   <span class="keywordflow">if</span>(<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00278"></a>00278     {
<a name="l00279"></a>00279     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FN008&quot;</span>);
<a name="l00280"></a>00280     }
<a name="l00281"></a>00281   <span class="keywordflow">else</span>
<a name="l00282"></a>00282   <span class="keywordflow">if</span>(<a class="code" href="a00086.html">is_complex_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00283"></a>00283     {
<a name="l00284"></a>00284     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FC008&quot;</span>);
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286   <span class="keywordflow">else</span>
<a name="l00287"></a>00287   <span class="keywordflow">if</span>(<a class="code" href="a00084.html">is_complex_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>)
<a name="l00288"></a>00288     {
<a name="l00289"></a>00289     <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ARMA_CUB_BIN_FC016&quot;</span>);
<a name="l00290"></a>00290     }
<a name="l00291"></a>00291   <span class="keywordflow">else</span>
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293     <span class="keywordflow">return</span> std::string();
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295   
<a name="l00296"></a>00296   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf1b98a9e26843fbaad5a12d626053023"></a><!-- doxytag: member="diskio::conv_to_hex_char" ref="gaf1b98a9e26843fbaad5a12d626053023" args="(const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char diskio::conv_to_hex_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l00302">302</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00334">conv_to_hex()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00303"></a>00303   {
<a name="l00304"></a>00304   <span class="keywordtype">char</span> out;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="keywordflow">switch</span>(x)
<a name="l00307"></a>00307     {
<a name="l00308"></a>00308     <span class="keywordflow">case</span>  0: out = <span class="charliteral">&apos;0&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00309"></a>00309     <span class="keywordflow">case</span>  1: out = <span class="charliteral">&apos;1&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00310"></a>00310     <span class="keywordflow">case</span>  2: out = <span class="charliteral">&apos;2&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00311"></a>00311     <span class="keywordflow">case</span>  3: out = <span class="charliteral">&apos;3&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00312"></a>00312     <span class="keywordflow">case</span>  4: out = <span class="charliteral">&apos;4&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00313"></a>00313     <span class="keywordflow">case</span>  5: out = <span class="charliteral">&apos;5&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00314"></a>00314     <span class="keywordflow">case</span>  6: out = <span class="charliteral">&apos;6&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00315"></a>00315     <span class="keywordflow">case</span>  7: out = <span class="charliteral">&apos;7&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00316"></a>00316     <span class="keywordflow">case</span>  8: out = <span class="charliteral">&apos;8&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00317"></a>00317     <span class="keywordflow">case</span>  9: out = <span class="charliteral">&apos;9&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00318"></a>00318     <span class="keywordflow">case</span> 10: out = <span class="charliteral">&apos;a&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00319"></a>00319     <span class="keywordflow">case</span> 11: out = <span class="charliteral">&apos;b&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00320"></a>00320     <span class="keywordflow">case</span> 12: out = <span class="charliteral">&apos;c&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00321"></a>00321     <span class="keywordflow">case</span> 13: out = <span class="charliteral">&apos;d&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00322"></a>00322     <span class="keywordflow">case</span> 14: out = <span class="charliteral">&apos;e&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00323"></a>00323     <span class="keywordflow">case</span> 15: out = <span class="charliteral">&apos;f&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00324"></a>00324     <span class="keywordflow">default</span>: out = <span class="charliteral">&apos;-&apos;</span>; <span class="keywordflow">break</span>;
<a name="l00325"></a>00325     }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <span class="keywordflow">return</span> out;  
<a name="l00328"></a>00328   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae1927b3ea8735a7d1e77d89405f592e3"></a><!-- doxytag: member="diskio::conv_to_hex" ref="gae1927b3ea8735a7d1e77d89405f592e3" args="(char *out, const u8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::conv_to_hex </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de">u8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l00334">334</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00302">conv_to_hex_char()</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00335"></a>00335   {
<a name="l00336"></a>00336   <span class="keyword">const</span> <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> a = x / 16;
<a name="l00337"></a>00337   <span class="keyword">const</span> <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> b = x - 16*a;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   out[0] = <a class="code" href="a00608.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(a);
<a name="l00340"></a>00340   out[1] = <a class="code" href="a00608.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a>(b);
<a name="l00341"></a>00341   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga81ac9508b1ee96fd24338a9701aeda71"></a><!-- doxytag: member="diskio::gen_tmp_name" ref="ga81ac9508b1ee96fd24338a9701aeda71" args="(const std::string &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string diskio::gen_tmp_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a quasi-random string to the given filename. The <a class="el" href="a00634.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00634.html#gae875f8ae2d57ae41e19bc529533ec40e" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00354">354</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00334">conv_to_hex()</a>, and <a class="el" href="a00444_source.html#l00031">sum()</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00509">save_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00593">save_arma_binary()</a>, <a class="el" href="a00406_source.html#l00651">save_pgm_binary()</a>, <a class="el" href="a00406_source.html#l02062">save_ppm_binary()</a>, <a class="el" href="a00406_source.html#l00445">save_raw_ascii()</a>, and <a class="el" href="a00406_source.html#l01745">save_std_string()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00355"></a>00355   {
<a name="l00356"></a>00356   <span class="keyword">const</span> std::string* ptr_x     = &amp;x;
<a name="l00357"></a>00357   <span class="keyword">const</span> <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*          ptr_ptr_x = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*<span class="keyword">&gt;</span>(&amp;ptr_x);
<a name="l00358"></a>00358   
<a name="l00359"></a>00359   <span class="keyword">const</span> <span class="keywordtype">char</span>* extra      = <span class="stringliteral">&quot;.tmp_&quot;</span>;
<a name="l00360"></a>00360   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   extra_size = 5;
<a name="l00361"></a>00361   
<a name="l00362"></a>00362   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>   tmp_size   = 2*<span class="keyword">sizeof</span>(<a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*) + 2*2;
<a name="l00363"></a>00363         <span class="keywordtype">char</span>  tmp[tmp_size];
<a name="l00364"></a>00364   
<a name="l00365"></a>00365   <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> char_count = 0;
<a name="l00366"></a>00366   
<a name="l00367"></a>00367   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;<span class="keyword">sizeof</span>(<a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>*); ++i)
<a name="l00368"></a>00368     {
<a name="l00369"></a>00369     <a class="code" href="a00608.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], ptr_ptr_x[i]);
<a name="l00370"></a>00370     char_count += 2;
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372   
<a name="l00373"></a>00373   <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> x_size = x.size();
<a name="l00374"></a>00374   <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a> <a class="code" href="a00644.html#ga3539d90506debc42c45497615cb60add" title="Delayed sum of elements of a matrix along a specified dimension (either rows or columns)...">sum</a> = 0;
<a name="l00375"></a>00375   
<a name="l00376"></a>00376   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00377"></a>00377     {
<a name="l00378"></a>00378     sum += <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x[i]);
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380   
<a name="l00381"></a>00381   <a class="code" href="a00608.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], sum);
<a name="l00382"></a>00382   char_count += 2;
<a name="l00383"></a>00383   
<a name="l00384"></a>00384   <a class="code" href="a00608.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a>(&amp;tmp[char_count], <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>(x_size));
<a name="l00385"></a>00385   
<a name="l00386"></a>00386   
<a name="l00387"></a>00387   std::string out;
<a name="l00388"></a>00388   out.resize(x_size + extra_size + tmp_size);
<a name="l00389"></a>00389   
<a name="l00390"></a>00390   
<a name="l00391"></a>00391   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x_size; ++i)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393     out[i] = x[i];
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395   
<a name="l00396"></a>00396   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;extra_size; ++i)
<a name="l00397"></a>00397     {
<a name="l00398"></a>00398     out[x_size + i] = extra[i];
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400   
<a name="l00401"></a>00401   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;tmp_size; ++i)
<a name="l00402"></a>00402     {
<a name="l00403"></a>00403     out[x_size + extra_size + i] = tmp[i];
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405   
<a name="l00406"></a>00406   <span class="keywordflow">return</span> out;
<a name="l00407"></a>00407   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga21a278d6cee27f2800429aadceaff8b1"></a><!-- doxytag: member="diskio::safe_rename" ref="ga21a278d6cee27f2800429aadceaff8b1" args="(const std::string &amp;old_name, const std::string &amp;new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::safe_rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>new_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00418">418</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00160">arma_warn()</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l00509">save_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00593">save_arma_binary()</a>, <a class="el" href="a00406_source.html#l00651">save_pgm_binary()</a>, <a class="el" href="a00406_source.html#l02062">save_ppm_binary()</a>, <a class="el" href="a00406_source.html#l00445">save_raw_ascii()</a>, and <a class="el" href="a00406_source.html#l01745">save_std_string()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00419"></a>00419   {
<a name="l00420"></a>00420   std::fstream f(new_name.c_str(), std::fstream::out | std::fstream::app);
<a name="l00421"></a>00421   f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00422"></a>00422   
<a name="l00423"></a>00423   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00424"></a>00424   f.close();
<a name="l00425"></a>00425   
<a name="l00426"></a>00426   <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, new_name );
<a name="l00427"></a>00427   
<a name="l00428"></a>00428   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00429"></a>00429     {
<a name="l00430"></a>00430     std::remove(new_name.c_str());
<a name="l00431"></a>00431     
<a name="l00432"></a>00432     <span class="keyword">const</span> <span class="keywordtype">int</span> mv_result = std::rename(old_name.c_str(), new_name.c_str());
<a name="l00433"></a>00433     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( (mv_result != 0), <span class="stringliteral">&quot;trouble writing &quot;</span>, new_name );
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435   
<a name="l00436"></a>00436   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6bdf26f1c22b7e62ae83333ba613fcc1"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="ga6bdf26f1c22b7e62ae83333ba613fcc1" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00445">445</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01893">Mat&lt; eT &gt;::save()</a>, and <a class="el" href="a00401_source.html#l01359">Cube&lt; eT &gt;::save()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00446"></a>00446   {
<a name="l00447"></a>00447   arma_extra_debug_sigprint();
<a name="l00448"></a>00448   
<a name="l00449"></a>00449   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00450"></a>00450   
<a name="l00451"></a>00451   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l00452"></a>00452   
<a name="l00453"></a>00453   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00454"></a>00454     {
<a name="l00455"></a>00455     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00456"></a>00456     }
<a name="l00457"></a>00457   <span class="keywordflow">else</span>
<a name="l00458"></a>00458     {
<a name="l00459"></a>00459     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00460"></a>00460     
<a name="l00461"></a>00461     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00462"></a>00462     
<a name="l00463"></a>00463     <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00464"></a>00464       {
<a name="l00465"></a>00465       f.setf(ios::scientific);
<a name="l00466"></a>00466       f.precision(8);
<a name="l00467"></a>00467       cell_width = 16;
<a name="l00468"></a>00468       }
<a name="l00469"></a>00469     
<a name="l00470"></a>00470     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00471"></a>00471       {
<a name="l00472"></a>00472       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00473"></a>00473         {
<a name="l00474"></a>00474         f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00475"></a>00475         
<a name="l00476"></a>00476         <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00477"></a>00477           {
<a name="l00478"></a>00478           f.width(cell_width);
<a name="l00479"></a>00479           }
<a name="l00480"></a>00480         
<a name="l00481"></a>00481         f &lt;&lt; x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483         
<a name="l00484"></a>00484       f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l00485"></a>00485       }
<a name="l00486"></a>00486     
<a name="l00487"></a>00487     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00488"></a>00488     
<a name="l00489"></a>00489     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00490"></a>00490     
<a name="l00491"></a>00491     f.flush();
<a name="l00492"></a>00492     f.close();
<a name="l00493"></a>00493     
<a name="l00494"></a>00494     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00495"></a>00495       {
<a name="l00496"></a>00496       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00497"></a>00497       }
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499   
<a name="l00500"></a>00500   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga00d2191a8f08a1a10926273bb91a766a"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="ga00d2191a8f08a1a10926273bb91a766a" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00509">509</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01893">Mat&lt; eT &gt;::save()</a>, <a class="el" href="a00401_source.html#l01359">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00406_source.html#l01257">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00510"></a>00510   {
<a name="l00511"></a>00511   arma_extra_debug_sigprint();
<a name="l00512"></a>00512   
<a name="l00513"></a>00513   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00514"></a>00514   
<a name="l00515"></a>00515   std::ofstream f(tmp_name.c_str());
<a name="l00516"></a>00516   
<a name="l00517"></a>00517   <a class="code" href="a00608.html#ga00d2191a8f08a1a10926273bb91a766a" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l00518"></a>00518   
<a name="l00519"></a>00519   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00520"></a>00520   
<a name="l00521"></a>00521   f.flush();
<a name="l00522"></a>00522   f.close();
<a name="l00523"></a>00523   
<a name="l00524"></a>00524   <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00525"></a>00525   
<a name="l00526"></a>00526   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528     <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00529"></a>00529     }
<a name="l00530"></a>00530   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga49a77a6aae221a4ba7e5e882777e0fd9"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="ga49a77a6aae221a4ba7e5e882777e0fd9" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00539">539</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00028">gen_txt_header()</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00540"></a>00540   {
<a name="l00541"></a>00541   arma_extra_debug_sigprint();
<a name="l00542"></a>00542   
<a name="l00543"></a>00543   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00544"></a>00544     {
<a name="l00545"></a>00545     arma_debug_print(<span class="stringliteral">&quot;unable to write &quot;</span>, name);
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547   <span class="keywordflow">else</span>
<a name="l00548"></a>00548     {
<a name="l00549"></a>00549     <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l00550"></a>00550     
<a name="l00551"></a>00551     f &lt;&lt; <a class="code" href="a00608.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00552"></a>00552     f &lt;&lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00553"></a>00553     
<a name="l00554"></a>00554     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l00555"></a>00555     
<a name="l00556"></a>00556     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l00557"></a>00557     
<a name="l00558"></a>00558     <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l00559"></a>00559       {
<a name="l00560"></a>00560       f.setf(ios::scientific);
<a name="l00561"></a>00561       f.precision(8);
<a name="l00562"></a>00562       cell_width = 16;
<a name="l00563"></a>00563       }
<a name="l00564"></a>00564       
<a name="l00565"></a>00565     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00566"></a>00566       {
<a name="l00567"></a>00567       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00568"></a>00568         {
<a name="l00569"></a>00569         f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l00570"></a>00570         
<a name="l00571"></a>00571         <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l00572"></a>00572           {
<a name="l00573"></a>00573           f.width(cell_width);
<a name="l00574"></a>00574           }
<a name="l00575"></a>00575         
<a name="l00576"></a>00576         f &lt;&lt; x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578       
<a name="l00579"></a>00579       f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l00580"></a>00580       }
<a name="l00581"></a>00581     
<a name="l00582"></a>00582     f.flags(orig_flags);
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaffe954d2c7ad14e7d5cc1be747cb2a63"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gaffe954d2c7ad14e7d5cc1be747cb2a63" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00593">593</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01893">Mat&lt; eT &gt;::save()</a>, <a class="el" href="a00408_source.html#l00826">field_aux::save()</a>, <a class="el" href="a00401_source.html#l01359">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00406_source.html#l01344">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594   {
<a name="l00595"></a>00595   arma_extra_debug_sigprint();
<a name="l00596"></a>00596   
<a name="l00597"></a>00597   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00598"></a>00598   
<a name="l00599"></a>00599   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l00600"></a>00600   
<a name="l00601"></a>00601   <a class="code" href="a00608.html#gaffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l00602"></a>00602   
<a name="l00603"></a>00603   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00604"></a>00604   
<a name="l00605"></a>00605   f.flush();
<a name="l00606"></a>00606   f.close();
<a name="l00607"></a>00607   
<a name="l00608"></a>00608   <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00609"></a>00609   
<a name="l00610"></a>00610   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00611"></a>00611     {
<a name="l00612"></a>00612     <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae9f09785dc6a18edd49fc074514fc6c7"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gae9f09785dc6a18edd49fc074514fc6c7" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00623">623</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00098">gen_bin_header()</a>, <a class="el" href="a00490_source.html#l00038">Mat&lt; eT &gt;::mem</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, and <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00624"></a>00624   {
<a name="l00625"></a>00625   arma_extra_debug_sigprint();
<a name="l00626"></a>00626   
<a name="l00627"></a>00627   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00628"></a>00628     {
<a name="l00629"></a>00629     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, name);
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631   <span class="keywordflow">else</span>
<a name="l00632"></a>00632     {
<a name="l00633"></a>00633     f &lt;&lt; <a class="code" href="a00608.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00634"></a>00634     f &lt;&lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00635"></a>00635     
<a name="l00636"></a>00636     f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="a00164.html#a14a6badc8098d810e5decb22272a07b0" title="pointer to the memory used by the matrix (memory is read-only)">mem</a>), x.<a class="code" href="a00164.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638   
<a name="l00639"></a>00639   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9fe8365235e562f75bdcf48826dc656a"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="ga9fe8365235e562f75bdcf48826dc656a" args="(const Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00651">651</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00568_source.html#l00032">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01893">Mat&lt; eT &gt;::save()</a>, and <a class="el" href="a00406_source.html#l00706">save_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00652"></a>00652   {
<a name="l00653"></a>00653   arma_extra_debug_sigprint();
<a name="l00654"></a>00654   
<a name="l00655"></a>00655   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l00656"></a>00656   
<a name="l00657"></a>00657   std::fstream f(tmp_name.c_str(), std::fstream::out | std::fstream::binary);
<a name="l00658"></a>00658   
<a name="l00659"></a>00659   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l00662"></a>00662     }
<a name="l00663"></a>00663   <span class="keywordflow">else</span>
<a name="l00664"></a>00664     {
<a name="l00665"></a>00665     f &lt;&lt; <span class="stringliteral">&quot;P5&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00666"></a>00666     f &lt;&lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00667"></a>00667     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l00668"></a>00668     
<a name="l00669"></a>00669     <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l00670"></a>00670     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l00671"></a>00671     
<a name="l00672"></a>00672     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l00673"></a>00673     
<a name="l00674"></a>00674     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00675"></a>00675       {
<a name="l00676"></a>00676       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00677"></a>00677         {
<a name="l00678"></a>00678         tmp[i] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x(row,col) );  <span class="comment">// TODO: add round() ?</span>
<a name="l00679"></a>00679         ++i;
<a name="l00680"></a>00680         }
<a name="l00681"></a>00681       }
<a name="l00682"></a>00682     
<a name="l00683"></a>00683     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l00684"></a>00684     
<a name="l00685"></a>00685     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l00686"></a>00686     
<a name="l00687"></a>00687     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l00688"></a>00688     
<a name="l00689"></a>00689     f.flush();
<a name="l00690"></a>00690     f.close();
<a name="l00691"></a>00691     
<a name="l00692"></a>00692     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l00693"></a>00693       {
<a name="l00694"></a>00694       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l00695"></a>00695       }
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697   
<a name="l00698"></a>00698   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad88e7d784105a99ba8666b2cc05af0a3"></a><!-- doxytag: member="diskio::save_pgm_binary" ref="gad88e7d784105a99ba8666b2cc05af0a3" args="(const Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_pgm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00164.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a matrix as a PGM greyscale image. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00706">706</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00651">save_pgm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00707"></a>00707   {
<a name="l00708"></a>00708   arma_extra_debug_sigprint();
<a name="l00709"></a>00709   
<a name="l00710"></a>00710   <span class="keyword">const</span> <a class="code" href="a00164.html" title="Dense matrix class.">uchar_mat</a> tmp = <a class="code" href="a00024.html">conv_to&lt;uchar_mat&gt;::from</a>(x);
<a name="l00711"></a>00711   <a class="code" href="a00608.html#ga9fe8365235e562f75bdcf48826dc656a" title="Save a matrix as a PGM greyscale image.">diskio::save_pgm_binary</a>(tmp,name);
<a name="l00712"></a>00712   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga400632d14748572e5faeecb30e7915c7"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="ga400632d14748572e5faeecb30e7915c7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00722">722</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00489_source.html#l01788">Mat&lt; eT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00401_source.html#l01393">Cube&lt; eT &gt;::load()</a>, and <a class="el" href="a00406_source.html#l01131">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00723"></a>00723   {
<a name="l00724"></a>00724   arma_extra_debug_sigprint();
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   std::fstream f;
<a name="l00727"></a>00727   f.open(name.c_str(), std::fstream::in);
<a name="l00728"></a>00728   
<a name="l00729"></a>00729   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00730"></a>00730   
<a name="l00731"></a>00731   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00732"></a>00732     {
<a name="l00733"></a>00733     load_okay = <span class="keyword">false</span>;
<a name="l00734"></a>00734     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736   <span class="keywordflow">else</span>
<a name="l00737"></a>00737     {
<a name="l00738"></a>00738     <span class="comment">//std::fstream::pos_type start = f.tellg();</span>
<a name="l00739"></a>00739     
<a name="l00740"></a>00740     <span class="comment">//</span>
<a name="l00741"></a>00741     <span class="comment">// work out the size</span>
<a name="l00742"></a>00742     
<a name="l00743"></a>00743     
<a name="l00744"></a>00744     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l00745"></a>00745     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l00746"></a>00746     
<a name="l00747"></a>00747     <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l00748"></a>00748     
<a name="l00749"></a>00749     std::string line_string;
<a name="l00750"></a>00750     std::string token;
<a name="l00751"></a>00751     
<a name="l00752"></a>00752     <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l00753"></a>00753       {
<a name="l00754"></a>00754       std::getline(f, line_string);
<a name="l00755"></a>00755       <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l00756"></a>00756         <span class="keywordflow">break</span>;
<a name="l00757"></a>00757       
<a name="l00758"></a>00758       std::stringstream line_stream(line_string);
<a name="l00759"></a>00759       
<a name="l00760"></a>00760       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l00761"></a>00761       <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l00762"></a>00762         line_n_cols++;
<a name="l00763"></a>00763       
<a name="l00764"></a>00764       <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l00765"></a>00765         {
<a name="l00766"></a>00766         f_n_cols = line_n_cols;
<a name="l00767"></a>00767         f_n_cols_found = <span class="keyword">true</span>;
<a name="l00768"></a>00768         }
<a name="l00769"></a>00769       <span class="keywordflow">else</span>
<a name="l00770"></a>00770         {
<a name="l00771"></a>00771         <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l00772"></a>00772           {
<a name="l00773"></a>00773           <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;inconsistent number of columns in &quot;</span>, name );
<a name="l00774"></a>00774           load_okay = <span class="keyword">false</span>;
<a name="l00775"></a>00775           }
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777       
<a name="l00778"></a>00778       ++f_n_rows;
<a name="l00779"></a>00779       }
<a name="l00780"></a>00780       
<a name="l00781"></a>00781     <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l00782"></a>00782       {
<a name="l00783"></a>00783       f.clear();
<a name="l00784"></a>00784       f.seekg(0, ios::beg);
<a name="l00785"></a>00785       <span class="comment">//f.seekg(start);</span>
<a name="l00786"></a>00786       
<a name="l00787"></a>00787       x.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00788"></a>00788     
<a name="l00789"></a>00789       eT val;
<a name="l00790"></a>00790       
<a name="l00791"></a>00791       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00792"></a>00792         {
<a name="l00793"></a>00793         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00794"></a>00794           {
<a name="l00795"></a>00795           <span class="comment">// f &gt;&gt; token;</span>
<a name="l00796"></a>00796           <span class="comment">// x.at(row,col) = eT( strtod(token.c_str(), 0) );</span>
<a name="l00797"></a>00797           
<a name="l00798"></a>00798           f &gt;&gt; val;
<a name="l00799"></a>00799           x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = val;
<a name="l00800"></a>00800           }
<a name="l00801"></a>00801         }
<a name="l00802"></a>00802       }
<a name="l00803"></a>00803     
<a name="l00804"></a>00804     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00805"></a>00805       {
<a name="l00806"></a>00806       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name );
<a name="l00807"></a>00807       load_okay = <span class="keyword">false</span>; 
<a name="l00808"></a>00808       }
<a name="l00809"></a>00809     
<a name="l00810"></a>00810     f.close();
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812   
<a name="l00813"></a>00813   
<a name="l00814"></a>00814   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00815"></a>00815     {
<a name="l00816"></a>00816     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00817"></a>00817     }
<a name="l00818"></a>00818   
<a name="l00819"></a>00819   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga81f825e8e6474ff560b71cb1e144dbd7"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga81f825e8e6474ff560b71cb1e144dbd7" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00828">828</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00401_source.html#l01393">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00406_source.html#l01421">load_arma_ascii()</a>, and <a class="el" href="a00406_source.html#l01131">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00829"></a>00829   {
<a name="l00830"></a>00830   arma_extra_debug_sigprint();
<a name="l00831"></a>00831   
<a name="l00832"></a>00832   std::ifstream f(name.c_str());
<a name="l00833"></a>00833   <a class="code" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l00834"></a>00834   f.close();
<a name="l00835"></a>00835   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4a8295cacc94eb458cfb09703b4f9c25"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga4a8295cacc94eb458cfb09703b4f9c25" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00844">844</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00028">gen_txt_header()</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00489_source.html#l01788">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00845"></a>00845   {
<a name="l00846"></a>00846   arma_extra_debug_sigprint();
<a name="l00847"></a>00847   
<a name="l00848"></a>00848   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00849"></a>00849   
<a name="l00850"></a>00850   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00851"></a>00851     {
<a name="l00852"></a>00852     load_okay = <span class="keyword">false</span>;
<a name="l00853"></a>00853     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00854"></a>00854     }
<a name="l00855"></a>00855   <span class="keywordflow">else</span>
<a name="l00856"></a>00856     {
<a name="l00857"></a>00857     std::string f_header;
<a name="l00858"></a>00858     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00859"></a>00859     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00860"></a>00860     
<a name="l00861"></a>00861     f &gt;&gt; f_header;
<a name="l00862"></a>00862     f &gt;&gt; f_n_rows;
<a name="l00863"></a>00863     f &gt;&gt; f_n_cols;
<a name="l00864"></a>00864     
<a name="l00865"></a>00865     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00608.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x))
<a name="l00866"></a>00866       {
<a name="l00867"></a>00867       x.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols);
<a name="l00868"></a>00868       
<a name="l00869"></a>00869       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l00870"></a>00870         {
<a name="l00871"></a>00871         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l00872"></a>00872           {
<a name="l00873"></a>00873           f &gt;&gt; x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col);
<a name="l00874"></a>00874           }
<a name="l00875"></a>00875         }
<a name="l00876"></a>00876       
<a name="l00877"></a>00877       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00878"></a>00878         {
<a name="l00879"></a>00879         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l00880"></a>00880         load_okay = <span class="keyword">false</span>;
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882       }
<a name="l00883"></a>00883     <span class="keywordflow">else</span>
<a name="l00884"></a>00884       {
<a name="l00885"></a>00885       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name );
<a name="l00886"></a>00886       load_okay = <span class="keyword">false</span>;
<a name="l00887"></a>00887       }
<a name="l00888"></a>00888   
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890   
<a name="l00891"></a>00891   
<a name="l00892"></a>00892   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00893"></a>00893     {
<a name="l00894"></a>00894     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00895"></a>00895     }
<a name="l00896"></a>00896   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8e0731ede58797f7638eda2a50af240f"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga8e0731ede58797f7638eda2a50af240f" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00905">905</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00408_source.html#l00850">field_aux::load()</a>, <a class="el" href="a00401_source.html#l01393">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00406_source.html#l01503">load_arma_binary()</a>, and <a class="el" href="a00406_source.html#l01131">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00906"></a>00906   {
<a name="l00907"></a>00907   arma_extra_debug_sigprint();
<a name="l00908"></a>00908   
<a name="l00909"></a>00909   std::ifstream f;
<a name="l00910"></a>00910   f.open(name.c_str(), std::fstream::binary);
<a name="l00911"></a>00911   <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l00912"></a>00912   f.close();
<a name="l00913"></a>00913   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga72d7772ca9cd9007571c986c2052fefc"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga72d7772ca9cd9007571c986c2052fefc" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l00920">920</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00098">gen_bin_header()</a>, <a class="el" href="a00489_source.html#l01590">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>, and <a class="el" href="a00489_source.html#l01788">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00921"></a>00921   {
<a name="l00922"></a>00922   arma_extra_debug_sigprint();
<a name="l00923"></a>00923   
<a name="l00924"></a>00924   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l00925"></a>00925   
<a name="l00926"></a>00926   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l00927"></a>00927     {
<a name="l00928"></a>00928     load_okay = <span class="keyword">false</span>;
<a name="l00929"></a>00929     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l00930"></a>00930     }
<a name="l00931"></a>00931   <span class="keywordflow">else</span>
<a name="l00932"></a>00932     {
<a name="l00933"></a>00933     std::string f_header;
<a name="l00934"></a>00934     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l00935"></a>00935     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l00936"></a>00936     
<a name="l00937"></a>00937     f &gt;&gt; f_header;
<a name="l00938"></a>00938     f &gt;&gt; f_n_rows;
<a name="l00939"></a>00939     f &gt;&gt; f_n_cols;
<a name="l00940"></a>00940     
<a name="l00941"></a>00941     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00608.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x))
<a name="l00942"></a>00942       {
<a name="l00943"></a>00943       <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l00944"></a>00944       f.get();
<a name="l00945"></a>00945       
<a name="l00946"></a>00946       x.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l00947"></a>00947       f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="a00673.html#ga78bb1eef0619bccb2a13f3dfafee19bf" title="returns a pointer to array of eTs used by the matrix">memptr</a>()), x.<a class="code" href="a00164.html#ab12257afbbe6338a7af830d9b65f3305" title="number of elements in the matrix (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l00948"></a>00948       
<a name="l00949"></a>00949       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l00950"></a>00950         {
<a name="l00951"></a>00951         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l00952"></a>00952         load_okay = <span class="keyword">false</span>;
<a name="l00953"></a>00953         }
<a name="l00954"></a>00954       }
<a name="l00955"></a>00955     <span class="keywordflow">else</span>
<a name="l00956"></a>00956       {
<a name="l00957"></a>00957       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name);
<a name="l00958"></a>00958       load_okay = <span class="keyword">false</span>;
<a name="l00959"></a>00959       }
<a name="l00960"></a>00960     
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962   
<a name="l00963"></a>00963   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l00964"></a>00964     {
<a name="l00965"></a>00965     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l00966"></a>00966     }
<a name="l00967"></a>00967   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga49b5a9c169b0cb638a029af61f922c97"></a><!-- doxytag: member="diskio::pnm_skip_comments" ref="ga49b5a9c169b0cb638a029af61f922c97" args="(std::istream &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::pnm_skip_comments </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l00973">973</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00406_source.html#l01019">load_pgm_binary()</a>, and <a class="el" href="a00406_source.html#l01943">load_ppm_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00974"></a>00974   {
<a name="l00975"></a>00975   <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00976"></a>00976     {
<a name="l00977"></a>00977     <span class="keywordflow">while</span>( isspace(f.peek()) )
<a name="l00978"></a>00978       f.get();
<a name="l00979"></a>00979   
<a name="l00980"></a>00980     <span class="keywordflow">if</span>(f.peek() == <span class="charliteral">&apos;#&apos;</span>)
<a name="l00981"></a>00981       {
<a name="l00982"></a>00982       <span class="keywordflow">while</span>( (f.peek() != <span class="charliteral">&apos;\r&apos;</span>) &amp;&amp; (f.peek()!=<span class="charliteral">&apos;\n&apos;</span>) )
<a name="l00983"></a>00983         f.get();
<a name="l00984"></a>00984       }
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga114a20791e59f5a1ad076c0a6153c634"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="ga114a20791e59f5a1ad076c0a6153c634" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l00994">994</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, and <a class="el" href="a00406_source.html#l01131">load_auto_detect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00995"></a>00995   {
<a name="l00996"></a>00996   arma_extra_debug_sigprint();
<a name="l00997"></a>00997   
<a name="l00998"></a>00998   std::fstream f;
<a name="l00999"></a>00999   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01000"></a>01000   
<a name="l01001"></a>01001   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01002"></a>01002     {
<a name="l01003"></a>01003     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01004"></a>01004     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006   <span class="keywordflow">else</span>
<a name="l01007"></a>01007     {
<a name="l01008"></a>01008     <a class="code" href="a00608.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">diskio::load_pgm_binary</a>(x, name, f); <span class="comment">// Do the actual load</span>
<a name="l01009"></a>01009     f.close();
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad236bb1f44446de130054ea0a4b85152"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="gad236bb1f44446de130054ea0a4b85152" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name, std::istream &amp;is)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01019">1019</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00567_source.html#l00194">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00406_source.html#l00973">pnm_skip_comments()</a>, <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00489_source.html#l01788">Mat&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01020"></a>01020   {
<a name="l01021"></a>01021   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01022"></a>01022   
<a name="l01023"></a>01023   std::string f_header;
<a name="l01024"></a>01024   f &gt;&gt; f_header;
<a name="l01025"></a>01025   
<a name="l01026"></a>01026   <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P5&quot;</span>)
<a name="l01027"></a>01027     {
<a name="l01028"></a>01028     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01029"></a>01029     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01030"></a>01030     <span class="keywordtype">int</span> f_maxval = 0;
<a name="l01031"></a>01031   
<a name="l01032"></a>01032     <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01033"></a>01033   
<a name="l01034"></a>01034     f &gt;&gt; f_n_cols;
<a name="l01035"></a>01035     <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01036"></a>01036   
<a name="l01037"></a>01037     f &gt;&gt; f_n_rows;
<a name="l01038"></a>01038     <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01039"></a>01039   
<a name="l01040"></a>01040     f &gt;&gt; f_maxval;
<a name="l01041"></a>01041     f.get();
<a name="l01042"></a>01042     
<a name="l01043"></a>01043     <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l01044"></a>01044       {
<a name="l01045"></a>01045       x.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l01046"></a>01046       
<a name="l01047"></a>01047       <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l01048"></a>01048         {
<a name="l01049"></a>01049         <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l01050"></a>01050         <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l01051"></a>01051         
<a name="l01052"></a>01052         f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l01053"></a>01053         
<a name="l01054"></a>01054         <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01055"></a>01055         
<a name="l01056"></a>01056         <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l01057"></a>01057         <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l01058"></a>01058         
<a name="l01059"></a>01059         
<a name="l01060"></a>01060         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01061"></a>01061           {
<a name="l01062"></a>01062           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01063"></a>01063             {
<a name="l01064"></a>01064             x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l01065"></a>01065             ++i;
<a name="l01066"></a>01066             }
<a name="l01067"></a>01067           }
<a name="l01068"></a>01068           
<a name="l01069"></a>01069         }
<a name="l01070"></a>01070       <span class="keywordflow">else</span>
<a name="l01071"></a>01071         {
<a name="l01072"></a>01072         <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = f_n_cols*f_n_rows;
<a name="l01073"></a>01073         <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l01074"></a>01074         
<a name="l01075"></a>01075         f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), n_elem*2);
<a name="l01076"></a>01076         
<a name="l01077"></a>01077         <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01078"></a>01078         
<a name="l01079"></a>01079         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01080"></a>01080           {
<a name="l01081"></a>01081           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01082"></a>01082             {
<a name="l01083"></a>01083             x.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i]);
<a name="l01084"></a>01084             ++i;
<a name="l01085"></a>01085             }
<a name="l01086"></a>01086           }
<a name="l01087"></a>01087         
<a name="l01088"></a>01088         }
<a name="l01089"></a>01089       
<a name="l01090"></a>01090       }
<a name="l01091"></a>01091     
<a name="l01092"></a>01092     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01093"></a>01093       {
<a name="l01094"></a>01094       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01095"></a>01095       load_okay = <span class="keyword">false</span>;
<a name="l01096"></a>01096       }
<a name="l01097"></a>01097     }
<a name="l01098"></a>01098   <span class="keywordflow">else</span>
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l01101"></a>01101     load_okay = <span class="keyword">false</span>;
<a name="l01102"></a>01102     }
<a name="l01103"></a>01103   
<a name="l01104"></a>01104   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01105"></a>01105     {
<a name="l01106"></a>01106     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01107"></a>01107     }
<a name="l01108"></a>01108   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga672f562ded628be461b769c7110264b3"></a><!-- doxytag: member="diskio::load_pgm_binary" ref="ga672f562ded628be461b769c7110264b3" args="(Mat&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_pgm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a PGM greyscale image as a matrix. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01116">1116</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01117"></a>01117   {
<a name="l01118"></a>01118   arma_extra_debug_sigprint();
<a name="l01119"></a>01119   
<a name="l01120"></a>01120   <a class="code" href="a00164.html" title="Dense matrix class.">uchar_mat</a> tmp;
<a name="l01121"></a>01121   tmp.<a class="code" href="a00673.html#gadc2d8e5aa706f9e181f7d94bc5698eec" title="load a matrix from a file">load</a>(name);
<a name="l01122"></a>01122   x = <a class="code" href="a00024.html">conv_to&lt; Mat&lt; std::complex&lt;T&gt;</a> &gt; &gt;::from(tmp);
<a name="l01123"></a>01123   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga7c35415b2c32ccc17cf0b3c8ef5c4c6d"></a><!-- doxytag: member="diskio::load_auto_detect" ref="ga7c35415b2c32ccc17cf0b3c8ef5c4c6d" args="(Mat&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00164.html">Mat</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a matrix by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01131">1131</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00828">load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00905">load_arma_binary()</a>, <a class="el" href="a00406_source.html#l00994">load_pgm_binary()</a>, <a class="el" href="a00406_source.html#l00722">load_raw_ascii()</a>, and <a class="el" href="a00489_source.html#l01880">Mat&lt; eT &gt;::reset()</a>.</p>

<p>Referenced by <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00408_source.html#l00850">field_aux::load()</a>, and <a class="el" href="a00401_source.html#l01393">Cube&lt; eT &gt;::load()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01132"></a>01132   {
<a name="l01133"></a>01133   arma_extra_debug_sigprint();
<a name="l01134"></a>01134   
<a name="l01135"></a>01135   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_TXT = <span class="stringliteral">&quot;ARMA_MAT_TXT&quot;</span>;
<a name="l01136"></a>01136   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_MAT_BIN = <span class="stringliteral">&quot;ARMA_MAT_BIN&quot;</span>;
<a name="l01137"></a>01137   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P5 = <span class="stringliteral">&quot;P5&quot;</span>;
<a name="l01138"></a>01138   
<a name="l01139"></a>01139   std::fstream f;
<a name="l01140"></a>01140   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01141"></a>01141   
<a name="l01142"></a>01142   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01143"></a>01143     {
<a name="l01144"></a>01144     x.<a class="code" href="a00673.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a>();
<a name="l01145"></a>01145     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147   <span class="keywordflow">else</span>
<a name="l01148"></a>01148     {
<a name="l01149"></a>01149     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_MAT_TXT.length() + 1);
<a name="l01150"></a>01150     
<a name="l01151"></a>01151     f.read(raw_header.memptr(), ARMA_MAT_TXT.length());
<a name="l01152"></a>01152     raw_header[ARMA_MAT_TXT.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01153"></a>01153     
<a name="l01154"></a>01154     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01155"></a>01155     
<a name="l01156"></a>01156     <span class="keywordflow">if</span>(ARMA_MAT_TXT == header.substr(0,ARMA_MAT_TXT.length()))
<a name="l01157"></a>01157       {
<a name="l01158"></a>01158       <a class="code" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name);
<a name="l01159"></a>01159       }
<a name="l01160"></a>01160     <span class="keywordflow">else</span>
<a name="l01161"></a>01161     <span class="keywordflow">if</span>(ARMA_MAT_BIN == header.substr(0,ARMA_MAT_BIN.length()))
<a name="l01162"></a>01162       {
<a name="l01163"></a>01163       <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name);
<a name="l01164"></a>01164       }
<a name="l01165"></a>01165     <span class="keywordflow">else</span>
<a name="l01166"></a>01166     <span class="keywordflow">if</span>(P5 == header.substr(0,P5.length()))
<a name="l01167"></a>01167       {
<a name="l01168"></a>01168       <a class="code" href="a00608.html#ga114a20791e59f5a1ad076c0a6153c634" title="Load a PGM greyscale image as a matrix.">load_pgm_binary</a>(x, name);
<a name="l01169"></a>01169       }
<a name="l01170"></a>01170     <span class="keywordflow">else</span>
<a name="l01171"></a>01171       {
<a name="l01172"></a>01172       <a class="code" href="a00608.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name);
<a name="l01173"></a>01173       }
<a name="l01174"></a>01174     
<a name="l01175"></a>01175     f.close();
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177   
<a name="l01178"></a>01178   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga174fcb65d0726a0b074cb638cf09d6b0"></a><!-- doxytag: member="diskio::save_raw_ascii" ref="ga174fcb65d0726a0b074cb638cf09d6b0" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_raw_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube as raw text (no header, human readable). </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01190">1190</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00401_source.html#l01018">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01191"></a>01191   {
<a name="l01192"></a>01192   arma_extra_debug_sigprint();
<a name="l01193"></a>01193   
<a name="l01194"></a>01194   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01195"></a>01195   
<a name="l01196"></a>01196   std::fstream f(tmp_name.c_str(), std::fstream::out);
<a name="l01197"></a>01197   
<a name="l01198"></a>01198   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01199"></a>01199     {
<a name="l01200"></a>01200     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, tmp_name);
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202   <span class="keywordflow">else</span>
<a name="l01203"></a>01203     {
<a name="l01204"></a>01204     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l01205"></a>01205     
<a name="l01206"></a>01206     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l01207"></a>01207     
<a name="l01208"></a>01208     <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01209"></a>01209       {
<a name="l01210"></a>01210       f.setf(ios::scientific);
<a name="l01211"></a>01211       f.precision(8);
<a name="l01212"></a>01212       cell_width = 16;
<a name="l01213"></a>01213       }
<a name="l01214"></a>01214     
<a name="l01215"></a>01215     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01216"></a>01216       {
<a name="l01217"></a>01217       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01218"></a>01218         {
<a name="l01219"></a>01219         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01220"></a>01220           {
<a name="l01221"></a>01221           f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l01222"></a>01222           
<a name="l01223"></a>01223           <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01224"></a>01224             {
<a name="l01225"></a>01225             f.width(cell_width);
<a name="l01226"></a>01226             }
<a name="l01227"></a>01227           
<a name="l01228"></a>01228           f &lt;&lt; x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01229"></a>01229           }
<a name="l01230"></a>01230           
<a name="l01231"></a>01231         f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l01232"></a>01232         }
<a name="l01233"></a>01233       }
<a name="l01234"></a>01234     
<a name="l01235"></a>01235     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01236"></a>01236     
<a name="l01237"></a>01237     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01238"></a>01238     
<a name="l01239"></a>01239     f.flush();
<a name="l01240"></a>01240     f.close();
<a name="l01241"></a>01241     
<a name="l01242"></a>01242     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01243"></a>01243       {
<a name="l01244"></a>01244       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01245"></a>01245       }
<a name="l01246"></a>01246     }
<a name="l01247"></a>01247   
<a name="l01248"></a>01248   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga144d1cf32717082303ca3507398f495a"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="ga144d1cf32717082303ca3507398f495a" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01257">1257</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00406_source.html#l00418">safe_rename()</a>, and <a class="el" href="a00406_source.html#l00509">save_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01258"></a>01258   {
<a name="l01259"></a>01259   arma_extra_debug_sigprint();
<a name="l01260"></a>01260   
<a name="l01261"></a>01261   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01262"></a>01262   
<a name="l01263"></a>01263   std::ofstream f(tmp_name.c_str());
<a name="l01264"></a>01264   
<a name="l01265"></a>01265   <a class="code" href="a00608.html#ga00d2191a8f08a1a10926273bb91a766a" title="Save a matrix in text format (human readable), with a header that indicates the matrix...">diskio::save_arma_ascii</a>(x, tmp_name, f);
<a name="l01266"></a>01266   
<a name="l01267"></a>01267   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01268"></a>01268   
<a name="l01269"></a>01269   f.flush();
<a name="l01270"></a>01270   f.close();
<a name="l01271"></a>01271   
<a name="l01272"></a>01272   <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01273"></a>01273   
<a name="l01274"></a>01274   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01275"></a>01275     {
<a name="l01276"></a>01276     <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01277"></a>01277     }
<a name="l01278"></a>01278   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab27bd44f095e1c68e8a52bebd2900802"></a><!-- doxytag: member="diskio::save_arma_ascii" ref="gab27bd44f095e1c68e8a52bebd2900802" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_ascii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01287">1287</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00401_source.html#l01018">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00028">gen_txt_header()</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, and <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01288"></a>01288   {
<a name="l01289"></a>01289   arma_extra_debug_sigprint();
<a name="l01290"></a>01290   
<a name="l01291"></a>01291   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01292"></a>01292     {
<a name="l01293"></a>01293     arma_debug_print(<span class="stringliteral">&quot;unable to write &quot;</span>, name);
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295   <span class="keywordflow">else</span>
<a name="l01296"></a>01296     {
<a name="l01297"></a>01297     <span class="keyword">const</span> ios::fmtflags orig_flags = f.flags();
<a name="l01298"></a>01298     
<a name="l01299"></a>01299     f &lt;&lt; <a class="code" href="a00608.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01300"></a>01300     f &lt;&lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01301"></a>01301     
<a name="l01302"></a>01302     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> cell_width;
<a name="l01303"></a>01303     
<a name="l01304"></a>01304     <span class="comment">// TODO: need sane values for complex numbers</span>
<a name="l01305"></a>01305     
<a name="l01306"></a>01306     <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )
<a name="l01307"></a>01307       {
<a name="l01308"></a>01308       f.setf(ios::scientific);
<a name="l01309"></a>01309       f.precision(8);
<a name="l01310"></a>01310       cell_width = 16;
<a name="l01311"></a>01311       }
<a name="l01312"></a>01312       
<a name="l01313"></a>01313     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01314"></a>01314       {
<a name="l01315"></a>01315       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01316"></a>01316         {
<a name="l01317"></a>01317         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01318"></a>01318           {
<a name="l01319"></a>01319           f.put(<span class="charliteral">&apos; &apos;</span>);
<a name="l01320"></a>01320           
<a name="l01321"></a>01321           <span class="keywordflow">if</span>( (<a class="code" href="a00093.html">is_float&lt;eT&gt;::value</a> == <span class="keyword">true</span>) || (<a class="code" href="a00091.html">is_double&lt;eT&gt;::value</a> == <span class="keyword">true</span>) )        
<a name="l01322"></a>01322             {
<a name="l01323"></a>01323             f.width(cell_width);
<a name="l01324"></a>01324             }
<a name="l01325"></a>01325           
<a name="l01326"></a>01326           f &lt;&lt; x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01327"></a>01327           }
<a name="l01328"></a>01328         
<a name="l01329"></a>01329         f.put(<span class="charliteral">&apos;\n&apos;</span>);
<a name="l01330"></a>01330         }
<a name="l01331"></a>01331       }
<a name="l01332"></a>01332     
<a name="l01333"></a>01333     f.flags(orig_flags);
<a name="l01334"></a>01334     }
<a name="l01335"></a>01335   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga26ac154aece92b7be2247de51e1f7d66"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga26ac154aece92b7be2247de51e1f7d66" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in binary format, with a header that stores the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01344">1344</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00406_source.html#l00418">safe_rename()</a>, and <a class="el" href="a00406_source.html#l00593">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01345"></a>01345   {
<a name="l01346"></a>01346   arma_extra_debug_sigprint();
<a name="l01347"></a>01347   
<a name="l01348"></a>01348   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01349"></a>01349   
<a name="l01350"></a>01350   std::ofstream f(tmp_name.c_str(), std::fstream::binary);
<a name="l01351"></a>01351   
<a name="l01352"></a>01352   <a class="code" href="a00608.html#gaffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x, tmp_name, f);
<a name="l01353"></a>01353   
<a name="l01354"></a>01354   <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01355"></a>01355   
<a name="l01356"></a>01356   f.flush();
<a name="l01357"></a>01357   f.close();
<a name="l01358"></a>01358   
<a name="l01359"></a>01359   <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>( writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01360"></a>01360   
<a name="l01361"></a>01361   <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363     <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01364"></a>01364     }
<a name="l01365"></a>01365   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaeb415f13cdadc3c8b35db264a600005e"></a><!-- doxytag: member="diskio::save_arma_binary" ref="gaeb415f13cdadc3c8b35db264a600005e" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ofstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ofstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a cube in binary format, with a header that stores the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01374">1374</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00098">gen_bin_header()</a>, <a class="el" href="a00402_source.html#l00041">Cube&lt; eT &gt;::mem</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, and <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01375"></a>01375   {
<a name="l01376"></a>01376   arma_extra_debug_sigprint();
<a name="l01377"></a>01377   
<a name="l01378"></a>01378   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01379"></a>01379     {
<a name="l01380"></a>01380     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unable to write &quot;</span>, name);
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382   <span class="keywordflow">else</span>
<a name="l01383"></a>01383     {
<a name="l01384"></a>01384     f &lt;&lt; <a class="code" href="a00608.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x) &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01385"></a>01385     f &lt;&lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos; &apos;</span> &lt;&lt; x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01386"></a>01386     
<a name="l01387"></a>01387     f.write(reinterpret_cast&lt;const char*&gt;(x.<a class="code" href="a00031.html#a5d762740f29569b8493d2d6372dc908d" title="pointer to the memory used by the cube (memory is read-only)">mem</a>), x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l01388"></a>01388     }
<a name="l01389"></a>01389   
<a name="l01390"></a>01390   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga35f015b5569d09e69d1562f3c087811e"></a><!-- doxytag: member="diskio::load_raw_ascii" ref="ga35f015b5569d09e69d1562f3c087811e" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_raw_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01399">1399</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00489_source.html#l01927">Mat&lt; eT &gt;::load()</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00401_source.html#l00594">Cube&lt; eT &gt;::slice()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01400"></a>01400   {
<a name="l01401"></a>01401   arma_extra_debug_sigprint();
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a> tmp;
<a name="l01404"></a>01404   tmp.<a class="code" href="a00673.html#gadc2d8e5aa706f9e181f7d94bc5698eec" title="load a matrix from a file">load</a>(name);
<a name="l01405"></a>01405   
<a name="l01406"></a>01406   x.<a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(tmp.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>, tmp.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>, 1);
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   <span class="keywordflow">if</span>(x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> &gt; 0)
<a name="l01409"></a>01409     {
<a name="l01410"></a>01410     x.<a class="code" href="a00605.html#ga278055e14ab971acffa2d4616cc65f68" title="provide the reference to the matrix representing a single slice">slice</a>(0) = tmp;
<a name="l01411"></a>01411     }
<a name="l01412"></a>01412   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga8c671488b92ad364dbc2c4cba859f718"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="ga8c671488b92ad364dbc2c4cba859f718" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01421">1421</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00828">load_arma_ascii()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01422"></a>01422   {
<a name="l01423"></a>01423   arma_extra_debug_sigprint();
<a name="l01424"></a>01424   
<a name="l01425"></a>01425   std::ifstream f(name.c_str());
<a name="l01426"></a>01426   <a class="code" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">diskio::load_arma_ascii</a>(x, name, f);
<a name="l01427"></a>01427   f.close();
<a name="l01428"></a>01428   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf0e1e21459b992bef79c0cb714cbbde9"></a><!-- doxytag: member="diskio::load_arma_ascii" ref="gaf0e1e21459b992bef79c0cb714cbbde9" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_ascii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01437">1437</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00401_source.html#l01018">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00028">gen_txt_header()</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00401_source.html#l01346">Cube&lt; eT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01438"></a>01438   {
<a name="l01439"></a>01439   arma_extra_debug_sigprint();
<a name="l01440"></a>01440   
<a name="l01441"></a>01441   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01442"></a>01442   
<a name="l01443"></a>01443   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01444"></a>01444     {
<a name="l01445"></a>01445     load_okay = <span class="keyword">false</span>;
<a name="l01446"></a>01446     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01447"></a>01447     }
<a name="l01448"></a>01448   <span class="keywordflow">else</span>
<a name="l01449"></a>01449     {
<a name="l01450"></a>01450     std::string f_header;
<a name="l01451"></a>01451     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01452"></a>01452     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01453"></a>01453     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_slices;
<a name="l01454"></a>01454     
<a name="l01455"></a>01455     f &gt;&gt; f_header;
<a name="l01456"></a>01456     f &gt;&gt; f_n_rows;
<a name="l01457"></a>01457     f &gt;&gt; f_n_cols;
<a name="l01458"></a>01458     f &gt;&gt; f_n_slices;
<a name="l01459"></a>01459     
<a name="l01460"></a>01460     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00608.html#gaa99252a20f066762a161ca8ceb9b2c29" title="Generate the first line of the header used for saving matrices in text format. Format:...">diskio::gen_txt_header</a>(x))
<a name="l01461"></a>01461       {
<a name="l01462"></a>01462       x.<a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, f_n_slices);
<a name="l01463"></a>01463 
<a name="l01464"></a>01464       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> slice=0; slice &lt; x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a>; ++slice)
<a name="l01465"></a>01465         {
<a name="l01466"></a>01466         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l01467"></a>01467           {
<a name="l01468"></a>01468           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l01469"></a>01469             {
<a name="l01470"></a>01470             f &gt;&gt; x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,slice);
<a name="l01471"></a>01471             }
<a name="l01472"></a>01472           }
<a name="l01473"></a>01473         }
<a name="l01474"></a>01474       
<a name="l01475"></a>01475       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01476"></a>01476         {
<a name="l01477"></a>01477         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01478"></a>01478         load_okay = <span class="keyword">false</span>;
<a name="l01479"></a>01479         }
<a name="l01480"></a>01480       }
<a name="l01481"></a>01481     <span class="keywordflow">else</span>
<a name="l01482"></a>01482       {
<a name="l01483"></a>01483       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name );
<a name="l01484"></a>01484       load_okay = <span class="keyword">false</span>;
<a name="l01485"></a>01485       }
<a name="l01486"></a>01486   
<a name="l01487"></a>01487     }
<a name="l01488"></a>01488   
<a name="l01489"></a>01489   
<a name="l01490"></a>01490   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01491"></a>01491     {
<a name="l01492"></a>01492     x.<a class="code" href="a00605.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01493"></a>01493     }
<a name="l01494"></a>01494   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga089f7fe67d64e445cd716cae5d4aad65"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga089f7fe67d64e445cd716cae5d4aad65" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a cube in binary format, with a header that indicates the cube type as well as its dimensions. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01503">1503</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00905">load_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01504"></a>01504   {
<a name="l01505"></a>01505   arma_extra_debug_sigprint();
<a name="l01506"></a>01506   
<a name="l01507"></a>01507   std::ifstream f;
<a name="l01508"></a>01508   f.open(name.c_str(), std::fstream::binary);
<a name="l01509"></a>01509   <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x, name, f);
<a name="l01510"></a>01510   f.close();
<a name="l01511"></a>01511   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab91a1e9d8c23aaa07474af24731e3d3d"></a><!-- doxytag: member="diskio::load_arma_binary" ref="gab91a1e9d8c23aaa07474af24731e3d3d" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name, std::ifstream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01518">1518</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00098">gen_bin_header()</a>, <a class="el" href="a00401_source.html#l01105">Cube&lt; eT &gt;::memptr()</a>, <a class="el" href="a00402_source.html#l00037">Cube&lt; eT &gt;::n_elem</a>, <a class="el" href="a00401_source.html#l01346">Cube&lt; eT &gt;::reset()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01519"></a>01519   {
<a name="l01520"></a>01520   arma_extra_debug_sigprint();
<a name="l01521"></a>01521   
<a name="l01522"></a>01522   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01523"></a>01523   
<a name="l01524"></a>01524   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01525"></a>01525     {
<a name="l01526"></a>01526     load_okay = <span class="keyword">false</span>;
<a name="l01527"></a>01527     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01528"></a>01528     }
<a name="l01529"></a>01529   <span class="keywordflow">else</span>
<a name="l01530"></a>01530     {
<a name="l01531"></a>01531     std::string f_header;
<a name="l01532"></a>01532     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01533"></a>01533     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01534"></a>01534     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_slices;
<a name="l01535"></a>01535     
<a name="l01536"></a>01536     f &gt;&gt; f_header;
<a name="l01537"></a>01537     f &gt;&gt; f_n_rows;
<a name="l01538"></a>01538     f &gt;&gt; f_n_cols;
<a name="l01539"></a>01539     f &gt;&gt; f_n_slices;
<a name="l01540"></a>01540     
<a name="l01541"></a>01541     <span class="keywordflow">if</span>(f_header == <a class="code" href="a00608.html#gafea81731918e03aedf946fafceda27b5" title="Generate the first line of the header used for saving matrices in binary format....">diskio::gen_bin_header</a>(x))
<a name="l01542"></a>01542       {
<a name="l01543"></a>01543       <span class="comment">//f.seekg(1, ios::cur);  // NOTE: this may not be portable, as on a Windows machine a newline could be two characters</span>
<a name="l01544"></a>01544       f.get();
<a name="l01545"></a>01545       
<a name="l01546"></a>01546       x.<a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, f_n_slices);
<a name="l01547"></a>01547       f.read( reinterpret_cast&lt;char *&gt;(x.<a class="code" href="a00605.html#ga1e0aa001a72a50700fc151a655ece615" title="returns a pointer to array of eTs used by the cube">memptr</a>()), x.<a class="code" href="a00031.html#a902bd50808663f9eec272591651ff21a" title="number of elements in the cube (read-only)">n_elem</a>*<span class="keyword">sizeof</span>(eT));
<a name="l01548"></a>01548       
<a name="l01549"></a>01549       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01550"></a>01550         {
<a name="l01551"></a>01551         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01552"></a>01552         load_okay = <span class="keyword">false</span>;
<a name="l01553"></a>01553         }
<a name="l01554"></a>01554       }
<a name="l01555"></a>01555     <span class="keywordflow">else</span>
<a name="l01556"></a>01556       {
<a name="l01557"></a>01557       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;incorrect header in &quot;</span>, name);
<a name="l01558"></a>01558       load_okay = <span class="keyword">false</span>;
<a name="l01559"></a>01559       }
<a name="l01560"></a>01560     
<a name="l01561"></a>01561     }
<a name="l01562"></a>01562   
<a name="l01563"></a>01563   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01564"></a>01564     {
<a name="l01565"></a>01565     x.<a class="code" href="a00605.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01566"></a>01566     }
<a name="l01567"></a>01567   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae1a42ba07bf3a86e11ab082cb96a45e9"></a><!-- doxytag: member="diskio::load_auto_detect" ref="gae1a42ba07bf3a86e11ab082cb96a45e9" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a cube by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01575">1575</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00406_source.html#l00828">load_arma_ascii()</a>, <a class="el" href="a00406_source.html#l00905">load_arma_binary()</a>, <a class="el" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>, <a class="el" href="a00406_source.html#l00722">load_raw_ascii()</a>, and <a class="el" href="a00401_source.html#l01346">Cube&lt; eT &gt;::reset()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01576"></a>01576   {
<a name="l01577"></a>01577   arma_extra_debug_sigprint();
<a name="l01578"></a>01578   
<a name="l01579"></a>01579   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_CUB_TXT = <span class="stringliteral">&quot;ARMA_CUB_TXT&quot;</span>;
<a name="l01580"></a>01580   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_CUB_BIN = <span class="stringliteral">&quot;ARMA_CUB_BIN&quot;</span>;
<a name="l01581"></a>01581   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P6 = <span class="stringliteral">&quot;P6&quot;</span>;
<a name="l01582"></a>01582   
<a name="l01583"></a>01583   std::fstream f;
<a name="l01584"></a>01584   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01585"></a>01585   
<a name="l01586"></a>01586   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01587"></a>01587     {
<a name="l01588"></a>01588     x.<a class="code" href="a00605.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l01589"></a>01589     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01590"></a>01590     }
<a name="l01591"></a>01591   <span class="keywordflow">else</span>
<a name="l01592"></a>01592     {
<a name="l01593"></a>01593     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_CUB_TXT.length() + 1);
<a name="l01594"></a>01594     
<a name="l01595"></a>01595     f.read(raw_header.memptr(), ARMA_CUB_TXT.length());
<a name="l01596"></a>01596     raw_header[ARMA_CUB_TXT.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01597"></a>01597     
<a name="l01598"></a>01598     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01599"></a>01599     
<a name="l01600"></a>01600     <span class="keywordflow">if</span>(ARMA_CUB_TXT == header.substr(0, ARMA_CUB_TXT.length()))
<a name="l01601"></a>01601       {
<a name="l01602"></a>01602       <a class="code" href="a00608.html#ga81f825e8e6474ff560b71cb1e144dbd7" title="Load a matrix in text format (human readable), with a header that indicates the matrix...">load_arma_ascii</a>(x, name);
<a name="l01603"></a>01603       }
<a name="l01604"></a>01604     <span class="keywordflow">else</span>
<a name="l01605"></a>01605     <span class="keywordflow">if</span>(ARMA_CUB_BIN == header.substr(0, ARMA_CUB_BIN.length()))
<a name="l01606"></a>01606       {
<a name="l01607"></a>01607       <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name);
<a name="l01608"></a>01608       }
<a name="l01609"></a>01609     <span class="keywordflow">else</span>
<a name="l01610"></a>01610     <span class="keywordflow">if</span>(P6 == header.substr(0,P6.length()))
<a name="l01611"></a>01611       {
<a name="l01612"></a>01612       <a class="code" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary</a>(x, name);
<a name="l01613"></a>01613       }
<a name="l01614"></a>01614     <span class="keywordflow">else</span>
<a name="l01615"></a>01615       {
<a name="l01616"></a>01616       <a class="code" href="a00608.html#ga400632d14748572e5faeecb30e7915c7" title="Load a matrix as raw text (no header, human readable). Can read matrices saved as...">load_raw_ascii</a>(x, name);
<a name="l01617"></a>01617       }
<a name="l01618"></a>01618     
<a name="l01619"></a>01619     f.close();
<a name="l01620"></a>01620     }
<a name="l01621"></a>01621   
<a name="l01622"></a>01622   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2c60a2f31130b27a3cb1ad020660cc21"></a><!-- doxytag: member="diskio::save_arma_binary" ref="ga2c60a2f31130b27a3cb1ad020660cc21" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_arma_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01636">1636</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00409_source.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00409_source.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00409_source.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00406_source.html#l00418">safe_rename()</a>, and <a class="el" href="a00406_source.html#l00593">save_arma_binary()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01637"></a>01637   {
<a name="l01638"></a>01638   arma_extra_debug_sigprint();
<a name="l01639"></a>01639   
<a name="l01640"></a>01640   <a class="code" href="a00016.html">arma_type_check&lt; (is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &amp;&amp; (<a class="code" href="a00087.html">is_Cube&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &gt;::apply();
<a name="l01641"></a>01641   
<a name="l01642"></a>01642   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01643"></a>01643   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01644"></a>01644   
<a name="l01645"></a>01645   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01646"></a>01646     {
<a name="l01647"></a>01647     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l01648"></a>01648     }
<a name="l01649"></a>01649   <span class="keywordflow">else</span>
<a name="l01650"></a>01650     {
<a name="l01651"></a>01651     f &lt;&lt; <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01652"></a>01652     f &lt;&lt; x.<a class="code" href="a00043.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01653"></a>01653     f &lt;&lt; x.<a class="code" href="a00043.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01654"></a>01654     
<a name="l01655"></a>01655     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00043.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01656"></a>01656       {
<a name="l01657"></a>01657       <a class="code" href="a00608.html#gaffe954d2c7ad14e7d5cc1be747cb2a63" title="Save a matrix in binary format, with a header that stores the matrix type as well...">diskio::save_arma_binary</a>(x[i], tmp_name, f);
<a name="l01658"></a>01658       }
<a name="l01659"></a>01659     
<a name="l01660"></a>01660     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01661"></a>01661     
<a name="l01662"></a>01662     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01663"></a>01663     
<a name="l01664"></a>01664     f.flush();
<a name="l01665"></a>01665     f.close();
<a name="l01666"></a>01666     
<a name="l01667"></a>01667     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01668"></a>01668       {
<a name="l01669"></a>01669       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01670"></a>01670       }
<a name="l01671"></a>01671     
<a name="l01672"></a>01672     }
<a name="l01673"></a>01673   
<a name="l01674"></a>01674   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga97df7a8f223054be0b5135ff783ab7d4"></a><!-- doxytag: member="diskio::load_arma_binary" ref="ga97df7a8f223054be0b5135ff783ab7d4" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_arma_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01681">1681</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00905">load_arma_binary()</a>, <a class="el" href="a00409_source.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00408_source.html#l00536">field&lt; oT &gt;::reset()</a>, and <a class="el" href="a00408_source.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01682"></a>01682   {
<a name="l01683"></a>01683   arma_extra_debug_sigprint();
<a name="l01684"></a>01684   
<a name="l01685"></a>01685   <a class="code" href="a00016.html">arma_type_check&lt; (is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &amp;&amp; (<a class="code" href="a00087.html">is_Cube&lt;T1&gt;::value</a> == <span class="keyword">false</span>) &gt;::apply();
<a name="l01686"></a>01686   
<a name="l01687"></a>01687   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01688"></a>01688   
<a name="l01689"></a>01689   std::ifstream f( name.c_str(), std::fstream::binary );
<a name="l01690"></a>01690   
<a name="l01691"></a>01691   <span class="keywordflow">if</span>(f.fail())
<a name="l01692"></a>01692     {
<a name="l01693"></a>01693     load_okay = <span class="keyword">false</span>;
<a name="l01694"></a>01694     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696   <span class="keywordflow">else</span>
<a name="l01697"></a>01697     {
<a name="l01698"></a>01698     std::string f_type;
<a name="l01699"></a>01699     f &gt;&gt; f_type;
<a name="l01700"></a>01700     
<a name="l01701"></a>01701     <span class="keywordflow">if</span>(f_type != <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span>)
<a name="l01702"></a>01702       {
<a name="l01703"></a>01703       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported field type in &quot;</span>, name);
<a name="l01704"></a>01704       load_okay = <span class="keyword">false</span>;
<a name="l01705"></a>01705       }
<a name="l01706"></a>01706     <span class="keywordflow">else</span>
<a name="l01707"></a>01707       {
<a name="l01708"></a>01708       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows;
<a name="l01709"></a>01709       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols;
<a name="l01710"></a>01710     
<a name="l01711"></a>01711       f &gt;&gt; f_n_rows;
<a name="l01712"></a>01712       f &gt;&gt; f_n_cols;
<a name="l01713"></a>01713       
<a name="l01714"></a>01714       x.<a class="code" href="a00609.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01715"></a>01715       
<a name="l01716"></a>01716       f.get();      
<a name="l01717"></a>01717       
<a name="l01718"></a>01718       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=0; i&lt;x.<a class="code" href="a00043.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a>; ++i)
<a name="l01719"></a>01719         {
<a name="l01720"></a>01720         <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">diskio::load_arma_binary</a>(x[i], name, f);
<a name="l01721"></a>01721         
<a name="l01722"></a>01722         <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01723"></a>01723           {
<a name="l01724"></a>01724           <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l01725"></a>01725           load_okay = <span class="keyword">false</span>;
<a name="l01726"></a>01726           <span class="keywordflow">break</span>;
<a name="l01727"></a>01727           }
<a name="l01728"></a>01728         }
<a name="l01729"></a>01729       }
<a name="l01730"></a>01730     }
<a name="l01731"></a>01731   
<a name="l01732"></a>01732   f.close();
<a name="l01733"></a>01733   
<a name="l01734"></a>01734   
<a name="l01735"></a>01735   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01736"></a>01736     {
<a name="l01737"></a>01737     x.<a class="code" href="a00609.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01738"></a>01738     }
<a name="l01739"></a>01739   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga83f09e96c16bb21f7185d867c9845efe"></a><!-- doxytag: member="diskio::save_std_string" ref="ga83f09e96c16bb21f7185d867c9845efe" args="(const field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_std_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01745">1745</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00408_source.html#l00267">field&lt; oT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00409_source.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00409_source.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p>Referenced by <a class="el" href="a00408_source.html#l01033">field_aux::save()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01746"></a>01746   {
<a name="l01747"></a>01747   arma_extra_debug_sigprint();
<a name="l01748"></a>01748   
<a name="l01749"></a>01749   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l01750"></a>01750   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l01751"></a>01751   
<a name="l01752"></a>01752   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01753"></a>01753     {
<a name="l01754"></a>01754     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756   <span class="keywordflow">else</span>
<a name="l01757"></a>01757     {
<a name="l01758"></a>01758     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row&lt;x.<a class="code" href="a00043.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l01759"></a>01759     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col&lt;x.<a class="code" href="a00043.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l01760"></a>01760       {
<a name="l01761"></a>01761       f &lt;&lt; x.<a class="code" href="a00609.html#ga0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l01762"></a>01762       
<a name="l01763"></a>01763       <span class="keywordflow">if</span>(col &lt; x.<a class="code" href="a00043.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>-1)
<a name="l01764"></a>01764         {
<a name="l01765"></a>01765         f &lt;&lt; <span class="charliteral">&apos; &apos;</span>;
<a name="l01766"></a>01766         }
<a name="l01767"></a>01767       <span class="keywordflow">else</span>
<a name="l01768"></a>01768         {
<a name="l01769"></a>01769         f &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771       }
<a name="l01772"></a>01772     
<a name="l01773"></a>01773     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l01774"></a>01774     
<a name="l01775"></a>01775     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l01776"></a>01776     
<a name="l01777"></a>01777     f.flush();
<a name="l01778"></a>01778     f.close();
<a name="l01779"></a>01779     
<a name="l01780"></a>01780     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l01781"></a>01781       {
<a name="l01782"></a>01782       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l01783"></a>01783       }
<a name="l01784"></a>01784     
<a name="l01785"></a>01785     }
<a name="l01786"></a>01786   
<a name="l01787"></a>01787   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6026e50ca294ce23eb2bef6f4e3765e4"></a><!-- doxytag: member="diskio::load_std_string" ref="ga6026e50ca294ce23eb2bef6f4e3765e4" args="(field&lt; std::string &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_std_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">field</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01793">1793</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00408_source.html#l00267">field&lt; oT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00409_source.html#l00032">field&lt; oT &gt;::n_cols</a>, <a class="el" href="a00409_source.html#l00031">field&lt; oT &gt;::n_rows</a>, <a class="el" href="a00408_source.html#l00536">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00408_source.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p>Referenced by <a class="el" href="a00408_source.html#l01044">field_aux::load()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01794"></a>01794   {
<a name="l01795"></a>01795   arma_extra_debug_sigprint();
<a name="l01796"></a>01796   
<a name="l01797"></a>01797   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01798"></a>01798   
<a name="l01799"></a>01799   std::ifstream f( name.c_str() );
<a name="l01800"></a>01800   
<a name="l01801"></a>01801   <span class="keywordflow">if</span>(f.fail())
<a name="l01802"></a>01802     {
<a name="l01803"></a>01803     load_okay = <span class="keyword">false</span>;
<a name="l01804"></a>01804     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01805"></a>01805     }
<a name="l01806"></a>01806   <span class="keywordflow">else</span>
<a name="l01807"></a>01807     {
<a name="l01808"></a>01808     <span class="comment">//</span>
<a name="l01809"></a>01809     <span class="comment">// work out the size</span>
<a name="l01810"></a>01810     
<a name="l01811"></a>01811     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01812"></a>01812     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01813"></a>01813     
<a name="l01814"></a>01814     <span class="keywordtype">bool</span> f_n_cols_found = <span class="keyword">false</span>;
<a name="l01815"></a>01815     
<a name="l01816"></a>01816     std::string line_string;
<a name="l01817"></a>01817     std::string token;
<a name="l01818"></a>01818     
<a name="l01819"></a>01819     <span class="keywordflow">while</span>( (f.good() == <span class="keyword">true</span>) &amp;&amp; (load_okay == <span class="keyword">true</span>) )
<a name="l01820"></a>01820       {
<a name="l01821"></a>01821       std::getline(f, line_string);
<a name="l01822"></a>01822       <span class="keywordflow">if</span>(line_string.size() == 0)
<a name="l01823"></a>01823         <span class="keywordflow">break</span>;
<a name="l01824"></a>01824       
<a name="l01825"></a>01825       std::stringstream line_stream(line_string);
<a name="l01826"></a>01826       
<a name="l01827"></a>01827       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> line_n_cols = 0;
<a name="l01828"></a>01828       <span class="keywordflow">while</span> (line_stream &gt;&gt; token)
<a name="l01829"></a>01829         line_n_cols++;
<a name="l01830"></a>01830       
<a name="l01831"></a>01831       <span class="keywordflow">if</span>(f_n_cols_found == <span class="keyword">false</span>)
<a name="l01832"></a>01832         {
<a name="l01833"></a>01833         f_n_cols = line_n_cols;
<a name="l01834"></a>01834         f_n_cols_found = <span class="keyword">true</span>;
<a name="l01835"></a>01835         }
<a name="l01836"></a>01836       <span class="keywordflow">else</span>
<a name="l01837"></a>01837         {
<a name="l01838"></a>01838         <span class="keywordflow">if</span>(line_n_cols != f_n_cols)
<a name="l01839"></a>01839           {
<a name="l01840"></a>01840           load_okay = <span class="keyword">false</span>;
<a name="l01841"></a>01841           <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;inconsistent number of columns in &quot;</span>, name );
<a name="l01842"></a>01842           }
<a name="l01843"></a>01843         }
<a name="l01844"></a>01844       
<a name="l01845"></a>01845       ++f_n_rows;
<a name="l01846"></a>01846       }
<a name="l01847"></a>01847       
<a name="l01848"></a>01848     <span class="keywordflow">if</span>(load_okay == <span class="keyword">true</span>)
<a name="l01849"></a>01849       {
<a name="l01850"></a>01850       f.clear();
<a name="l01851"></a>01851       f.seekg(0, ios::beg);
<a name="l01852"></a>01852       <span class="comment">//f.seekg(start);</span>
<a name="l01853"></a>01853       
<a name="l01854"></a>01854       x.<a class="code" href="a00609.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(f_n_rows, f_n_cols);
<a name="l01855"></a>01855     
<a name="l01856"></a>01856       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00043.html#a98d956dc3c4571ff9d29ee3d709d0202" title="number of rows in the field (read-only)">n_rows</a>; ++row)
<a name="l01857"></a>01857         {
<a name="l01858"></a>01858         <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00043.html#ad33a934565f6e02edb4e7f6d1331d34a" title="number of columns in the field (read-only)">n_cols</a>; ++col)
<a name="l01859"></a>01859           {
<a name="l01860"></a>01860           f &gt;&gt; x.<a class="code" href="a00609.html#ga0e24e346da9e98e461bf32ad674216cf" title="element accessor; no bounds check">at</a>(row,col);
<a name="l01861"></a>01861           }
<a name="l01862"></a>01862         }
<a name="l01863"></a>01863       }
<a name="l01864"></a>01864     
<a name="l01865"></a>01865     <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l01866"></a>01866       {
<a name="l01867"></a>01867       load_okay = <span class="keyword">false</span>; 
<a name="l01868"></a>01868       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name );
<a name="l01869"></a>01869       }
<a name="l01870"></a>01870     
<a name="l01871"></a>01871     f.close();
<a name="l01872"></a>01872     }
<a name="l01873"></a>01873   
<a name="l01874"></a>01874   
<a name="l01875"></a>01875   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l01876"></a>01876     {
<a name="l01877"></a>01877     x.<a class="code" href="a00609.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01878"></a>01878     }
<a name="l01879"></a>01879   
<a name="l01880"></a>01880   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gac66e6e0cc9f7ef2a6bb1fadab19e90f9"></a><!-- doxytag: member="diskio::load_auto_detect" ref="gac66e6e0cc9f7ef2a6bb1fadab19e90f9" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_auto_detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to load a <a class="el" href="a00043.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type. </p>

<p>Definition at line <a class="el" href="a00406_source.html#l01888">1888</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00406_source.html#l00905">load_arma_binary()</a>, <a class="el" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary()</a>, and <a class="el" href="a00408_source.html#l00536">field&lt; oT &gt;::reset()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01889"></a>01889   {
<a name="l01890"></a>01890   arma_extra_debug_sigprint();
<a name="l01891"></a>01891   
<a name="l01892"></a>01892   <a class="code" href="a00016.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l01893"></a>01893   
<a name="l01894"></a>01894   <span class="keyword">static</span> <span class="keyword">const</span> std::string ARMA_FLD_BIN = <span class="stringliteral">&quot;ARMA_FLD_BIN&quot;</span>;
<a name="l01895"></a>01895   <span class="keyword">static</span> <span class="keyword">const</span> std::string           P6 = <span class="stringliteral">&quot;P6&quot;</span>;
<a name="l01896"></a>01896   
<a name="l01897"></a>01897   std::fstream f;
<a name="l01898"></a>01898   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01899"></a>01899   
<a name="l01900"></a>01900   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01901"></a>01901     {
<a name="l01902"></a>01902     x.<a class="code" href="a00609.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01903"></a>01903     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01904"></a>01904     }
<a name="l01905"></a>01905   <span class="keywordflow">else</span>
<a name="l01906"></a>01906     {
<a name="l01907"></a>01907     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;char&gt;</a> raw_header(ARMA_FLD_BIN.length() + 1);
<a name="l01908"></a>01908     
<a name="l01909"></a>01909     f.read(raw_header.memptr(), ARMA_FLD_BIN.length());
<a name="l01910"></a>01910     raw_header[ARMA_FLD_BIN.length()] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01911"></a>01911     
<a name="l01912"></a>01912     <span class="keyword">const</span> std::string header = raw_header.mem;
<a name="l01913"></a>01913     
<a name="l01914"></a>01914     <span class="keywordflow">if</span>(ARMA_FLD_BIN == header.substr(0,ARMA_FLD_BIN.length()))
<a name="l01915"></a>01915       {
<a name="l01916"></a>01916       <a class="code" href="a00608.html#ga8e0731ede58797f7638eda2a50af240f" title="Load a matrix in binary format, with a header that indicates the matrix type as well...">load_arma_binary</a>(x, name);
<a name="l01917"></a>01917       }
<a name="l01918"></a>01918     <span class="keywordflow">else</span>
<a name="l01919"></a>01919     <span class="keywordflow">if</span>(P6 == header.substr(0,P6.length()))
<a name="l01920"></a>01920       {
<a name="l01921"></a>01921       <a class="code" href="a00042.html#af99253ff5b74b240b49de9be42a5569d">load_ppm_binary</a>(x, name);
<a name="l01922"></a>01922       }
<a name="l01923"></a>01923     <span class="keywordflow">else</span>
<a name="l01924"></a>01924       {
<a name="l01925"></a>01925       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l01926"></a>01926       x.<a class="code" href="a00609.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l01927"></a>01927       }
<a name="l01928"></a>01928     
<a name="l01929"></a>01929     f.close();
<a name="l01930"></a>01930     }
<a name="l01931"></a>01931   
<a name="l01932"></a>01932   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="gade8fe65bb50cb3e7bb9129ff4af773ed"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="gade8fe65bb50cb3e7bb9129ff4af773ed" args="(Cube&lt; eT &gt; &amp;x, const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l01943">1943</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00401_source.html#l01018">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00567_source.html#l00194">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00406_source.html#l00973">pnm_skip_comments()</a>, <a class="el" href="a00401_source.html#l01346">Cube&lt; eT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00401_source.html#l01254">Cube&lt; eT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01944"></a>01944   {
<a name="l01945"></a>01945   arma_extra_debug_sigprint();
<a name="l01946"></a>01946   
<a name="l01947"></a>01947   std::fstream f;
<a name="l01948"></a>01948   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l01949"></a>01949   
<a name="l01950"></a>01950   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l01951"></a>01951   
<a name="l01952"></a>01952   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l01953"></a>01953     {
<a name="l01954"></a>01954     load_okay = <span class="keyword">false</span>;
<a name="l01955"></a>01955     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l01956"></a>01956     }
<a name="l01957"></a>01957   <span class="keywordflow">else</span>
<a name="l01958"></a>01958     {
<a name="l01959"></a>01959     std::string f_header;
<a name="l01960"></a>01960     f &gt;&gt; f_header;
<a name="l01961"></a>01961     
<a name="l01962"></a>01962     <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P6&quot;</span>)
<a name="l01963"></a>01963       {
<a name="l01964"></a>01964       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l01965"></a>01965       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l01966"></a>01966       <span class="keywordtype">int</span> f_maxval = 0;
<a name="l01967"></a>01967     
<a name="l01968"></a>01968       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01969"></a>01969     
<a name="l01970"></a>01970       f &gt;&gt; f_n_cols;
<a name="l01971"></a>01971       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01972"></a>01972     
<a name="l01973"></a>01973       f &gt;&gt; f_n_rows;
<a name="l01974"></a>01974       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l01975"></a>01975     
<a name="l01976"></a>01976       f &gt;&gt; f_maxval;
<a name="l01977"></a>01977       f.get();
<a name="l01978"></a>01978       
<a name="l01979"></a>01979       <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l01980"></a>01980         {
<a name="l01981"></a>01981         x.<a class="code" href="a00605.html#gac10bacf38c391e357e110e36b74c8863" title="change the cube to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows, f_n_cols, 3);
<a name="l01982"></a>01982         
<a name="l01983"></a>01983         <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l01984"></a>01984           {
<a name="l01985"></a>01985           <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l01986"></a>01986           <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l01987"></a>01987           
<a name="l01988"></a>01988           f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l01989"></a>01989           
<a name="l01990"></a>01990           <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l01991"></a>01991           
<a name="l01992"></a>01992           <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l01993"></a>01993           <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l01994"></a>01994           
<a name="l01995"></a>01995           
<a name="l01996"></a>01996           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l01997"></a>01997             {
<a name="l01998"></a>01998             <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l01999"></a>01999               {
<a name="l02000"></a>02000               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) = eT(tmp[i+0]);
<a name="l02001"></a>02001               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) = eT(tmp[i+1]);
<a name="l02002"></a>02002               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) = eT(tmp[i+2]);
<a name="l02003"></a>02003               i+=3;
<a name="l02004"></a>02004               }
<a name="l02005"></a>02005             
<a name="l02006"></a>02006             }
<a name="l02007"></a>02007           }
<a name="l02008"></a>02008         <span class="keywordflow">else</span>
<a name="l02009"></a>02009           {
<a name="l02010"></a>02010           <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02011"></a>02011           <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l02012"></a>02012           
<a name="l02013"></a>02013           f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), 2*n_elem);
<a name="l02014"></a>02014           
<a name="l02015"></a>02015           <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02016"></a>02016           
<a name="l02017"></a>02017           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02018"></a>02018             {
<a name="l02019"></a>02019             <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02020"></a>02020               {
<a name="l02021"></a>02021               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) = eT(tmp[i+0]);
<a name="l02022"></a>02022               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) = eT(tmp[i+1]);
<a name="l02023"></a>02023               x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) = eT(tmp[i+2]);
<a name="l02024"></a>02024               i+=3;
<a name="l02025"></a>02025               }
<a name="l02026"></a>02026             
<a name="l02027"></a>02027             }
<a name="l02028"></a>02028           
<a name="l02029"></a>02029           }
<a name="l02030"></a>02030         
<a name="l02031"></a>02031         }
<a name="l02032"></a>02032       
<a name="l02033"></a>02033       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l02034"></a>02034         {
<a name="l02035"></a>02035         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l02036"></a>02036         load_okay = <span class="keyword">false</span>;
<a name="l02037"></a>02037         }
<a name="l02038"></a>02038       
<a name="l02039"></a>02039       }
<a name="l02040"></a>02040     <span class="keywordflow">else</span>
<a name="l02041"></a>02041       {
<a name="l02042"></a>02042       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l02043"></a>02043       load_okay = <span class="keyword">false</span>;
<a name="l02044"></a>02044       }
<a name="l02045"></a>02045     
<a name="l02046"></a>02046     f.close();
<a name="l02047"></a>02047     }
<a name="l02048"></a>02048   
<a name="l02049"></a>02049   
<a name="l02050"></a>02050   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l02051"></a>02051     {
<a name="l02052"></a>02052     x.<a class="code" href="a00605.html#gaba9b3dcaf9379fc802c0bdb8b5db4bc9">reset</a>();
<a name="l02053"></a>02053     }
<a name="l02054"></a>02054   
<a name="l02055"></a>02055   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga287ba6a07f728ff3e54db5a1fe8bfd16"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ga287ba6a07f728ff3e54db5a1fe8bfd16" args="(const Cube&lt; eT &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">Cube</a>&lt; eT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l02062">2062</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00401_source.html#l01018">Cube&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00568_source.html#l00032">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="a00402_source.html#l00034">Cube&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00402_source.html#l00033">Cube&lt; eT &gt;::n_rows</a>, <a class="el" href="a00402_source.html#l00036">Cube&lt; eT &gt;::n_slices</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02063"></a>02063   {
<a name="l02064"></a>02064   arma_extra_debug_sigprint();
<a name="l02065"></a>02065   
<a name="l02066"></a>02066   arma_debug_check( (x.<a class="code" href="a00031.html#a44db2acf88521b88816d7d7c607f96d7" title="number of slices in the cube (read-only)">n_slices</a> != 3), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given cube must have exactly 3 slices&quot;</span> );
<a name="l02067"></a>02067   
<a name="l02068"></a>02068   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l02069"></a>02069   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l02070"></a>02070   
<a name="l02071"></a>02071   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02072"></a>02072     {
<a name="l02073"></a>02073     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l02074"></a>02074     }
<a name="l02075"></a>02075   <span class="keywordflow">else</span>
<a name="l02076"></a>02076     {
<a name="l02077"></a>02077     <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3 * x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> * x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>;
<a name="l02078"></a>02078     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02079"></a>02079 
<a name="l02080"></a>02080     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02081"></a>02081     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a>; ++row)
<a name="l02082"></a>02082       {
<a name="l02083"></a>02083       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a>; ++col)
<a name="l02084"></a>02084         {
<a name="l02085"></a>02085         tmp[i+0] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,0) );
<a name="l02086"></a>02086         tmp[i+1] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,1) );
<a name="l02087"></a>02087         tmp[i+2] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( x.<a class="code" href="a00605.html#ga88789d28113d5e6606c27f802c506c82" title="element accessor; no bounds check">at</a>(row,col,2) );
<a name="l02088"></a>02088         
<a name="l02089"></a>02089         i+=3;
<a name="l02090"></a>02090         }
<a name="l02091"></a>02091       }
<a name="l02092"></a>02092     
<a name="l02093"></a>02093     f &lt;&lt; <span class="stringliteral">&quot;P6&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02094"></a>02094     f &lt;&lt; x.<a class="code" href="a00031.html#ad80e30cde8ecfc263436b59d95b42342" title="number of columns in each slice (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02095"></a>02095     f &lt;&lt; x.<a class="code" href="a00031.html#a2b96522a62c1934882f61a5cf31f6823" title="number of rows in each slice (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02096"></a>02096     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02097"></a>02097 
<a name="l02098"></a>02098     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l02099"></a>02099     
<a name="l02100"></a>02100     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02101"></a>02101     
<a name="l02102"></a>02102     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l02103"></a>02103     
<a name="l02104"></a>02104     f.flush();
<a name="l02105"></a>02105     f.close();
<a name="l02106"></a>02106     
<a name="l02107"></a>02107     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l02108"></a>02108       {
<a name="l02109"></a>02109       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l02110"></a>02110       }
<a name="l02111"></a>02111     
<a name="l02112"></a>02112     }
<a name="l02113"></a>02113   
<a name="l02114"></a>02114   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga589a30dc9494f1b2780682cf78757f0e"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="ga589a30dc9494f1b2780682cf78757f0e" args="(field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l02121">2121</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00567_source.html#l00194">podarray&lt; T1 &gt;::memptr()</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00406_source.html#l00973">pnm_skip_comments()</a>, <a class="el" href="a00408_source.html#l00536">field&lt; oT &gt;::reset()</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, <a class="el" href="a00489_source.html#l01788">Mat&lt; eT &gt;::set_size()</a>, and <a class="el" href="a00408_source.html#l00156">field&lt; oT &gt;::set_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02122"></a>02122   {
<a name="l02123"></a>02123   arma_extra_debug_sigprint();
<a name="l02124"></a>02124   
<a name="l02125"></a>02125   <a class="code" href="a00016.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l02126"></a>02126   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l02127"></a>02127   
<a name="l02128"></a>02128   std::fstream f;
<a name="l02129"></a>02129   f.open(name.c_str(), std::fstream::in | std::fstream::binary);
<a name="l02130"></a>02130   
<a name="l02131"></a>02131   <span class="keywordtype">bool</span> load_okay = <span class="keyword">true</span>;
<a name="l02132"></a>02132   
<a name="l02133"></a>02133   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02134"></a>02134     {
<a name="l02135"></a>02135     load_okay = <span class="keyword">false</span>;
<a name="l02136"></a>02136     arma_extra_debug_print(<span class="stringliteral">&quot;unable to read &quot;</span>, name);
<a name="l02137"></a>02137     }
<a name="l02138"></a>02138   <span class="keywordflow">else</span>
<a name="l02139"></a>02139     {
<a name="l02140"></a>02140     std::string f_header;
<a name="l02141"></a>02141     f &gt;&gt; f_header;
<a name="l02142"></a>02142     
<a name="l02143"></a>02143     <span class="keywordflow">if</span>(f_header == <span class="stringliteral">&quot;P6&quot;</span>)
<a name="l02144"></a>02144       {
<a name="l02145"></a>02145       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_rows = 0;
<a name="l02146"></a>02146       <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> f_n_cols = 0;
<a name="l02147"></a>02147       <span class="keywordtype">int</span> f_maxval = 0;
<a name="l02148"></a>02148     
<a name="l02149"></a>02149       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02150"></a>02150     
<a name="l02151"></a>02151       f &gt;&gt; f_n_cols;
<a name="l02152"></a>02152       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02153"></a>02153     
<a name="l02154"></a>02154       f &gt;&gt; f_n_rows;
<a name="l02155"></a>02155       <a class="code" href="a00608.html#ga49b5a9c169b0cb638a029af61f922c97">diskio::pnm_skip_comments</a>(f);
<a name="l02156"></a>02156     
<a name="l02157"></a>02157       f &gt;&gt; f_maxval;
<a name="l02158"></a>02158       f.get();
<a name="l02159"></a>02159       
<a name="l02160"></a>02160       <span class="keywordflow">if</span>( (f_maxval &gt; 0) || (f_maxval &lt;= 65535) )
<a name="l02161"></a>02161         {
<a name="l02162"></a>02162         x.<a class="code" href="a00609.html#gafd7a090f4134eab2ab1c805fb867e85c" title="change the field to have the specified number of elements, assuming a column-major...">set_size</a>(3);
<a name="l02163"></a>02163         <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l02164"></a>02164         <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l02165"></a>02165         <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l02166"></a>02166         
<a name="l02167"></a>02167         R.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02168"></a>02168         G.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02169"></a>02169         B.<a class="code" href="a00673.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">set_size</a>(f_n_rows,f_n_cols);
<a name="l02170"></a>02170         
<a name="l02171"></a>02171         <span class="keywordflow">if</span>(f_maxval &lt;= 255)
<a name="l02172"></a>02172           {
<a name="l02173"></a>02173           <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02174"></a>02174           <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02175"></a>02175           
<a name="l02176"></a>02176           f.read( reinterpret_cast&lt;char*&gt;(tmp.memptr()), n_elem);
<a name="l02177"></a>02177           
<a name="l02178"></a>02178           <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02179"></a>02179           
<a name="l02180"></a>02180           <span class="comment">//cout &lt;&lt; &quot;f_n_cols = &quot; &lt;&lt; f_n_cols &lt;&lt; endl;</span>
<a name="l02181"></a>02181           <span class="comment">//cout &lt;&lt; &quot;f_n_rows = &quot; &lt;&lt; f_n_rows &lt;&lt; endl;</span>
<a name="l02182"></a>02182           
<a name="l02183"></a>02183           
<a name="l02184"></a>02184           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02185"></a>02185             {
<a name="l02186"></a>02186             <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02187"></a>02187               {
<a name="l02188"></a>02188               R.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l02189"></a>02189               G.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l02190"></a>02190               B.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l02191"></a>02191               i+=3;
<a name="l02192"></a>02192               }
<a name="l02193"></a>02193             
<a name="l02194"></a>02194             }
<a name="l02195"></a>02195           }
<a name="l02196"></a>02196         <span class="keywordflow">else</span>
<a name="l02197"></a>02197           {
<a name="l02198"></a>02198           <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3*f_n_cols*f_n_rows;
<a name="l02199"></a>02199           <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u16&gt;</a> tmp(n_elem);
<a name="l02200"></a>02200           
<a name="l02201"></a>02201           f.read( reinterpret_cast&lt;char *&gt;(tmp.memptr()), 2*n_elem);
<a name="l02202"></a>02202           
<a name="l02203"></a>02203           <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02204"></a>02204           
<a name="l02205"></a>02205           <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; f_n_rows; ++row)
<a name="l02206"></a>02206             {
<a name="l02207"></a>02207             <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; f_n_cols; ++col)
<a name="l02208"></a>02208               {
<a name="l02209"></a>02209               R.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+0]);
<a name="l02210"></a>02210               G.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+1]);
<a name="l02211"></a>02211               B.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) = eT(tmp[i+2]);
<a name="l02212"></a>02212               i+=3;
<a name="l02213"></a>02213               }
<a name="l02214"></a>02214             
<a name="l02215"></a>02215             }
<a name="l02216"></a>02216           
<a name="l02217"></a>02217           }
<a name="l02218"></a>02218         
<a name="l02219"></a>02219         }
<a name="l02220"></a>02220       
<a name="l02221"></a>02221       <span class="keywordflow">if</span>(f.good() == <span class="keyword">false</span>)
<a name="l02222"></a>02222         {
<a name="l02223"></a>02223         <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;trouble reading &quot;</span>, name);
<a name="l02224"></a>02224         load_okay = <span class="keyword">false</span>;
<a name="l02225"></a>02225         }
<a name="l02226"></a>02226       
<a name="l02227"></a>02227       }
<a name="l02228"></a>02228     <span class="keywordflow">else</span>
<a name="l02229"></a>02229       {
<a name="l02230"></a>02230       <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;unsupported header in &quot;</span>, name);
<a name="l02231"></a>02231       load_okay = <span class="keyword">false</span>;
<a name="l02232"></a>02232       }
<a name="l02233"></a>02233     
<a name="l02234"></a>02234     f.close();
<a name="l02235"></a>02235     }
<a name="l02236"></a>02236   
<a name="l02237"></a>02237   
<a name="l02238"></a>02238   <span class="keywordflow">if</span>(load_okay == <span class="keyword">false</span>)
<a name="l02239"></a>02239     {
<a name="l02240"></a>02240     x.<a class="code" href="a00609.html#gac9dc9ea2b0eb588746b147e2e25d48db">reset</a>();
<a name="l02241"></a>02241     }
<a name="l02242"></a>02242   
<a name="l02243"></a>02243   }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga23d4e3f45a86ec0440b4d99450f38b20"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ga23d4e3f45a86ec0440b4d99450f38b20" args="(const field&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00043.html">field</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00406_source.html#l02250">2250</a> of file <a class="el" href="a00406_source.html">diskio_meat.hpp</a>.</p>

<p>References <a class="el" href="a00403_source.html#l00026">arma_print()</a>, <a class="el" href="a00403_source.html#l00160">arma_warn()</a>, <a class="el" href="a00489_source.html#l01459">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00489_source.html#l00882">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00406_source.html#l00354">gen_tmp_name()</a>, <a class="el" href="a00568_source.html#l00032">podarray&lt; T1 &gt;::mem</a>, <a class="el" href="a00490_source.html#l00034">Mat&lt; eT &gt;::n_cols</a>, <a class="el" href="a00490_source.html#l00035">Mat&lt; eT &gt;::n_elem</a>, <a class="el" href="a00409_source.html#l00033">field&lt; oT &gt;::n_elem</a>, <a class="el" href="a00490_source.html#l00033">Mat&lt; eT &gt;::n_rows</a>, <a class="el" href="a00489_source.html#l00852">Mat&lt; eT &gt;::row()</a>, and <a class="el" href="a00406_source.html#l00418">safe_rename()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02251"></a>02251   {
<a name="l02252"></a>02252   arma_extra_debug_sigprint();
<a name="l02253"></a>02253   
<a name="l02254"></a>02254   <a class="code" href="a00016.html">arma_type_check&lt;is_Mat&lt;T1&gt;::value</a> == <span class="keyword">false</span>&gt;::apply();
<a name="l02255"></a>02255   <span class="keyword">typedef</span> <span class="keyword">typename</span> T1::elem_type eT;
<a name="l02256"></a>02256   
<a name="l02257"></a>02257   arma_debug_check( (x.<a class="code" href="a00043.html#a546aa9caedb2f0a0657e4dd765503db7" title="number of elements in the field (read-only)">n_elem</a> != 3), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given field must have exactly 3 matrices of equal size&quot;</span> );
<a name="l02258"></a>02258   
<a name="l02259"></a>02259   <span class="keywordtype">bool</span> same_size = <span class="keyword">true</span>;
<a name="l02260"></a>02260   <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i=1; i&lt;3; ++i)
<a name="l02261"></a>02261     {
<a name="l02262"></a>02262     <span class="keywordflow">if</span>( (x(0).n_rows != x(i).n_rows) || (x(0).n_cols != x(i).n_cols) )
<a name="l02263"></a>02263       {
<a name="l02264"></a>02264       same_size = <span class="keyword">false</span>;
<a name="l02265"></a>02265       <span class="keywordflow">break</span>;
<a name="l02266"></a>02266       }
<a name="l02267"></a>02267     }
<a name="l02268"></a>02268   
<a name="l02269"></a>02269   arma_debug_check( (same_size != <span class="keyword">true</span>), <span class="stringliteral">&quot;diskio::save_ppm_binary(): given field must have exactly 3 matrices of equal size&quot;</span> );
<a name="l02270"></a>02270   
<a name="l02271"></a>02271   <span class="keyword">const</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; R = x(0);
<a name="l02272"></a>02272   <span class="keyword">const</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; G = x(1);
<a name="l02273"></a>02273   <span class="keyword">const</span> <a class="code" href="a00164.html" title="Dense matrix class.">Mat&lt;eT&gt;</a>&amp; B = x(2);
<a name="l02274"></a>02274   
<a name="l02275"></a>02275   <span class="keyword">const</span> std::string tmp_name = <a class="code" href="a00608.html#ga81ac9508b1ee96fd24338a9701aeda71" title="Append a quasi-random string to the given filename. The rand() function is deliberately...">diskio::gen_tmp_name</a>(final_name);
<a name="l02276"></a>02276   std::ofstream f( tmp_name.c_str(), std::fstream::binary );
<a name="l02277"></a>02277   
<a name="l02278"></a>02278   <span class="keywordflow">if</span>(f.is_open() == <span class="keyword">false</span>)
<a name="l02279"></a>02279     {
<a name="l02280"></a>02280     <a class="code" href="a00606.html#gadcf220676d0c7293eb01474a2d67e080">arma_print</a>(<span class="stringliteral">&quot;couldn&apos;t write &quot;</span>, tmp_name);
<a name="l02281"></a>02281     }
<a name="l02282"></a>02282   <span class="keywordflow">else</span>
<a name="l02283"></a>02283     {
<a name="l02284"></a>02284     f &lt;&lt; <span class="stringliteral">&quot;P6&quot;</span> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02285"></a>02285     f &lt;&lt; R.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02286"></a>02286     f &lt;&lt; R.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02287"></a>02287     f &lt;&lt; 255 &lt;&lt; <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02288"></a>02288 
<a name="l02289"></a>02289     <span class="keyword">const</span> <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> n_elem = 3 * R.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a> * R.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>;
<a name="l02290"></a>02290     <a class="code" href="a00231.html" title="A lightweight array for POD types. If the amount of memory requested is small, the...">podarray&lt;u8&gt;</a> tmp(n_elem);
<a name="l02291"></a>02291 
<a name="l02292"></a>02292     <a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i = 0;
<a name="l02293"></a>02293     <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row=0; row &lt; R.<a class="code" href="a00164.html#aaa8c7e5e59361913b15ae55f714ca6c6" title="number of rows in the matrix (read-only)">n_rows</a>; ++row)
<a name="l02294"></a>02294       {
<a name="l02295"></a>02295       <span class="keywordflow">for</span>(<a class="code" href="a00729.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col=0; col &lt; R.<a class="code" href="a00164.html#a163bed70780a1d181594d126295d5a09" title="number of columns in the matrix (read-only)">n_cols</a>; ++col)
<a name="l02296"></a>02296         {
<a name="l02297"></a>02297         tmp[i+0] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( R.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l02298"></a>02298         tmp[i+1] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( G.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l02299"></a>02299         tmp[i+2] = <a class="code" href="a00729.html#gaed742c436da53c1080638ce6ef7d13de" title="unsigned 8 bit type">u8</a>( B.<a class="code" href="a00673.html#ga6e3952e7bf8575ff6423340f4ad1807a" title="element accessor; no bounds check">at</a>(row,col) );
<a name="l02300"></a>02300         
<a name="l02301"></a>02301         i+=3;
<a name="l02302"></a>02302         }
<a name="l02303"></a>02303       }
<a name="l02304"></a>02304     
<a name="l02305"></a>02305     f.write(reinterpret_cast&lt;const char*&gt;(tmp.mem), n_elem);
<a name="l02306"></a>02306     
<a name="l02307"></a>02307     <span class="keyword">const</span> <span class="keywordtype">bool</span> writing_problem = (f.good() == <span class="keyword">false</span>);
<a name="l02308"></a>02308     
<a name="l02309"></a>02309     <a class="code" href="a00606.html#gad87c496c718f00ff529987ac00095eb4" title="if state is true, print a message on cout">arma_warn</a>(writing_problem, <span class="stringliteral">&quot;trouble writing &quot;</span>, tmp_name );
<a name="l02310"></a>02310     
<a name="l02311"></a>02311     f.flush();
<a name="l02312"></a>02312     f.close();
<a name="l02313"></a>02313     
<a name="l02314"></a>02314     <span class="keywordflow">if</span>(writing_problem == <span class="keyword">false</span>)
<a name="l02315"></a>02315       {
<a name="l02316"></a>02316       <a class="code" href="a00608.html#ga21a278d6cee27f2800429aadceaff8b1" title="Safely rename a file. Before renaming, test if we can write to the final file. This...">diskio::safe_rename</a>(tmp_name, final_name);
<a name="l02317"></a>02317       }
<a name="l02318"></a>02318     
<a name="l02319"></a>02319     }
<a name="l02320"></a>02320   
<a name="l02321"></a>02321   }
</pre></div></p>

</div>
</div>
</div>
</BODY>
</HTML>
