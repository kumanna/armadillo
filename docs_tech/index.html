<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Armadillo Technical Documentation</h1>
<p>
 

<p>
<center>
(this is the technical documentation -- the <a href="../docs_user/index.html">user documentation is over here</a>)
</center>
</p>
<br>
<p>
<a name="#impl_notes"><b>Implementation Notes</b></a>
</p>
<br>
<p>
Matrix and vector types:

<ul>

<li>
'basic_mat' is the dense matrix class, with row-major ordering of data.
</li>
<br>

<li>
'basic_rowvec' and 'basic_colvec' are the dense row vector and column vector classes, respectively.
The vector classes are derived from the 'basic_mat' class.
An instance of a 'basic_rowvec' is effectively treated as a 'basic_mat' comprised of one row.
Similarly, 'basic_colvec' is treated as 'basic_mat' comprised of one column.
Functions which expect 'basic_mat' as an input can also use 'basic_rowvec' and 'basic_colvec', where it mathematically makes sense -- 
an error at run-time is given where incorrect usage is detected.
</li>
<br>

<li>
'basic_mat&lt;double&gt;' has been typedefed as 'mat'.  Similarly for colvec and rowvec.
See <i>arma_bits/typedef.hpp</i> for more typedefs.
</li>

<br>

<li>
A scalar is treated as a 1x1 matrix.  Hence <b>mat&nbsp;X(5,10);&nbsp;X&nbsp;=&nbsp;20;</b> will result in <b>X</b> having a size of 1x1, rather than 5x10.
This is the same as what happens in Matlab/Octave.
</li>
<br>
</ul>
</p>

<p>
In order to have ease of use and a straightforward user interface,
some trade-offs between verbosity, speed and memory efficiency are present:
<ul>
<li>
To dramatically speed up handling of small vectors and matrices,
while at the same time allowing dynamic re-sizing (e.g. to load matrices of unknown size from disk),
each matrix has a certain amount of memory pre-allocated directly in the definition of the 'mat' class.
The 'new' operator is called only if the required size of the matrix does not fit into the pre-allocated memory.
The pre-allocation technique was used instead of requiring the user to hard-code matrix sizes.
</li>
<br>
<li>
Accessors for simple data, such as the number of rows and columns, are not used, e.g. <b>X.rows()</b>.
Instead, read-only publically accessible members are provided, e.g. <b>X.n_rows</b>.
This was done with the aim of improving readbility of user code with many loops.
(As a sidenote, <b>X.rows(...)</b> is used to access sub-matrices of <b>X</b>).
</li>
<br>
<li>
Unsigned integers are used (of type 'u32') for loops and the storage of sizes.
This avoids the need to account for negative values during bounds checks.
</li>
<br>
</ul>
</p>

<p>
Debugging:
<ul>
<li>
<b>Bounds and other checks are enabled by default</b>.
They can be turned off by defining <b>ARMA_NO_DEBUG</b> prior to including <i>armadillo</i>
(preferably in the Makefile file or the command line, e.g. g++ -DARMA_NO_DEBUG ...).
The reasoning here is that bounds checks should be turned off <b>only</b> when the user is satisfied that their code is working correctly
(i.e. thoroughly debugged).
</li>
<br>

<li>
<b>Low level library debugging</b> can be aided by defining <b>ARMA_EXTRA_DEBUG</b> prior to including <i>armadillo</i>.
Note that defining ARMA_NO_DEBUG will automatically undefine ARMA_EXTRA_DEBUG (see <i>armadillo_bits/debug.hpp</i>).
</li>
<br>
</ul>
</p>

<p>
External libraries:
<ul>
<li>
To avoid reinventing a few wheels, Armadillo can leverage ATLAS, LAPACK, BLAS and Boost libraries.
While the presence of these libraries is not mandatory, the functionality of Armadillo will be reduced without them.
Operations such as matrix multiplication will still work,
however more involved operations such as matrix inversion of eigenvalue decomposition require ATLAS or LAPACK.
</li>
<br>
</ul>
</p>


<p>
Delayed evaluation via expression templates:

<ul>
<li>
Many operations (invoked through unary or binary operators) are not immediately executed, allowing more operations to be queued.
The queued operations are executed (possibly by combining several operations) only when the 'mat' (or 'diagmat') 
constructor or assignment operator is invoked.
This is done at compile time.
<p>
As an example, when the compiler evaluates the line
<b>mat&nbsp;Z&nbsp;=&nbsp;A&nbsp;+&nbsp;B&nbsp;+&nbsp;C</b>,
the line is converted, at compile time, to be
<b>mat&nbsp;Z&nbsp;=&nbsp;X</b>,
where <b>X</b> is of type <b>glue_data&lt;&nbsp;glue_data&lt;mat,&nbsp;mat,&nbsp;glue_plus&gt;,&nbsp;mat,&nbsp;glue_plus&gt;</b>.
The constructor for the 'mat' class then uses the last template argument to call
<b>glue_plus::apply(*this,&nbsp;X)</b>,
which sets the size of <b>Z</b> and evaluates <b>A&nbsp;+&nbsp;B&nbsp;+&nbsp;C</b> in one loop (i.e. no temporary matrices are created).
</p>
<p>
The recursive template type <b>glue_data&lt;&nbsp;glue_data&lt;mat,&nbsp;mat,&nbsp;glue_plus&gt;,&nbsp;mat,&nbsp;glue_plus&gt;</b>
is constructed via repeated invocations of <b>operator+()</b>.
First, <b>operator+(mat,mat)</b> is called, which returns an object of type <b>glue_data&lt;mat,&nbsp;mat,&nbsp;glue_plus&gt;</b>.
This object is then fed to <b>operator+(glue_data&lt;T1,T2,glue_type&gt;,&nbsp;mat)</b> which returns an object of type
<b>glue_data&lt;&nbsp;glue_data&lt;mat,&nbsp;mat,&nbsp;glue_plus&gt;,&nbsp;mat,&nbsp;glue_plus&gt;</b>.
</p>
<p>Note that the compiler can optimise away the temporary object <b>X</b> as well as the intermediate object resulting
from calling <b>operator+()</b> the first time.
Furthermore, the single loop which evaluates <b>A&nbsp;+&nbsp;B&nbsp;+&nbsp;C</b> can be inlined.
</p>
</li>
<br>
<li>
Other types of delayed operation are queued unary operations.
One example is <b>max&nbsp;Z&nbsp;=&nbsp;inv(diagmat(A))</b>, which has a temporary object of type
<b>op_data&lt;&nbsp;op_data&lt;mat,&nbsp;op_diagmat&gt;,&nbsp;op_inv&gt;</b>.
</li>
<br>
<li>
Operations types can be mixed. A contrived example is <b>mat&nbsp;Z&nbsp;=&nbsp;trans(&nbsp;diagmat(A&nbsp;*&nbsp;B)&nbsp;+&nbsp;inv(C)&nbsp;)</b>,
which has a temporary object with the rather convoluted type of 
<font size=-1>
<b>op_data&lt;&nbsp;glue_data&lt;&nbsp;op_data&lt;&nbsp;glue_data&lt;mat,&nbsp;mat,&nbsp;glue_times&gt;,&nbsp;op_diagmat&gt;,&nbsp;op_data&lt;mat,&nbsp;op_inv&gt;,&nbsp;glue_plus&gt;,&nbsp;op_trans&gt;</b>.
</font>
</li>
<br>
<li>
The degree to which operations are optimised is dependent on code being present to handle particular combinations.
</li>
<br>
</ul>
</p>

<p>
Coding style
<ul>
<li>
While many preferences exist, we've settled on the following style in order to enhance readability of the source code.
For blocks of code which are not placed on one line,
starting and ending curly braces are indented, with the starting brace underneath the function name or keyword.
For example:
<font size=-1>
<pre>
inline void mat::save(const std::string name, const file_type type) const
  {
  arma_lowdebug_sigprint();
  
  switch(type)
    {
    case raw_ascii:
      diskio::save_raw_ascii(*this, name);
      break;
    
    ...

    default:
      check(true, "mat::save(): unknown type");
    }
  }
</pre>
</font>
</li>
</ul>

</p>




 </div>
</BODY>
</HTML>
