<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="a00001.html">access</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00002.html">arma_apply_proxy&lt; false, arma_class &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00003.html">arma_apply_proxy&lt; true, arma_class &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00004.html">arma_config</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00005.html">arma_counter&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00006.html">arma_cx_median_packet&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00007.html">junk::arma_elem_size_test</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00008.html">junk::arma_first_extra_debug_message</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00009.html">arma_ostream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00010.html">arma_ostream_state</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00011.html">arma_qsort_helper&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00012.html">arma_qsort_helper&lt; std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00013.html">arma_sort_index_packet_ascend&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00014.html">arma_sort_index_packet_descend&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00015.html">arma_static_assert&lt; true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00016.html">arma_type_check&lt; val &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00017.html">arma_version</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00018.html">auxlib</a></td><td class="indexvalue">Wrapper for accessing external functions defined in ATLAS, LAPACK or BLAS libraries </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00019.html">Base&lt; elem_type, derived &gt;</a></td><td class="indexvalue">Class for static polymorphism, modelled after the "Curiously Recurring Template Pattern" (CRTP). Used for type-safe downcasting in functions that restrict their input(s) to be classes that are derived from <a class="el" href="a00019.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> (e.g. <a class="el" href="a00164.html" title="Dense matrix class.">Mat</a>, <a class="el" href="a00171.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, <a class="el" href="a00041.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>, <a class="el" href="a00319.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a>). A <a class="el" href="a00019.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> object can be converted to a <a class="el" href="a00164.html" title="Dense matrix class.">Mat</a> object by the <a class="el" href="a00325.html">unwrap</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00020.html">BaseCube&lt; elem_type, derived &gt;</a></td><td class="indexvalue">Analog of the <a class="el" href="a00019.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">Base</a> class, intended for cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00021.html">BaseVec&lt; elem_type, derived &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00022.html">arma_boost::basic_format&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00023.html">Col&lt; eT &gt;</a></td><td class="indexvalue">Class for column vectors (matrices with only column) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00024.html">conv_to&lt; out_eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00025.html">conv_to&lt; Col&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00026.html">conv_to&lt; Cube&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00027.html">conv_to&lt; itpp::Mat&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00028.html">conv_to&lt; itpp::Vec&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00029.html">conv_to&lt; Mat&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00030.html">conv_to&lt; Row&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00031.html">Cube&lt; eT &gt;</a></td><td class="indexvalue">Dense cube class </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00032.html">Cube_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00033.html">cube_ptrs&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00033.html" title="Template metaprogram cube_ptrs fills a given array with addresses of cubes from a...">cube_ptrs</a> fills a given array with addresses of cubes from a recursive instance of GlueCube&lt;Tx,Ty, glue_cube_type&gt;. While parsing the recursive instance, if encountered objects are of type <a class="el" href="a00229.html" title="Analog of the Op class, intended for cubes.">OpCube</a>&lt;..&gt;, they are converted to type 'Cube' first </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00034.html">cube_ptrs&lt; glue_type, GlueCube&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00035.html">cube_ptrs_outcheck&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00035.html" title="template metaprogram cube_ptrs_outcheck builds on &#39;cube_ptrs&#39; by also checking...">cube_ptrs_outcheck</a> builds on 'cube_ptrs' by also checking whether any of the input cubes are aliases of the output cube </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00036.html">cube_ptrs_outcheck&lt; glue_type, GlueCube&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00037.html">depth_lhs&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00037.html" title="Template metaprogram depth_lhs calculates the number of Glue&lt;Tx,Ty, glue_type&gt;...">depth_lhs</a> calculates the number of Glue&lt;Tx,Ty, glue_type&gt; instances on the left hand side argument of Glue&lt;Tx,Ty, glue_type&gt; i.e. it recursively expands each Tx, until the type of Tx is not "Glue&lt;..,.., glue_type&gt;" (i.e the "glue_type" changes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00038.html">depth_lhs&lt; glue_type, Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00039.html">depth_lhs_cube&lt; glue_cube_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00039.html" title="Template metaprogram depth_lhs_cube calculates the number of GlueCube&lt;Tx,Ty, glue_type&gt;...">depth_lhs_cube</a> calculates the number of GlueCube&lt;Tx,Ty, glue_type&gt; instances on the left hand side argument of GlueCube&lt;Tx,Ty, glue_cube_type&gt; i.e. it recursively expands each Tx, until the type of Tx is not "GlueCube&lt;..,.., glue_cube_type&gt;" (i.e the "glue_cube_type" changes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00040.html">depth_lhs_cube&lt; glue_cube_type, GlueCube&lt; T1, T2, glue_cube_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00041.html">diagview&lt; eT &gt;</a></td><td class="indexvalue">Class for storing data required to extract and set the diagonals of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00042.html">diskio</a></td><td class="indexvalue">Class for saving and loading matrices and fields </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00043.html">field&lt; oT &gt;</a></td><td class="indexvalue">A lightweight 2D container for abitrary objects (the objects must have a copy constructor) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00044.html">field_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00045.html">arma_boost::format</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00046.html">arma_boost::format_metaprog&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00047.html">arma_boost::format_metaprog&lt; basic_format&lt; T1, T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00048.html">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Wrapper for ATLAS/BLAS dgemm function, using template arguments to control the arguments passed to dgemm. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00049.html">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemm(), using caching for speedup. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00050.html">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemm(), non-cached version. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00051.html">gemm_mixed&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00052.html">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types. Uses caching for speedup. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00053.html">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types. Simple version (no caching). Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00054.html">gemv&lt; do_trans_A, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Wrapper for ATLAS/BLAS <a class="el" href="a00054.html" title="Wrapper for ATLAS/BLAS gemv function, using template arguments to control the arguments...">gemv</a> function, using template arguments to control the arguments passed to <a class="el" href="a00054.html" title="Wrapper for ATLAS/BLAS gemv function, using template arguments to control the arguments...">gemv</a>. 'y' is assumed to have been set to the correct size (i.e. taking into account the transpose) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00055.html">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemv(). 'y' is assumed to have been set to the correct size (i.e. taking into account the transpose) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00056.html">get_pod_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00057.html">get_pod_type&lt; std::complex&lt; T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00058.html">Glue&lt; T1, T2, glue_type &gt;</a></td><td class="indexvalue">Class for storing data required for delayed binary operations, such as the operands (e.g. two matrices) and the binary operator (e.g. addition). The operands are stored as references (which can be optimised away), while the operator is "stored" through the template definition (glue_type). The operands can be 'Mat', 'Row', 'Col', 'Op', and 'Glue'. Note that as 'Glue' can be one of the operands, more than two matrices can be stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00059.html">glue_cor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00060.html">glue_cov</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00061.html">glue_cube_div</a></td><td class="indexvalue">Class which implements the immediate element-wise division of two or more cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00062.html">glue_cube_minus</a></td><td class="indexvalue">Class which implements the immediate subtraction of cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00063.html">glue_cube_plus</a></td><td class="indexvalue">Class which implements the immediate addition of cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00064.html">glue_cube_schur</a></td><td class="indexvalue">Class which implements the immediate Schur product (element-wise multiplication) of two or more cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00065.html">glue_div</a></td><td class="indexvalue">Class which implements the immediate element-wise division of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00066.html">glue_kron</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00067.html">glue_minus</a></td><td class="indexvalue">Class for the minus operation, where the result is always a dense matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00068.html">glue_minus_diag</a></td><td class="indexvalue">Class for the minus operation, where one of the operands is a diagonal matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00069.html">glue_plus</a></td><td class="indexvalue">Class which implements the immediate addition of matrices, with the result stored in 'Mat' (dense matrix) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00070.html">glue_plus_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00071.html">glue_schur</a></td><td class="indexvalue">Class which implements the immediate Schur product (element-wise multiplication) of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00072.html">glue_schur_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00073.html">glue_times</a></td><td class="indexvalue">Class which implements the immediate multiplication of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00074.html">glue_times_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00075.html">glue_times_vec</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00076.html">GlueCube&lt; T1, T2, glue_type &gt;</a></td><td class="indexvalue">Analog of the <a class="el" href="a00058.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a> class, intended for <a class="el" href="a00031.html" title="Dense cube class.">Cube</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00077.html">is_arma_cube_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00078.html">is_arma_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00079.html">is_Col&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00080.html">is_Col&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00081.html">is_complex&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00082.html">is_complex&lt; std::complex&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00083.html">is_complex&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00084.html">is_complex_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00085.html">is_complex_double&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00086.html">is_complex_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00087.html">is_Cube&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00088.html">is_Cube&lt; Cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00089.html">is_diagview&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00090.html">is_diagview&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00091.html">is_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00092.html">is_double&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00093.html">is_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00094.html">is_float&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00095.html">is_Glue&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00096.html">is_Glue&lt; Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00097.html">is_glue_times&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00098.html">is_glue_times&lt; Glue&lt; T1, T2, glue_times &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00099.html">is_GlueCube&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00100.html">is_GlueCube&lt; GlueCube&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00101.html">is_Mat&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00102.html">is_Mat&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00103.html">is_Mat&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00104.html">is_Mat&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00105.html">is_Mat_only&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00106.html">is_Mat_only&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00107.html">is_non_integral&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00108.html">is_Op&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00109.html">is_Op&lt; Op&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00110.html">is_OpCube&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00111.html">is_OpCube&lt; OpCube&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00112.html">is_Row&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00113.html">is_Row&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00114.html">is_s16&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00115.html">is_s16&lt; s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00116.html">is_s32&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00117.html">is_s32&lt; s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00118.html">is_s8&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00119.html">is_s8&lt; s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00120.html">is_same_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00121.html">is_same_type&lt; T1, T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00122.html">is_signed&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00123.html">is_subview&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00124.html">is_subview&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00125.html">is_subview_cube&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00126.html">is_subview_cube&lt; subview_cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00127.html">is_supported_blas_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00128.html">is_supported_complex&lt; T1 &gt;</a></td><td class="indexvalue">Check for a weird implementation of the std::complex class </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00129.html">is_supported_complex&lt; std::complex&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00130.html">is_supported_complex_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00131.html">is_supported_complex_double&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00132.html">is_supported_complex_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00133.html">is_supported_complex_float&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00134.html">is_supported_elem_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00135.html">diskio::is_supported_type&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00136.html">is_u16&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00137.html">is_u16&lt; u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00138.html">is_u32&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00139.html">is_u32&lt; u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00140.html">is_u8&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00141.html">is_u8&lt; u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00142.html">isnt_fltpt&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00143.html">isnt_fltpt&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00144.html">isnt_fltpt&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00145.html">isnt_fltpt&lt; long double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00146.html">isnt_fltpt&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00147.html">isnt_fltpt&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00148.html">isnt_fltpt_false</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00149.html">isnt_same_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00150.html">isnt_same_type&lt; T1, T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00151.html">isnt_supported_elem_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00152.html">isnt_supported_elem_type&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00153.html">isnt_supported_elem_type&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00154.html">isnt_supported_elem_type&lt; s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00155.html">isnt_supported_elem_type&lt; s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00156.html">isnt_supported_elem_type&lt; s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00157.html">isnt_supported_elem_type&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00158.html">isnt_supported_elem_type&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00159.html">isnt_supported_elem_type&lt; u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00160.html">isnt_supported_elem_type&lt; u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00161.html">isnt_supported_elem_type&lt; u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00162.html">isnt_supported_elem_type_false</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00163.html">itpp::Mat&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00164.html">Mat&lt; eT &gt;</a></td><td class="indexvalue">Dense matrix class </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00165.html">Mat_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00166.html">mat_ptrs&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00166.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a> fills a given array with addresses of matrices from a recursive instance of Glue&lt;Tx,Ty, glue_type&gt;. While parsing the recursive instance, if encountered objects are of type <a class="el" href="a00171.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>&lt;..&gt;, they are converted to type 'Mat' first </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00167.html">mat_ptrs&lt; glue_type, Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00168.html">mat_ptrs_outcheck&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="a00168.html" title="template metaprogram mat_ptrs_outcheck builds on &#39;mat_ptrs&#39; by also checking...">mat_ptrs_outcheck</a> builds on 'mat_ptrs' by also checking whether any of the input matrices are aliases of the output matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00169.html">mat_ptrs_outcheck&lt; glue_type, Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00170.html">Math&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00171.html">Op&lt; T1, op_type &gt;</a></td><td class="indexvalue">Class for storing data required for delayed unary operations, such as the operand (e.g. the matrix to which the operation is to be applied) and the unary operator (e.g. inverse). The operand is stored as a reference (which can be optimised away), while the operator is "stored" through the template definition (op_type). The operands can be 'Mat', 'Row', 'Col', 'Op', and 'Glue'. Note that as 'Glue' can be one of the operands, more than one matrix can be stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00172.html">op_acos</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00173.html">op_acosh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00174.html">op_asin</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00175.html">op_asinh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00176.html">op_atan</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00177.html">op_atanh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00178.html">op_conj</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00179.html">op_cor</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00180.html">op_cos</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00181.html">op_cosh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00182.html">op_cov</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00183.html">op_diagmat</a></td><td class="indexvalue">Convert a mat/rowvec/colvec to a diagonal matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00184.html">op_diagmat_vec</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00185.html">op_dot</a></td><td class="indexvalue">Dot product operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00186.html">op_eps</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00187.html">op_exp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00188.html">op_htrans</a></td><td class="indexvalue">'hermitian transpose' operation (only valid for complex number matrices) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00189.html">op_inv</a></td><td class="indexvalue">'invert matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00190.html">op_log</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00191.html">op_log10</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00192.html">op_max</a></td><td class="indexvalue">Class for finding maximum values in a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00193.html">op_mean</a></td><td class="indexvalue">Class for finding mean values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00194.html">op_median</a></td><td class="indexvalue">Class for finding median values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00195.html">op_min</a></td><td class="indexvalue">Class for finding minimum values in a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00196.html">op_neg</a></td><td class="indexvalue">Negate operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00197.html">op_norm_dot</a></td><td class="indexvalue">Normalised dot product operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00198.html">op_ones_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00199.html">op_ones_full</a></td><td class="indexvalue">Class for creation of a dense matrix/vector/cube with all elements set to one </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00200.html">op_pinv</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00201.html">op_pow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00202.html">op_pow_s32</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00203.html">op_prod</a></td><td class="indexvalue">Class for finding products of values in a matrix (e.g. along rows or columns) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00204.html">op_rand</a></td><td class="indexvalue">'generate matrix with random values' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00205.html">op_randn</a></td><td class="indexvalue">'generate matrix with random values' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00206.html">op_repmat</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00207.html">op_reshape</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00208.html">op_scalar_div_post</a></td><td class="indexvalue">'divide matrix/cube by a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00209.html">op_scalar_div_pre</a></td><td class="indexvalue">'divide scalar by a matrix/cube' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00210.html">op_scalar_minus_post</a></td><td class="indexvalue">'subtract scalar from a matrix/cube' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00211.html">op_scalar_minus_pre</a></td><td class="indexvalue">'subtract matrix/cube from a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00212.html">op_scalar_plus</a></td><td class="indexvalue">'add scalar to a matrix/cube' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00213.html">op_scalar_times</a></td><td class="indexvalue">'multiply matrix/cube by a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00214.html">op_shuffle</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00215.html">op_sin</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00216.html">op_sinh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00217.html">op_sort</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00218.html">op_sqrt</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00219.html">op_square</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00220.html">op_stddev</a></td><td class="indexvalue">Class for finding the standard deviation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00221.html">op_sum</a></td><td class="indexvalue">Class for finding sums of values in a matrix (e.g. along rows or columns) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00222.html">op_tan</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00223.html">op_tanh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00224.html">op_trans</a></td><td class="indexvalue">'matrix transpose' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00225.html">op_trunc_exp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00226.html">op_trunc_log</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00227.html">op_var</a></td><td class="indexvalue">Class for finding variance values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00228.html">op_zeros</a></td><td class="indexvalue">Generate matrix/vector with all elements set to zero </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00229.html">OpCube&lt; T1, op_type &gt;</a></td><td class="indexvalue">Analog of the <a class="el" href="a00171.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a> class, intended for cubes </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00230.html">Phy&lt; eT &gt;</a></td><td class="indexvalue">Physical constants taken from NIST and WolframAlpha on 2009-06-23 <a href="http://physics.nist.gov/cuu/Constants">http://physics.nist.gov/cuu/Constants</a> <a href="http://www.wolframalpha.com">http://www.wolframalpha.com</a> See also <a href="http://en.wikipedia.org/wiki/Physical_constant">http://en.wikipedia.org/wiki/Physical_constant</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00231.html">podarray&lt; T1 &gt;</a></td><td class="indexvalue">A lightweight array for POD types. If the amount of memory requested is small, the stack is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00232.html">promote_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00233.html">promote_type&lt; double, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00234.html">promote_type&lt; double, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00235.html">promote_type&lt; double, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00236.html">promote_type&lt; double, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00237.html">promote_type&lt; double, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00238.html">promote_type&lt; double, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00239.html">promote_type&lt; double, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00240.html">promote_type&lt; double, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00241.html">promote_type&lt; float, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00242.html">promote_type&lt; float, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00243.html">promote_type&lt; float, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00244.html">promote_type&lt; float, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00245.html">promote_type&lt; float, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00246.html">promote_type&lt; float, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00247.html">promote_type&lt; float, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00248.html">promote_type&lt; float, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00249.html">promote_type&lt; s16, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00250.html">promote_type&lt; s16, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00251.html">promote_type&lt; s16, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00252.html">promote_type&lt; s16, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00253.html">promote_type&lt; s16, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00254.html">promote_type&lt; s16, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00255.html">promote_type&lt; s16, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00256.html">promote_type&lt; s16, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00257.html">promote_type&lt; s32, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00258.html">promote_type&lt; s32, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00259.html">promote_type&lt; s32, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00260.html">promote_type&lt; s32, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00261.html">promote_type&lt; s32, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00262.html">promote_type&lt; s32, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00263.html">promote_type&lt; s32, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00264.html">promote_type&lt; s32, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00265.html">promote_type&lt; s8, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00266.html">promote_type&lt; s8, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00267.html">promote_type&lt; s8, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00268.html">promote_type&lt; s8, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00269.html">promote_type&lt; s8, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00270.html">promote_type&lt; s8, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00271.html">promote_type&lt; s8, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00272.html">promote_type&lt; s8, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00273.html">promote_type&lt; std::complex&lt; double &gt;, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00274.html">promote_type&lt; std::complex&lt; double &gt;, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00275.html">promote_type&lt; std::complex&lt; float &gt;, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00276.html">promote_type&lt; std::complex&lt; float &gt;, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00277.html">promote_type&lt; std::complex&lt; T &gt;, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00278.html">promote_type&lt; std::complex&lt; T &gt;, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00279.html">promote_type&lt; std::complex&lt; T &gt;, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00280.html">promote_type&lt; std::complex&lt; T &gt;, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00281.html">promote_type&lt; std::complex&lt; T &gt;, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00282.html">promote_type&lt; std::complex&lt; T &gt;, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00283.html">promote_type&lt; std::complex&lt; T &gt;, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00284.html">promote_type&lt; T, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00285.html">promote_type&lt; T, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00286.html">promote_type&lt; u16, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00287.html">promote_type&lt; u16, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00288.html">promote_type&lt; u16, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00289.html">promote_type&lt; u16, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00290.html">promote_type&lt; u16, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00291.html">promote_type&lt; u16, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00292.html">promote_type&lt; u16, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00293.html">promote_type&lt; u16, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00294.html">promote_type&lt; u32, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00295.html">promote_type&lt; u32, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00296.html">promote_type&lt; u32, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00297.html">promote_type&lt; u32, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00298.html">promote_type&lt; u32, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00299.html">promote_type&lt; u32, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00300.html">promote_type&lt; u32, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00301.html">promote_type&lt; u32, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00302.html">promote_type&lt; u8, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00303.html">promote_type&lt; u8, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00304.html">promote_type&lt; u8, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00305.html">promote_type&lt; u8, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00306.html">promote_type&lt; u8, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00307.html">promote_type&lt; u8, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00308.html">promote_type&lt; u8, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00309.html">promote_type&lt; u8, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00310.html">promote_type_ok</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00311.html">Row&lt; eT &gt;</a></td><td class="indexvalue">Class for row vectors (matrices with only one row) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00312.html">running_stat&lt; eT &gt;</a></td><td class="indexvalue">Class for keeping statistics of a continuously sampled process / signal. Useful if the storage of individual samples is not necessary or desired. Also useful if the number of samples is not known beforehand or exceeds available memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00313.html">running_stat_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00314.html">running_stat_vec&lt; eT &gt;</a></td><td class="indexvalue">Class for keeping statistics of a continuously sampled process / signal. Useful if the storage of individual samples is not necessary or desired. Also useful if the number of samples is not known beforehand or exceeds available memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00315.html">running_stat_vec_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00316.html">sort_index_result_type_deducer&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00317.html">sort_index_result_type_deducer&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00318.html">sort_index_result_type_deducer&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00319.html">subview&lt; eT &gt;</a></td><td class="indexvalue">Class for storing data required to construct or apply operations to a submatrix (i.e. where the submatrix starts and ends as well as a reference/pointer to the original matrix), </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00320.html">subview_col&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00321.html">subview_cube&lt; eT &gt;</a></td><td class="indexvalue">Class for storing data required to construct or apply operations to a subcube (i.e. where the subcube starts and ends as well as a reference/pointer to the original cube), </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00322.html">subview_field&lt; oT &gt;</a></td><td class="indexvalue">Class for storing data required to construct or apply operations to a subfield (i.e. where the subfield starts and ends as well as a reference/pointer to the original <a class="el" href="a00043.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a>), </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00323.html">subview_row&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00324.html">syslib</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00325.html">unwrap&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00326.html">unwrap&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00327.html">unwrap&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00328.html">unwrap&lt; Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00329.html">unwrap&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00330.html">unwrap&lt; Op&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00331.html">unwrap&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00332.html">unwrap&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00333.html">unwrap_check&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00334.html">unwrap_check&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00335.html">unwrap_check&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00336.html">unwrap_check&lt; Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00337.html">unwrap_check&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00338.html">unwrap_check&lt; Op&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00339.html">unwrap_check&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00340.html">unwrap_check&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00341.html">unwrap_cube&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00342.html">unwrap_cube&lt; Cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00343.html">unwrap_cube&lt; GlueCube&lt; T1, T2, glue_cube_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00344.html">unwrap_cube&lt; OpCube&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00345.html">unwrap_cube&lt; subview_cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00346.html">unwrap_cube_check&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00347.html">unwrap_cube_check&lt; Cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00348.html">unwrap_cube_check&lt; GlueCube&lt; T1, T2, glue_cube_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00349.html">unwrap_cube_check&lt; OpCube&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00350.html">unwrap_cube_check&lt; subview_cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00351.html">unwrap_cube_write&lt; T1 &gt;</a></td><td class="indexvalue">If the given object in not a cube, <a class="el" href="a00325.html">unwrap</a> it into the given 'out' cube (i.e. do not create another cube) and provide a reference to the 'out' cube. if the given object is a cube, set the size of the 'out' cube to be the same as the given object and provide a reference to the given object </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00352.html">unwrap_cube_write&lt; Cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00353.html">unwrap_cube_write&lt; GlueCube&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00354.html">unwrap_cube_write&lt; OpCube&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00355.html">unwrap_cube_write&lt; subview_cube&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00356.html">unwrap_to_elem_access&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00357.html">unwrap_to_elem_access&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00358.html">unwrap_to_elem_access&lt; Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00359.html">unwrap_to_elem_access&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00360.html">unwrap_to_elem_access&lt; Op&lt; Col&lt; eT &gt;, op_trans &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00361.html">unwrap_to_elem_access&lt; Op&lt; Row&lt; eT &gt;, op_trans &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00362.html">unwrap_to_elem_access&lt; Op&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00363.html">unwrap_to_elem_access&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00364.html">unwrap_to_elem_access&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00365.html">unwrap_write&lt; T1 &gt;</a></td><td class="indexvalue">If the given object in not a matrix, <a class="el" href="a00325.html">unwrap</a> it into the given 'out' matrix (i.e. do not create another matrix) and provide a reference to the 'out' matrix. if the given object is a matrix, set the size of the 'out' matrix to be the same as the given object and provide a reference to the given object </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00366.html">unwrap_write&lt; Col&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00367.html">unwrap_write&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00368.html">unwrap_write&lt; Glue&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00369.html">unwrap_write&lt; Mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00370.html">unwrap_write&lt; Op&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00371.html">unwrap_write&lt; Row&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00372.html">unwrap_write&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00373.html">upgrade_val&lt; T1, T2 &gt;</a></td><td class="indexvalue">Upgrade_val is used to ensure an operation such as multiplication is possible between two types. values are upgraded only where necessary. used by: <a class="el" href="a00662.html#gaa6d80b7c73cb9c665a6b930acf76d0c8" title="element-wise division with different element types">glue_div::apply_mixed()</a>, <a class="el" href="a00666.html#ga8e1dd68c3b92457af6e13d030881de84" title="matrix subtraction with different element types">glue_minus::apply_mixed()</a>, <a class="el" href="a00667.html#ga230a7f2dcea8fde7ff6689f4a1116cf5" title="matrix addition with different element types">glue_plus::apply_mixed()</a>, <a class="el" href="a00668.html#ga9fb4407f420281b8f495e41e2447d99a" title="matrix schur product with different element types">glue_schur::apply_mixed()</a> and <a class="el" href="a00669.html#ga229b087d0091a592689dd50a98e7ade2" title="matrix multiplication with different element types">glue_times::apply_mixed()</a> via gemm_mixed() </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00374.html">upgrade_val&lt; double, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00375.html">upgrade_val&lt; float, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00376.html">upgrade_val&lt; std::complex&lt; double &gt;, float &gt;</a></td><td class="indexvalue">Work around limitations in the complex class (at least as present in gcc 4.1 &amp; 4.3) </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00377.html">upgrade_val&lt; std::complex&lt; double &gt;, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00378.html">upgrade_val&lt; std::complex&lt; float &gt;, double &gt;</a></td><td class="indexvalue">Ensure we don't lose precision when multiplying a complex number with a higher precision real number </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00379.html">upgrade_val&lt; std::complex&lt; float &gt;, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue">Ensure we don't lose precision when multiplying complex numbers with different underlying types </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00380.html">upgrade_val&lt; std::complex&lt; T &gt;, T2 &gt;</a></td><td class="indexvalue">Upgrade a type to allow multiplication with a complex type e.g. the int in "int * complex&lt;double&gt;" is upgraded to a double </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00381.html">upgrade_val&lt; T, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00382.html">upgrade_val&lt; T1, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00383.html">itpp::Vec&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00384.html">wall_clock</a></td><td class="indexvalue">Class for measuring time intervals </td></tr>
</table>
</div>
</BODY>
</HTML>
