<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Armadillo Technical: Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="classaccess.html">access</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__apply__proxy_3_01false_00_01arma__class_01_4.html">arma_apply_proxy&lt; false, arma_class &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__apply__proxy_3_01true_00_01arma__class_01_4.html">arma_apply_proxy&lt; true, arma_class &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__base.html">arma_base&lt; elem_type, arma_derived &gt;</a></td><td class="indexvalue">Class for static polymorphism, modelled after the "Curiously Recurring Template Pattern" (CRTP). Used for type-safe downcasting in functions that restrict their input(s) to be classes that are derived from <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> (e.g. <a class="el" href="classbasic__mat.html" title="Dense matrix class.">basic_mat</a>, <a class="el" href="classop__data.html" title="Class for storing data required for delayed unary operations, such as the operand...">op_data</a>, <a class="el" href="classglue__data.html" title="Class for storing data required for delayed binary operations, such as the operands...">glue_data</a>, <a class="el" href="classdiagview.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>, <a class="el" href="classsubview.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a>). An <a class="el" href="structarma__base.html" title="Class for static polymorphism, modelled after the &quot;Curiously Recurring Template...">arma_base</a> object can be converted to a <a class="el" href="classbasic__mat.html" title="Dense matrix class.">basic_mat</a> object by the <a class="el" href="classunwrap.html">unwrap</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__base__vec.html">arma_base_vec&lt; elem_type, arma_derived_vec &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__config.html">arma_config</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__cx__median__packet.html">arma_cx_median_packet&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structjunk_1_1arma__elem__size__test.html">junk::arma_elem_size_test</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classjunk_1_1arma__first__extra__debug__message.html">junk::arma_first_extra_debug_message</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classarma__ostream.html">arma_ostream</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classarma__qsort__helper.html">arma_qsort_helper&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classarma__qsort__helper_3_01std_1_1complex_3_01T_01_4_01_4.html">arma_qsort_helper&lt; std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__sort__index__packet__ascend.html">arma_sort_index_packet_ascend&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__sort__index__packet__descend.html">arma_sort_index_packet_descend&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__static__assert_3_01true_01_4.html">arma_static_assert&lt; true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__type__check.html">arma_type_check&lt; val &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__version.html">arma_version</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classauxlib.html">auxlib</a></td><td class="indexvalue">Wrapper for accessing external functions defined in ATLAS, LAPACK or BLAS libraries </td></tr>
  <tr><td class="indexkey"><a class="el" href="classbasic__colvec.html">basic_colvec&lt; eT &gt;</a></td><td class="indexvalue">Class for column vectors (matrices with only column) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classarma__boost_1_1basic__format.html">arma_boost::basic_format&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classbasic__mat.html">basic_mat&lt; eT &gt;</a></td><td class="indexvalue">Dense matrix class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classbasic__math.html">basic_math&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classbasic__rowvec.html">basic_rowvec&lt; eT &gt;</a></td><td class="indexvalue">Class for row vectors (matrices with only one row) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to.html">conv_to&lt; out_eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to_3_01basic__colvec_3_01out__eT_01_4_01_4.html">conv_to&lt; basic_colvec&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to_3_01basic__mat_3_01out__eT_01_4_01_4.html">conv_to&lt; basic_mat&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to_3_01basic__rowvec_3_01out__eT_01_4_01_4.html">conv_to&lt; basic_rowvec&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to_3_01itpp_1_1Mat_3_01out__eT_01_4_01_4.html">conv_to&lt; itpp::Mat&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classconv__to_3_01itpp_1_1Vec_3_01out__eT_01_4_01_4.html">conv_to&lt; itpp::Vec&lt; out_eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structdepth__lhs.html">depth_lhs&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="structdepth__lhs.html" title="Template metaprogram depth_lhs calculates the number of glue_data&lt;Tx,Ty, glue_type&gt;...">depth_lhs</a> calculates the number of glue_data&lt;Tx,Ty, glue_type&gt; instances on the left hand side argument of glue_data&lt;Tx,Ty, glue_type&gt; i.e. it recursively expands each Tx, until the type of Tx is not "glue&lt;..,.., glue_type&gt;" (i.e the "glue_type" changes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdepth__lhs_3_01glue__type_00_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">depth_lhs&lt; glue_type, glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classdiagview.html">diagview&lt; eT &gt;</a></td><td class="indexvalue">Class for storing data required to extract and set the diagonals of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classdiskio.html">diskio</a></td><td class="indexvalue">Class for saving and loading matrices and fields </td></tr>
  <tr><td class="indexkey"><a class="el" href="structdiskio_1_1is__supported__type.html">diskio::is_supported_type&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classfield.html">field&lt; oT &gt;</a></td><td class="indexvalue">A lightweight 2D container for abitrary objects (the objects must have a copy constructor) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classfield__aux.html">field_aux</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classarma__boost_1_1format.html">arma_boost::format</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__boost_1_1format__metaprog.html">arma_boost::format_metaprog&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structarma__boost_1_1format__metaprog_3_01basic__format_3_01T1_00_01T2_01_4_01_4.html">arma_boost::format_metaprog&lt; basic_format&lt; T1, T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm.html">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Wrapper for ATLAS/BLAS dgemm function, using template arguments to control the arguments passed to dgemm. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm__emul__cache.html">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemm(), using caching for speedup. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm__emul__simple.html">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemm(), non-cached version. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm__mixed.html">gemm_mixed&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm__mixed__cache.html">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types. Uses caching for speedup. Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemm__mixed__simple.html">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Matrix multplication where the matrices have different element types. Simple version (no caching). Matrix 'C' is assumed to have been set to the correct size (i.e. taking into account transposes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemv.html">gemv&lt; do_trans_A, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Wrapper for ATLAS/BLAS <a class="el" href="classgemv.html" title="Wrapper for ATLAS/BLAS gemv function, using template arguments to control the arguments...">gemv</a> function, using template arguments to control the arguments passed to <a class="el" href="classgemv.html" title="Wrapper for ATLAS/BLAS gemv function, using template arguments to control the arguments...">gemv</a>. 'y' is assumed to have been set to the correct size (i.e. taking into account the transpose) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classgemv__arma.html">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;</a></td><td class="indexvalue">Partial emulation of ATLAS/BLAS gemv(). 'y' is assumed to have been set to the correct size (i.e. taking into account the transpose) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__pod__type.html">get_pod_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structget__pod__type_3_01std_1_1complex_3_01T2_01_4_01_4.html">get_pod_type&lt; std::complex&lt; T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__data.html">glue_data&lt; T1, T2, glue_type &gt;</a></td><td class="indexvalue">Class for storing data required for delayed binary operations, such as the operands (e.g. two matrices) and the binary operator (e.g. addition). The operands are stored as references (which can be optimised away), while the operator is "stored" through the template definition (glue_type). The operands can be 'mat', 'rowvec', 'colvec', 'op_data', and 'glue_data'. Note that as 'glue_data' can be one of the operands, more than two matrices can be stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__div.html">glue_div</a></td><td class="indexvalue">Class which implements the immediate element-wise division of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__minus.html">glue_minus</a></td><td class="indexvalue">Class for the minus operation, where the result is always a dense matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__minus__diag.html">glue_minus_diag</a></td><td class="indexvalue">Class for the minus operation, where one of the operands is a diagonal matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__plus.html">glue_plus</a></td><td class="indexvalue">Class which implements the immediate addition matrices, with the result stored in 'mat' (dense matrix) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__plus__diag.html">glue_plus_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__schur.html">glue_schur</a></td><td class="indexvalue">Class which implements the immediate Schur product (element-wise multiplication) of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__schur__diag.html">glue_schur_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__times.html">glue_times</a></td><td class="indexvalue">Class which implements the immediate multiplication of two or more matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__times__diag.html">glue_times_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classglue__times__vec.html">glue_times_vec</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__arma__type.html">is_arma_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__colvec.html">is_basic_colvec&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__colvec_3_01basic__colvec_3_01eT_01_4_01_4.html">is_basic_colvec&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat.html">is_basic_mat&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat_3_01basic__colvec_3_01eT_01_4_01_4.html">is_basic_mat&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat_3_01basic__mat_3_01eT_01_4_01_4.html">is_basic_mat&lt; basic_mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat_3_01basic__rowvec_3_01eT_01_4_01_4.html">is_basic_mat&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat__only.html">is_basic_mat_only&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__mat__only_3_01basic__mat_3_01eT_01_4_01_4.html">is_basic_mat_only&lt; basic_mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__rowvec.html">is_basic_rowvec&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__basic__rowvec_3_01basic__rowvec_3_01eT_01_4_01_4.html">is_basic_rowvec&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex.html">is_complex&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex_3_01std_1_1complex_3_01eT_01_4_01_4.html">is_complex&lt; std::complex&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex_3_01std_1_1complex_3_01float_01_4_01_4.html">is_complex&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex__double.html">is_complex_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex__double_3_01std_1_1complex_3_01double_01_4_01_4.html">is_complex_double&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__complex__float.html">is_complex_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__diagview.html">is_diagview&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__diagview_3_01diagview_3_01eT_01_4_01_4.html">is_diagview&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__double.html">is_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__double_3_01double_01_4.html">is_double&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__float.html">is_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__float_3_01float_01_4.html">is_float&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__glue__data.html">is_glue_data&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__glue__data_3_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">is_glue_data&lt; glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__non__integral.html">is_non_integral&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__op__data.html">is_op_data&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__op__data_3_01op__data_3_01T1_00_01op__type_01_4_01_4.html">is_op_data&lt; op_data&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s16.html">is_s16&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s16_3_01s16_01_4.html">is_s16&lt; s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s32.html">is_s32&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s32_3_01s32_01_4.html">is_s32&lt; s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s8.html">is_s8&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__s8_3_01s8_01_4.html">is_s8&lt; s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__same__type.html">is_same_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__same__type_3_01T1_00_01T1_01_4.html">is_same_type&lt; T1, T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__signed.html">is_signed&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__subview.html">is_subview&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__subview_3_01subview_3_01eT_01_4_01_4.html">is_subview&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__blas__type.html">is_supported_blas_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex.html">is_supported_complex&lt; T1 &gt;</a></td><td class="indexvalue">Check for a weird implementation of the std::complex class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex_3_01std_1_1complex_3_01eT_01_4_01_4.html">is_supported_complex&lt; std::complex&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex__double.html">is_supported_complex_double&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex__double_3_01std_1_1complex_3_01double_01_4_01_4.html">is_supported_complex_double&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex__float.html">is_supported_complex_float&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__complex__float_3_01std_1_1complex_3_01float_01_4_01_4.html">is_supported_complex_float&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__supported__elem__type.html">is_supported_elem_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u16.html">is_u16&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u16_3_01u16_01_4.html">is_u16&lt; u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u32.html">is_u32&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u32_3_01u32_01_4.html">is_u32&lt; u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u8.html">is_u8&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structis__u8_3_01u8_01_4.html">is_u8&lt; u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt.html">isnt_fltpt&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt_3_01double_01_4.html">isnt_fltpt&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt_3_01float_01_4.html">isnt_fltpt&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt_3_01long_01double_01_4.html">isnt_fltpt&lt; long double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt_3_01std_1_1complex_3_01double_01_4_01_4.html">isnt_fltpt&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt_3_01std_1_1complex_3_01float_01_4_01_4.html">isnt_fltpt&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__fltpt__false.html">isnt_fltpt_false</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__same__type.html">isnt_same_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__same__type_3_01T1_00_01T1_01_4.html">isnt_same_type&lt; T1, T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type.html">isnt_supported_elem_type&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01double_01_4.html">isnt_supported_elem_type&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01float_01_4.html">isnt_supported_elem_type&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01s16_01_4.html">isnt_supported_elem_type&lt; s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01s32_01_4.html">isnt_supported_elem_type&lt; s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01s8_01_4.html">isnt_supported_elem_type&lt; s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01std_1_1complex_3_01double_01_4_01_4.html">isnt_supported_elem_type&lt; std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01std_1_1complex_3_01float_01_4_01_4.html">isnt_supported_elem_type&lt; std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01u16_01_4.html">isnt_supported_elem_type&lt; u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01u32_01_4.html">isnt_supported_elem_type&lt; u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type_3_01u8_01_4.html">isnt_supported_elem_type&lt; u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structisnt__supported__elem__type__false.html">isnt_supported_elem_type_false</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classitpp_1_1Mat.html">itpp::Mat&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structmat__ptrs.html">mat_ptrs&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="structmat__ptrs.html" title="Template metaprogram mat_ptrs fills a given array with addresses of matrices from...">mat_ptrs</a> fills a given array with addresses of matrices from a recursive instance of glue_data&lt;Tx,Ty, glue_type&gt;. While parsing the recursive instance, if encountered objects are of type <a class="el" href="classop__data.html" title="Class for storing data required for delayed unary operations, such as the operand...">op_data</a>&lt;..&gt;, they are converted to type 'mat' first </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmat__ptrs_3_01glue__type_00_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">mat_ptrs&lt; glue_type, glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structmat__ptrs__outcheck.html">mat_ptrs_outcheck&lt; glue_type, T1 &gt;</a></td><td class="indexvalue">Template metaprogram <a class="el" href="structmat__ptrs__outcheck.html" title="template metaprogram mat_ptrs_outcheck builds on &#39;mat_ptrs&#39; by also checking...">mat_ptrs_outcheck</a> builds on 'mat_ptrs' by also checking whether any of the input matrices are aliases of the output matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="structmat__ptrs__outcheck_3_01glue__type_00_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">mat_ptrs_outcheck&lt; glue_type, glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__acos.html">op_acos</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__acosh.html">op_acosh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__asin.html">op_asin</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__asinh.html">op_asinh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__atan.html">op_atan</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__atanh.html">op_atanh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__conj.html">op_conj</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__cos.html">op_cos</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__cosh.html">op_cosh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__data.html">op_data&lt; T1, op_type &gt;</a></td><td class="indexvalue">Class for storing data required for delayed unary operations, such as the operand (e.g. the matrix to which the operation is to be applied) and the unary operator (e.g. inverse). The operand is stored as a reference (which can be optimised away), while the operator is "stored" through the template definition (op_type). The operands can be 'mat', 'rowvec', 'colvec', 'op_data', and 'glue_data'. Note that as 'glue_data' can be one of the operands, more than one matrix can be stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__diagmat.html">op_diagmat</a></td><td class="indexvalue">Convert a mat/rowvec/colvec to a diagonal matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__diagmat__vec.html">op_diagmat_vec</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__dot.html">op_dot</a></td><td class="indexvalue">Dot product operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__exp.html">op_exp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__htrans.html">op_htrans</a></td><td class="indexvalue">'hermitian transpose' operation (only valid for complex number matrices) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__inv.html">op_inv</a></td><td class="indexvalue">'invert matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__log.html">op_log</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__log10.html">op_log10</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__max.html">op_max</a></td><td class="indexvalue">Class for finding maximum values in a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__mean.html">op_mean</a></td><td class="indexvalue">Class for finding mean values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__median.html">op_median</a></td><td class="indexvalue">Class for finding median values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__min.html">op_min</a></td><td class="indexvalue">Class for finding minimum values in a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__neg.html">op_neg</a></td><td class="indexvalue">'negate matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__norm__dot.html">op_norm_dot</a></td><td class="indexvalue">Normalised dot product operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__ones__diag.html">op_ones_diag</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__ones__full.html">op_ones_full</a></td><td class="indexvalue">Class for creation of a dense matrix/vector with all elements set to one </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__pow.html">op_pow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__pow__s32.html">op_pow_s32</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__rand.html">op_rand</a></td><td class="indexvalue">'generate matrix with random values' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__randn.html">op_randn</a></td><td class="indexvalue">'generate matrix with random values' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__div__post.html">op_scalar_div_post</a></td><td class="indexvalue">'divide matrix by a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__div__pre.html">op_scalar_div_pre</a></td><td class="indexvalue">'divide scalar by a matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__minus__post.html">op_scalar_minus_post</a></td><td class="indexvalue">'subtract scalar from matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__minus__pre.html">op_scalar_minus_pre</a></td><td class="indexvalue">'subtract matrix from a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__plus.html">op_scalar_plus</a></td><td class="indexvalue">'add scalar to matrix' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__scalar__times.html">op_scalar_times</a></td><td class="indexvalue">'multiply matrix by a scalar' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__sin.html">op_sin</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__sinh.html">op_sinh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__sort.html">op_sort</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__sqrt.html">op_sqrt</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__square.html">op_square</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__stddev.html">op_stddev</a></td><td class="indexvalue">Class for finding the standard deviation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__sum.html">op_sum</a></td><td class="indexvalue">Class for finding sums of values in a matrix (e.g. along rows or columns) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__tan.html">op_tan</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__tanh.html">op_tanh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__trans.html">op_trans</a></td><td class="indexvalue">'matrix transpose' operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__trunc__exp.html">op_trunc_exp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__trunc__log.html">op_trunc_log</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__var.html">op_var</a></td><td class="indexvalue">Class for finding variance values of a matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classop__zeros.html">op_zeros</a></td><td class="indexvalue">Generate matrix/vector with all elements set to zero </td></tr>
  <tr><td class="indexkey"><a class="el" href="classpodarray.html">podarray&lt; T1 &gt;</a></td><td class="indexvalue">A lightweight array for POD types. If the amount of memory requested is small, the stack is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type.html">promote_type&lt; T1, T2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01float_01_4.html">promote_type&lt; double, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01s16_01_4.html">promote_type&lt; double, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01s32_01_4.html">promote_type&lt; double, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01s8_01_4.html">promote_type&lt; double, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01std_1_1complex_3_01float_01_4_01_4.html">promote_type&lt; double, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01u16_01_4.html">promote_type&lt; double, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01u32_01_4.html">promote_type&lt; double, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01double_00_01u8_01_4.html">promote_type&lt; double, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01double_01_4.html">promote_type&lt; float, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01s16_01_4.html">promote_type&lt; float, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01s32_01_4.html">promote_type&lt; float, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01s8_01_4.html">promote_type&lt; float, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01std_1_1complex_3_01double_01_4_01_4.html">promote_type&lt; float, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01u16_01_4.html">promote_type&lt; float, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01u32_01_4.html">promote_type&lt; float, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01float_00_01u8_01_4.html">promote_type&lt; float, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01double_01_4.html">promote_type&lt; s16, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01float_01_4.html">promote_type&lt; s16, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01s32_01_4.html">promote_type&lt; s16, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01s8_01_4.html">promote_type&lt; s16, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; s16, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01u16_01_4.html">promote_type&lt; s16, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01u32_01_4.html">promote_type&lt; s16, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s16_00_01u8_01_4.html">promote_type&lt; s16, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01double_01_4.html">promote_type&lt; s32, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01float_01_4.html">promote_type&lt; s32, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01s16_01_4.html">promote_type&lt; s32, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01s8_01_4.html">promote_type&lt; s32, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; s32, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01u16_01_4.html">promote_type&lt; s32, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01u32_01_4.html">promote_type&lt; s32, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s32_00_01u8_01_4.html">promote_type&lt; s32, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01double_01_4.html">promote_type&lt; s8, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01float_01_4.html">promote_type&lt; s8, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01s16_01_4.html">promote_type&lt; s8, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01s32_01_4.html">promote_type&lt; s8, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; s8, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01u16_01_4.html">promote_type&lt; s8, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01u32_01_4.html">promote_type&lt; s8, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01s8_00_01u8_01_4.html">promote_type&lt; s8, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01double_01_4_00_01float_01_4.html">promote_type&lt; std::complex&lt; double &gt;, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01double_01_4_00_01std_1_1complex_3_01float_01_4_01_4.html">promote_type&lt; std::complex&lt; double &gt;, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01float_01_4_00_01double_01_4.html">promote_type&lt; std::complex&lt; float &gt;, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01float_01_4_00_01std_1_1complex_3_01double_01_4_01_4.html">promote_type&lt; std::complex&lt; float &gt;, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01s16_01_4.html">promote_type&lt; std::complex&lt; T &gt;, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01s32_01_4.html">promote_type&lt; std::complex&lt; T &gt;, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01s8_01_4.html">promote_type&lt; std::complex&lt; T &gt;, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01T_01_4.html">promote_type&lt; std::complex&lt; T &gt;, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01u16_01_4.html">promote_type&lt; std::complex&lt; T &gt;, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01u32_01_4.html">promote_type&lt; std::complex&lt; T &gt;, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01std_1_1complex_3_01T_01_4_00_01u8_01_4.html">promote_type&lt; std::complex&lt; T &gt;, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01T_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; T, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01T_00_01T_01_4.html">promote_type&lt; T, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01double_01_4.html">promote_type&lt; u16, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01float_01_4.html">promote_type&lt; u16, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01s16_01_4.html">promote_type&lt; u16, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01s32_01_4.html">promote_type&lt; u16, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01s8_01_4.html">promote_type&lt; u16, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; u16, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01u32_01_4.html">promote_type&lt; u16, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u16_00_01u8_01_4.html">promote_type&lt; u16, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01double_01_4.html">promote_type&lt; u32, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01float_01_4.html">promote_type&lt; u32, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01s16_01_4.html">promote_type&lt; u32, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01s32_01_4.html">promote_type&lt; u32, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01s8_01_4.html">promote_type&lt; u32, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; u32, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01u16_01_4.html">promote_type&lt; u32, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u32_00_01u8_01_4.html">promote_type&lt; u32, u8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01double_01_4.html">promote_type&lt; u8, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01float_01_4.html">promote_type&lt; u8, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01s16_01_4.html">promote_type&lt; u8, s16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01s32_01_4.html">promote_type&lt; u8, s32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01s8_01_4.html">promote_type&lt; u8, s8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01std_1_1complex_3_01T_01_4_01_4.html">promote_type&lt; u8, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01u16_01_4.html">promote_type&lt; u8, u16 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type_3_01u8_00_01u32_01_4.html">promote_type&lt; u8, u32 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structpromote__type__ok.html">promote_type_ok</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsort__index__result__type__deducer.html">sort_index_result_type_deducer&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsort__index__result__type__deducer_3_01basic__colvec_3_01eT_01_4_01_4.html">sort_index_result_type_deducer&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structsort__index__result__type__deducer_3_01basic__rowvec_3_01eT_01_4_01_4.html">sort_index_result_type_deducer&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classsubview.html">subview&lt; eT &gt;</a></td><td class="indexvalue">Class for storing data required to construct or apply operations to a submatrix (i.e. where the submatrix starts and ends as well as a reference/pointer to the original matrix), </td></tr>
  <tr><td class="indexkey"><a class="el" href="classsubview__col.html">subview_col&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classsubview__field.html">subview_field&lt; oT &gt;</a></td><td class="indexvalue">Class for storing data required to construct or apply operations to a subfield (i.e. where the subfield starts and ends as well as a reference/pointer to the original <a class="el" href="classfield.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a>), </td></tr>
  <tr><td class="indexkey"><a class="el" href="classsubview__row.html">subview_row&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classsyslib.html">syslib</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap.html">unwrap&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01basic__colvec_3_01eT_01_4_01_4.html">unwrap&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01basic__mat_3_01eT_01_4_01_4.html">unwrap&lt; basic_mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01basic__rowvec_3_01eT_01_4_01_4.html">unwrap&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01diagview_3_01eT_01_4_01_4.html">unwrap&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">unwrap&lt; glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01op__data_3_01T1_00_01op__type_01_4_01_4.html">unwrap&lt; op_data&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap_3_01subview_3_01eT_01_4_01_4.html">unwrap&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check.html">unwrap_check&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01basic__colvec_3_01eT_01_4_01_4.html">unwrap_check&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01basic__mat_3_01eT_01_4_01_4.html">unwrap_check&lt; basic_mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01basic__rowvec_3_01eT_01_4_01_4.html">unwrap_check&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01diagview_3_01eT_01_4_01_4.html">unwrap_check&lt; diagview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">unwrap_check&lt; glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01op__data_3_01T1_00_01op__type_01_4_01_4.html">unwrap_check&lt; op_data&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__check_3_01subview_3_01eT_01_4_01_4.html">unwrap_check&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access.html">unwrap_to_elem_access&lt; T1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01basic__colvec_3_01eT_01_4_01_4.html">unwrap_to_elem_access&lt; basic_colvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01basic__mat_3_01eT_01_4_01_4.html">unwrap_to_elem_access&lt; basic_mat&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01basic__rowvec_3_01eT_01_4_01_4.html">unwrap_to_elem_access&lt; basic_rowvec&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01glue__data_3_01T1_00_01T2_00_01glue__type_01_4_01_4.html">unwrap_to_elem_access&lt; glue_data&lt; T1, T2, glue_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01op__data_3_01basic__colvec_3_01eT_01_4_00_01op__trans_01_4_01_4.html">unwrap_to_elem_access&lt; op_data&lt; basic_colvec&lt; eT &gt;, op_trans &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01op__data_3_01basic__rowvec_3_01eT_01_4_00_01op__trans_01_4_01_4.html">unwrap_to_elem_access&lt; op_data&lt; basic_rowvec&lt; eT &gt;, op_trans &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01op__data_3_01T1_00_01op__type_01_4_01_4.html">unwrap_to_elem_access&lt; op_data&lt; T1, op_type &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classunwrap__to__elem__access_3_01subview_3_01eT_01_4_01_4.html">unwrap_to_elem_access&lt; subview&lt; eT &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val.html">upgrade_val&lt; T1, T2 &gt;</a></td><td class="indexvalue">Upgrade_val is used to ensure an operation such as multiplication is possible between two types. values are upgraded only where necessary. used by: <a class="el" href="group__glue__div.html#g861b41c54f2e365d21fec780dac7f980">glue_div::apply_mixed()</a>, <a class="el" href="group__glue__minus.html#gf338919ea974a8ca8cb6f3f24cb009a2">glue_minus::apply_mixed()</a>, <a class="el" href="group__glue__plus.html#g533ae9716a6f8afbc50696d3b6eb2c8a">glue_plus::apply_mixed()</a>, <a class="el" href="group__glue__schur.html#g011d0547ea60ca28361c5e0951cd2560">glue_schur::apply_mixed()</a> and <a class="el" href="group__glue__times.html#g9e0f686087fbf3b3fa8dbde121b18517">glue_times::apply_mixed()</a> via gemm_mixed() </td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01double_00_01std_1_1complex_3_01float_01_4_01_4.html">upgrade_val&lt; double, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01float_00_01std_1_1complex_3_01double_01_4_01_4.html">upgrade_val&lt; float, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01std_1_1complex_3_01double_01_4_00_01float_01_4.html">upgrade_val&lt; std::complex&lt; double &gt;, float &gt;</a></td><td class="indexvalue">Work around limitations in the complex class (at least as present in gcc 4.1 &amp; 4.3) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01std_1_1complex_3_01double_01_4_00_01std_1_1complex_3_01float_01_4_01_4.html">upgrade_val&lt; std::complex&lt; double &gt;, std::complex&lt; float &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01std_1_1complex_3_01float_01_4_00_01double_01_4.html">upgrade_val&lt; std::complex&lt; float &gt;, double &gt;</a></td><td class="indexvalue">Ensure we don't lose precision when multiplying a complex number with a higher precision real number </td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01std_1_1complex_3_01float_01_4_00_01std_1_1complex_3_01double_01_4_01_4.html">upgrade_val&lt; std::complex&lt; float &gt;, std::complex&lt; double &gt; &gt;</a></td><td class="indexvalue">Ensure we don't lose precision when multiplying a complex numbers with different underlying types </td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01std_1_1complex_3_01T_01_4_00_01T2_01_4.html">upgrade_val&lt; std::complex&lt; T &gt;, T2 &gt;</a></td><td class="indexvalue">Upgrade a type to allow multiplication with a complex type e.g. the int in "int * complex&lt;double&gt;" is upgraded to a double </td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01T_00_01T_01_4.html">upgrade_val&lt; T, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structupgrade__val_3_01T1_00_01std_1_1complex_3_01T_01_4_01_4.html">upgrade_val&lt; T1, std::complex&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classitpp_1_1Vec.html">itpp::Vec&lt; eT &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classwall__clock.html">wall_clock</a></td><td class="indexvalue">Class for measuring time intervals </td></tr>
</table>
</div>
</BODY>
</HTML>
