<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: diskio Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>diskio Class Reference<br/>
<small>
[<a class="el" href="a00890.html">Diskio</a>]</small>
</h1><!-- doxytag: class="diskio" -->
<p>class for saving and loading matrices and fields  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00649_source.html">diskio_proto.hpp</a>&gt;</code></p>

<p><a href="a01144.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html">is_supported_type</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga8e793aceb1da177184d0805698d9e914">load_ppm_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gae34cba5cc0b9a61a22df7d5d9fd12125">load_ppm_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga67cf3529485a5f03a42e9a4fddcee5b6">save_ppm_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaf06795a4029da9f236fe377456c36757">save_ppm_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaa99252a20f066762a161ca8ceb9b2c29">gen_txt_header</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in text format. Format: "ARMA_MAT_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00890.html#gaa99252a20f066762a161ca8ceb9b2c29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gafea81731918e03aedf946fafceda27b5">gen_bin_header</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving matrices in binary format. Format: "ARMA_MAT_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00890.html#gafea81731918e03aedf946fafceda27b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gacc59f2968b7cc76c746183cb61dcfe04">gen_txt_header</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in text format. Format: "ARMA_CUB_TXT_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00890.html#gacc59f2968b7cc76c746183cb61dcfe04"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gae12c3543c4168cd7a2fade35eeee82b4">gen_bin_header</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate the first line of the header used for saving cubes in binary format. Format: "ARMA_CUB_BIN_ABXYZ". A is one of: I (for integral types) or F (for floating point types). B is one of: U (for unsigned types), S (for signed types), N (for not appliable) or C (for complex types). XYZ specifies the width of each element in terms of bytes, e.g. "008" indicates eight bytes.  <a href="a00890.html#gae12c3543c4168cd7a2fade35eeee82b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#gaf1b98a9e26843fbaad5a12d626053023">conv_to_hex_char</a> (const <a class="el" href="a01037.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#gae1927b3ea8735a7d1e77d89405f592e3">conv_to_hex</a> (char *out, const <a class="el" href="a01037.html#gaed742c436da53c1080638ce6ef7d13de">u8</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#ga81ac9508b1ee96fd24338a9701aeda71">gen_tmp_name</a> (const std::string &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a quasi-random string to the given filename. The <a class="el" href="a00937.html#gab0b2227ea064a59987a6a896ede44a92" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> function is deliberately not used, as <a class="el" href="a00937.html#gab0b2227ea064a59987a6a896ede44a92" title="Generate a dense matrix with all elements set to random values in the [0,1] interval...">rand()</a> has an internal state that changes from call to call. Such states should not be modified in scientific applications, where the results should be reproducable and not affected by saving data.  <a href="a00890.html#ga81ac9508b1ee96fd24338a9701aeda71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#gafd37296c4660795ae79ddb0766d4551a">safe_rename</a> (const std::string &amp;old_name, const std::string &amp;new_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safely rename a file. Before renaming, test if we can write to the final file. This should prevent: (i) overwriting files that have been write protected, (ii) overwriting directories.  <a href="a00890.html#gafd37296c4660795ae79ddb0766d4551a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga6d482ba36dd7a467081e8e608c91f581">save_raw_ascii</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="a00890.html#ga6d482ba36dd7a467081e8e608c91f581"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga4d326e8be2c5b95ef3337717b86f4329">save_arma_ascii</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00890.html#ga4d326e8be2c5b95ef3337717b86f4329"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga52459bb7a66f63027bd814a9dd9d5cfe">save_arma_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00890.html#ga52459bb7a66f63027bd814a9dd9d5cfe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gadb705639c3cf3421a30622b20d19b835">save_pgm_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00890.html#gadb705639c3cf3421a30622b20d19b835"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga7081922d5091fc28d3cab0e82bc3398c">save_pgm_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00890.html#ga7081922d5091fc28d3cab0e82bc3398c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga666e1a293a0401a86c881822cd32140e">save_raw_ascii</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as raw text (no header, human readable). Matrices can be loaded in Matlab and Octave, as long as they don't have complex elements.  <a href="a00890.html#ga666e1a293a0401a86c881822cd32140e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga62dac251620edbe6725e919e638f490f">save_arma_ascii</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00890.html#ga62dac251620edbe6725e919e638f490f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaa40b81a651ed16838b88e2430d1b3ddd">save_arma_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix in binary format, with a header that stores the matrix type as well as its dimensions.  <a href="a00890.html#gaa40b81a651ed16838b88e2430d1b3ddd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga20673c20655c5edd2da5d273db3e44f1">save_pgm_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00890.html#ga20673c20655c5edd2da5d273db3e44f1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gad632460302bf088555c2c94c0c29cacd">save_pgm_binary</a> (const <a class="el" href="a00389.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a matrix as a PGM greyscale image.  <a href="a00890.html#gad632460302bf088555c2c94c0c29cacd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gac5f0bc3bf04a756ee45c9fafa593a760">load_raw_ascii</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="a00890.html#gac5f0bc3bf04a756ee45c9fafa593a760"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga59177b0451d297eaa761569c1350d736">load_arma_ascii</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00890.html#ga59177b0451d297eaa761569c1350d736"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga14261f1417e2d4c23afe9ff73335cd67">load_arma_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in binary format, with a header that indicates the matrix type as well as its dimensions.  <a href="a00890.html#ga14261f1417e2d4c23afe9ff73335cd67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gadcec9609327e33974263176c554e1b8e">load_pgm_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00890.html#gadcec9609327e33974263176c554e1b8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gae15baa7a87a49e9fbf2ac766872fb82f">load_pgm_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00890.html#gae15baa7a87a49e9fbf2ac766872fb82f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaa1e1d5f014eb35a2d27e5867c7766426">load_auto_detect</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="a00890.html#gaa1e1d5f014eb35a2d27e5867c7766426"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaa85ac1fad967883b45aa8c855c1e43e9">load_raw_ascii</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix as raw text (no header, human readable). Can read matrices saved as text in Matlab and Octave. NOTE: this is much slower than reading a file with a header.  <a href="a00890.html#gaa85ac1fad967883b45aa8c855c1e43e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga86e7be8c0b169b5fee5f9bc5df67d8bf">load_arma_ascii</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a matrix in text format (human readable), with a header that indicates the matrix type as well as its dimensions.  <a href="a00890.html#ga86e7be8c0b169b5fee5f9bc5df67d8bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga26ef639dbb61370dede2b2583063ce9d">load_arma_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaeeed68e89d44a73daf0ee2e07477eade">load_pgm_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::istream &amp;is, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00890.html#gaeeed68e89d44a73daf0ee2e07477eade"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga0fce658dcaacf0505eb4aa3a848103df">load_pgm_binary</a> (<a class="el" href="a00389.html">Mat</a>&lt; std::complex&lt; T &gt; &gt; &amp;x, std::istream &amp;is, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a PGM greyscale image as a matrix.  <a href="a00890.html#ga0fce658dcaacf0505eb4aa3a848103df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga21a867aed20b0711f64ec17d57cdff79">load_auto_detect</a> (<a class="el" href="a00389.html">Mat</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a matrix by automatically determining its type.  <a href="a00890.html#ga21a867aed20b0711f64ec17d57cdff79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#ga49b5a9c169b0cb638a029af61f922c97">pnm_skip_comments</a> (std::istream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga66a999e3d87d790e515111d3ac84cb0f">save_raw_ascii</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="a00890.html#ga66a999e3d87d790e515111d3ac84cb0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga54b330dafff944f77f5024db0096d225">save_arma_ascii</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00890.html#ga54b330dafff944f77f5024db0096d225"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga6bb7fea33753e8fa2e91f2c3ce0280a8">save_arma_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="a00890.html#ga6bb7fea33753e8fa2e91f2c3ce0280a8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga9ebe66100757d8c89ecce6dedcbafa3e">save_raw_ascii</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube as raw text (no header, human readable).  <a href="a00890.html#ga9ebe66100757d8c89ecce6dedcbafa3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga4e7d80e223a5fe3f010f993d233ea1cc">save_arma_ascii</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00890.html#ga4e7d80e223a5fe3f010f993d233ea1cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga6e40373aa5b8f733a4ff0ce50ad92c4f">save_arma_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a cube in binary format, with a header that stores the cube type as well as its dimensions.  <a href="a00890.html#ga6e40373aa5b8f733a4ff0ce50ad92c4f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga15486271cfa18d452c84b77b5e967989">load_raw_ascii</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="a00890.html#ga15486271cfa18d452c84b77b5e967989"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaf3654e7f6f762884695434295bbefc64">load_arma_ascii</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00890.html#gaf3654e7f6f762884695434295bbefc64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga7b292c8c44cb548521daa2db53ba12e4">load_arma_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in binary format, with a header that indicates the cube type as well as its dimensions.  <a href="a00890.html#ga7b292c8c44cb548521daa2db53ba12e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga643135029f713fb8498de714a5672c6a">load_auto_detect</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="a00890.html#ga643135029f713fb8498de714a5672c6a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga4660c48953d0400100e2d46cb346a82f">load_raw_ascii</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube as raw text (no header, human readable). NOTE: this is much slower than reading a file with a header.  <a href="a00890.html#ga4660c48953d0400100e2d46cb346a82f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga58a4cec4db8d7eb948444d804ec17cfd">load_arma_ascii</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a cube in text format (human readable), with a header that indicates the cube type as well as its dimensions.  <a href="a00890.html#ga58a4cec4db8d7eb948444d804ec17cfd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga1de9933c506010bd29376802b7557ee6">load_arma_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga054889baa454ba4e20bf22c2fe107082">load_auto_detect</a> (<a class="el" href="a00123.html">Cube</a>&lt; eT &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a cube by automatically determining its type.  <a href="a00890.html#ga054889baa454ba4e20bf22c2fe107082"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga7c4cc7bead39273dff85afca31499473">save_arma_binary</a> (const <a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gafe6d02389f86c0ccf09ef4e833c9e097">save_arma_binary</a> (const <a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gadf2f5cd66790e49e98881a79b34021fd">load_arma_binary</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gae0712c759b9ab2fc7561b8b7aadb3c72">load_arma_binary</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gadca424912cf90e51dc602866adf7eab1">load_auto_detect</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00230.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="a00890.html#gadca424912cf90e51dc602866adf7eab1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaf274a4171ea30a0f55f8c26ae01eace4">load_auto_detect</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to load a <a class="el" href="a00230.html" title="A lightweight 2D container for abitrary objects (the objects must have a copy constructor)...">field</a> by automatically determining its type.  <a href="a00890.html#gaf274a4171ea30a0f55f8c26ae01eace4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#ga73e50db8af7ebe8efcd413a7199ab6d4">save_std_string</a> (const <a class="el" href="a00230.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#ga8c3b8ed182277b50ce77c992c10757d0">save_std_string</a> (const <a class="el" href="a00230.html">field</a>&lt; std::string &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#gaafeba997e7fd02a3a9f323e593c6b9ab">load_std_string</a> (<a class="el" href="a00230.html">field</a>&lt; std::string &gt; &amp;x, const std::string &amp;name, std::string &amp;err_msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html#ga10a33bd4f1aba32a638b9292f7748797">load_std_string</a> (<a class="el" href="a00230.html">field</a>&lt; std::string &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00136.html#a0e140f86ff0be915c41e769517d7eb5b">save_ppm_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00136.html#ac55f2b18591f9ed9227a23e634035a54">save_ppm_binary</a> (const <a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00136.html#a21bd8dcf7dd78f3babff12d51df2ae1b">load_ppm_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00136.html#a762b23f0a57a58411c9d599cdb2a17db">load_ppm_binary</a> (<a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga7e18d6d6485e4d1e6537aea1345a0dd5">save_ppm_binary</a> (const <a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#ga2a74e106e35437820df23c5326b7ff94">save_ppm_binary</a> (const <a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, std::ostream &amp;f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gaf2e66dd6e276bcf8acfd71f548c32c58">load_ppm_binary</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::string &amp;err_msg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00890.html#gae02243e85c380a43afa400447b952493">load_ppm_binary</a> (<a class="el" href="a00230.html">field</a>&lt; T1 &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>class for saving and loading matrices and fields </p>

<p>Definition at line <a class="el" href="a00649_source.html#l00023">23</a> of file <a class="el" href="a00649_source.html">diskio_proto.hpp</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0e140f86ff0be915c41e769517d7eb5b"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="a0e140f86ff0be915c41e769517d7eb5b" args="(const Cube&lt; T1 &gt; &amp;x, const std::string &amp;final_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="a00669_source.html#l01234">field_aux::save()</a>, <a class="el" href="a00642_source.html#l01727">Cube&lt; eT &gt;::save()</a>, and <a class="el" href="a00648_source.html#l02222">save_ppm_binary()</a>.</p>

</div>
</div>
<a class="anchor" id="ac55f2b18591f9ed9227a23e634035a54"></a><!-- doxytag: member="diskio::save_ppm_binary" ref="ac55f2b18591f9ed9227a23e634035a54" args="(const Cube&lt; T1 &gt; &amp;x, std::ostream &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool diskio::save_ppm_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21bd8dcf7dd78f3babff12d51df2ae1b"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="a21bd8dcf7dd78f3babff12d51df2ae1b" args="(Cube&lt; T1 &gt; &amp;x, const std::string &amp;final_name, std::string &amp;err_msg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>final_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>err_msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="a00669_source.html#l01284">field_aux::load()</a>, <a class="el" href="a00642_source.html#l01807">Cube&lt; eT &gt;::load()</a>, <a class="el" href="a00648_source.html#l01689">load_auto_detect()</a>, and <a class="el" href="a00648_source.html#l02094">load_ppm_binary()</a>.</p>

</div>
</div>
<a class="anchor" id="a762b23f0a57a58411c9d599cdb2a17db"></a><!-- doxytag: member="diskio::load_ppm_binary" ref="a762b23f0a57a58411c9d599cdb2a17db" args="(Cube&lt; T1 &gt; &amp;x, std::istream &amp;f, std::string &amp;err_msg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool diskio::load_ppm_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00123.html">Cube</a>&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>err_msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
</BODY>
</HTML>
