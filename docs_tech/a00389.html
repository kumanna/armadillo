<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Mat&lt; eT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Mat&lt; eT &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00975.html">Mat</a>]</small>
</h1><!-- doxytag: class="Mat" --><!-- doxytag: inherits="Base&lt; eT, Mat&lt; eT &gt; &gt;" -->
<p>Dense matrix class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00759_source.html">Mat_proto.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Mat&lt; eT &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="a00389.gif" usemap="#Mat&lt; eT &gt;_map" alt=""/>
  <map id="Mat&lt; eT &gt;_map" name="Mat&lt; eT &gt;_map">
<area href="a00103.html" alt="Base&lt; eT, Mat&lt; eT &gt; &gt;" shape="rect" coords="78,0,224,24"/>
<area href="a00112.html" alt="Col&lt; eT &gt;" shape="rect" coords="0,112,146,136"/>
<area href="a00578.html" alt="Row&lt; eT &gt;" shape="rect" coords="156,112,302,136"/>
</map>
 </div>
</div>

<p><a href="a01395.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">const_row_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00579.html">row_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of elements stored in the matrix  <a href="#a3b7c1109cca98fb4bf493b8be33c4299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00245.html">get_pod_type</a>&lt; eT &gt;::result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a0fc14012052d730de3388eaac02e540d">pod_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex  <a href="#a0fc14012052d730de3388eaac02e540d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a28d8b1a8e68d6d2975dd1072f6904ee0">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a79aaf5045e97720d8ca9b9115a5c4e77">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a79c4fa96d87168eef289bb2682f10728">col_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a0e62996616bbebf568309184a171b05b">const_col_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga3b82e7c8bced32cad06a0d3353d86a0e">~Mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gae6672df794f7ec95a2ef60165b296e14">Mat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga017548674d56b5400940606bfe3caa6e">Mat</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct the matrix to have user specified dimensions  <a href="a00975.html#ga017548674d56b5400940606bfe3caa6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga3a2b6f33180c63af39433d6e59594e46">Mat</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00975.html#ga3a2b6f33180c63af39433d6e59594e46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga0d1d28a725ef1232c8d7b404cc0dd302">operator=</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00975.html#ga0d1d28a725ef1232c8d7b404cc0dd302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga08056e3a5f18347bbc0edd1aefef8870">Mat</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00975.html#ga08056e3a5f18347bbc0edd1aefef8870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga395ddf62b79a1ab93f54c7f5859deb40">operator=</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create the matrix from a textual description  <a href="a00975.html#ga395ddf62b79a1ab93f54c7f5859deb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac401a31e52150d0a6291bd0bc1d4c91d">Mat</a> (eT *aux_mem, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols, const bool copy_aux_mem=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given auxiliary array of eTs. if copy_aux_mem is true, new memory is allocated and the array is copied. if copy_aux_mem is false, the auxiliary array is used directly (without allocating memory and copying). the default is to copy the array.  <a href="a00975.html#gac401a31e52150d0a6291bd0bc1d4c91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga0ab642c6dc44b0b2f09dd5c2045d7071">Mat</a> (const eT *aux_mem, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given auxiliary read-only array of eTs. the array is copied.  <a href="a00975.html#ga0ab642c6dc44b0b2f09dd5c2045d7071"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga029ee5fd254cd7829ea033a75622d37d">operator=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the matrix to be equal to the specified scalar. NOTE: the size of the matrix will be 1x1.  <a href="a00975.html#ga029ee5fd254cd7829ea033a75622d37d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gafd3c0fff0616fbef5094f8a1eaf78bea">operator+=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place addition of a scalar to all elements of the matrix.  <a href="a00975.html#gafd3c0fff0616fbef5094f8a1eaf78bea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga26320df042acc259335164ca00f11407">operator-=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place subtraction of a scalar from all elements of the matrix.  <a href="a00975.html#ga26320df042acc259335164ca00f11407"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaad8308865d373b5dbcc5517fd73ef4ba">operator*=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place multiplication of all elements of the matrix with a scalar.  <a href="a00975.html#gaad8308865d373b5dbcc5517fd73ef4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga3ffd336aafb355efd5a8ef6076d10d74">operator/=</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In-place division of all elements of the matrix with a scalar.  <a href="a00975.html#ga3ffd336aafb355efd5a8ef6076d10d74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga824d20ed95764e288d00ec70f3efd23f">Mat</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00975.html#ga824d20ed95764e288d00ec70f3efd23f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga37163b5ece683f63c7e0c0fcf9f089fe">operator=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00975.html#ga37163b5ece683f63c7e0c0fcf9f089fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga2cdc8ab31ab8112f8598d2aa23485f65">operator+=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition  <a href="a00975.html#ga2cdc8ab31ab8112f8598d2aa23485f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga674700f7c76ea0fafbd0812cdcfba0ff">operator-=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction  <a href="a00975.html#ga674700f7c76ea0fafbd0812cdcfba0ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga02175c61f90586cbb998d5ae62e3d81e">operator*=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication  <a href="a00975.html#ga02175c61f90586cbb998d5ae62e3d81e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga5b8b28c6064027ba31b0b46fc3966dc3">operator%=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix multiplication  <a href="a00975.html#ga5b8b28c6064027ba31b0b46fc3966dc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga1205480b81872f46694b7352b8c08539">operator/=</a> (const <a class="el" href="a00389.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division  <a href="a00975.html#ga1205480b81872f46694b7352b8c08539"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga0688744b9c1bb22395353af1180df2a7">Mat</a> (const <a class="el" href="a00103.html">Base</a>&lt; <a class="el" href="a00389.html#a0fc14012052d730de3388eaac02e540d">pod_type</a>, T1 &gt; &amp;A, const <a class="el" href="a00103.html">Base</a>&lt; <a class="el" href="a00389.html#a0fc14012052d730de3388eaac02e540d">pod_type</a>, T2 &gt; &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">for constructing a complex matrix out of two non-complex matrices  <a href="a00975.html#ga0688744b9c1bb22395353af1180df2a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaa7536044eb0982fb537008d4e170e92a">Mat</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (e.g. construct a matrix from a delayed submatrix operation)  <a href="a00975.html#gaa7536044eb0982fb537008d4e170e92a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga842026269a093a0cdc6241c557ea4062">operator=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (e.g. construct a matrix from a delayed submatrix operation)  <a href="a00975.html#ga842026269a093a0cdc6241c557ea4062"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga67e01e0e65c8913215930b55578c8e12">operator+=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a submatrix on the right-hand-side)  <a href="a00975.html#ga67e01e0e65c8913215930b55578c8e12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6d87684c219899d2ec4ff940db83ae87">operator-=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a submatrix on the right-hand-side)  <a href="a00975.html#ga6d87684c219899d2ec4ff940db83ae87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga9ec63518d1ca07f49eb874dd0e655805">operator*=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00975.html#ga9ec63518d1ca07f49eb874dd0e655805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gae91414c6103d9f0a9632170a6eeac1e3">operator%=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00975.html#gae91414c6103d9f0a9632170a6eeac1e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gab593128f6f762f345871c7c1c07a45df">operator/=</a> (const <a class="el" href="a00590.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a submatrix on the right-hand-side)  <a href="a00975.html#gab593128f6f762f345871c7c1c07a45df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaed510503c0a577bce94c037ab698e5fe">Mat</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a <a class="el" href="a00592.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance  <a href="a00975.html#gaed510503c0a577bce94c037ab698e5fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6507409953ec3e6f336086282074b9c6">operator=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a <a class="el" href="a00592.html" title="Class for storing data required to construct or apply operations to a subcube (i...">subview_cube</a> instance  <a href="a00975.html#ga6507409953ec3e6f336086282074b9c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac6112a83b4ceed466c33fff1eda50842">operator+=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a single-slice subcube on the right-hand-side)  <a href="a00975.html#gac6112a83b4ceed466c33fff1eda50842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga9ddd3c6be1330c870f54c527a03b0101">operator-=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a single-slice subcube on the right-hand-side)  <a href="a00975.html#ga9ddd3c6be1330c870f54c527a03b0101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga58d436053dd07591edb9dad539988ed5">operator*=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a single-slice subcube on the right-hand-side)  <a href="a00975.html#ga58d436053dd07591edb9dad539988ed5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga4e277b4f0cd936dcbfe9c7bcc4ba0bc4">operator%=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a single-slice subcube on the right-hand-side)  <a href="a00975.html#ga4e277b4f0cd936dcbfe9c7bcc4ba0bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga7043bbf21a6e45a3f3a2f842ab5b262f">operator/=</a> (const <a class="el" href="a00592.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a single-slice subcube on the right-hand-side)  <a href="a00975.html#ga7043bbf21a6e45a3f3a2f842ab5b262f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga7b1d9112781e7432ce4a897a39b3d7bd">Mat</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (e.g. construct a matrix from a delayed diag operation)  <a href="a00975.html#ga7b1d9112781e7432ce4a897a39b3d7bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga59a2458fe1b064aafade061f51772196">operator=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (e.g. construct a matrix from a delayed diag operation)  <a href="a00975.html#ga59a2458fe1b064aafade061f51772196"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga5136977ee4bdf5445a260cbcaa619ea3">operator+=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition (using a <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00975.html#ga5136977ee4bdf5445a260cbcaa619ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga0d0812bd9eef6facd7dd2135a3138432">operator-=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction (using a <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00975.html#ga0d0812bd9eef6facd7dd2135a3138432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabc62b37b158967b7fd24e4139e412184">operator*=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00975.html#gabc62b37b158967b7fd24e4139e412184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga7e9686e94a6f5907606eec81da3a9f4b">operator%=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix mutiplication (using a <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00975.html#ga7e9686e94a6f5907606eec81da3a9f4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga119374661fa15e69e9bde297e8e72cc2">operator/=</a> (const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place element-wise matrix division (using a <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00975.html#ga119374661fa15e69e9bde297e8e72cc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00594.html">subview_row</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6c635601a53805f94ae700cd3f5e1ee2">row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00975.html#ga6c635601a53805f94ae700cd3f5e1ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00594.html">subview_row</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga8d8c592f5a4d25f1e49e4eb606966787">row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00975.html#ga8d8c592f5a4d25f1e49e4eb606966787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00591.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga2375909127f177e73b26b9f64db8e371">col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (column vector)  <a href="a00975.html#ga2375909127f177e73b26b9f64db8e371"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00591.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga472c837fe6f0fcf4abf17bc4f4f9dfe0">col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (column vector)  <a href="a00975.html#ga472c837fe6f0fcf4abf17bc4f4f9dfe0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga8d1124a9e4dca72171f1eb33a5fbc0eb">rows</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00975.html#ga8d1124a9e4dca72171f1eb33a5fbc0eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga09b4d721feee58f88c6baf951d8d42c5">rows</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00975.html#ga09b4d721feee58f88c6baf951d8d42c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga7041aca9876cdd664656e1d9c0b66ed4">cols</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified column vectors)  <a href="a00975.html#ga7041aca9876cdd664656e1d9c0b66ed4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga5986cc7d055bc9811bc800586659c4a8">cols</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified column vectors)  <a href="a00975.html#ga5986cc7d055bc9811bc800586659c4a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6cbc37f46d31a6e5e75ae82a90f6015f">submat</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix)  <a href="a00975.html#ga6cbc37f46d31a6e5e75ae82a90f6015f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00590.html">subview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga61cfe2cb1b1315b5feaffcadda98ad7f">submat</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00590.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (generic submatrix)  <a href="a00975.html#ga61cfe2cb1b1315b5feaffcadda98ad7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00135.html">diagview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga5c33674c27dc9663c3a76b8c81584a1d">diag</a> (const <a class="el" href="a01037.html#ga584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a> in_id=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (diagonal)  <a href="a00975.html#ga5c33674c27dc9663c3a76b8c81584a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00135.html">diagview</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga2def58167305ce98f896e4918fc313dc">diag</a> (const <a class="el" href="a01037.html#ga584ab8b1fe53a7874ffa10b1f0c54ef4">s32</a> in_id=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00135.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> (diagonal)  <a href="a00975.html#ga2def58167305ce98f896e4918fc313dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga40b14d5a36c66f84e8fd918f36740d55">swap_rows</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6df2b2946f4b96e3354b1c3ca8ce7730">swap_cols</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col1, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gad0595e26094a2412ef2ae9c1e0320938">Mat</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00395.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed unary operations  <a href="a00975.html#gad0595e26094a2412ef2ae9c1e0320938"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gaa4674cf1bc952d6fd307eba92cd54d36">operator=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00395.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed unary operations  <a href="a00975.html#gaa4674cf1bc952d6fd307eba92cd54d36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga6e73bbf147bc1f6fca939959e54fb321">operator+=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operand having delayed operations  <a href="a00975.html#ga6e73bbf147bc1f6fca939959e54fb321"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gade9eaff44df34271b77b157e9b1fe61d">operator-=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operand having delayed operations  <a href="a00975.html#gade9eaff44df34271b77b157e9b1fe61d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gaae498ac76bf2d9e5d232c0846d464117">operator*=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication, with the right-hand-side operand having delayed operations  <a href="a00975.html#gaae498ac76bf2d9e5d232c0846d464117"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gae9d43b30d8e22aab1f97752cb321a3fc">operator%=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise multiplication, with the right-hand-side operand having delayed operations  <a href="a00975.html#gae9d43b30d8e22aab1f97752cb321a3fc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga0b39e2617954b5f82f1a32cf6a471a8f">operator/=</a> (const <a class="el" href="a00395.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise division, with the right-hand-side operand having delayed operations  <a href="a00975.html#ga0b39e2617954b5f82f1a32cf6a471a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gae99d9ac3f97013476c37729d94021340">Mat</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00149.html">eOp</a>, i.e. run the previously delayed unary operations  <a href="a00975.html#gae99d9ac3f97013476c37729d94021340"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga09b6f9282ef02a155f00011908f635cb">operator=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00149.html">eOp</a>, i.e. run the previously delayed unary operations  <a href="a00975.html#ga09b6f9282ef02a155f00011908f635cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga1057038bcb2fb117cc73dd783366897b">operator+=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga9489dd95254a980f632025c67daeb8b3">operator-=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gaa1b03e3bb8fa10df5c3283d49994b7d0">operator*=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga73fee4211d5de4f24781abbf623007d8">operator%=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gac9d906a34cf66b86ad16e708db5b3a38">operator/=</a> (const <a class="el" href="a00149.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gaa52a77dc05025129fe57f19689127544">Mat</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#gaa52a77dc05025129fe57f19689127544"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga6601036b27c87f73b36156fc18d885be">operator=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#ga6601036b27c87f73b36156fc18d885be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga7d95dacff3a24c5e5b50d20d4e1dbb01">operator+=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#ga7d95dacff3a24c5e5b50d20d4e1dbb01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gacea6a67cd895170e0274605aecd12ac5">operator-=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#gacea6a67cd895170e0274605aecd12ac5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga2d07327bea2eaac763483a43c4e1d1c9">operator*=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#ga2d07327bea2eaac763483a43c4e1d1c9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga7ceb93f2bae0bd01f559276d9c501eea">operator%=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#ga7ceb93f2bae0bd01f559276d9c501eea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gadb48106c56db2e6dc3b2a23c07620920">operator/=</a> (const <a class="el" href="a00394.html">mtOp</a>&lt; eT, T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL.  <a href="a00975.html#gadb48106c56db2e6dc3b2a23c07620920"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga913949ff41cc0ba91bf6324a77b799cd">Mat</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00247.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="a00975.html#ga913949ff41cc0ba91bf6324a77b799cd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga22e1b9221c9531127d605429a219aae3">operator=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00247.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations  <a href="a00975.html#ga22e1b9221c9531127d605429a219aae3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga3cb518b25b04ebcab72980bda08ebe26">operator+=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operands having delayed operations  <a href="a00975.html#ga3cb518b25b04ebcab72980bda08ebe26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga77eb50589187818454ff0abf0bd3dd00">operator-=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operands having delayed operations  <a href="a00975.html#ga77eb50589187818454ff0abf0bd3dd00"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gac3bc7f2c61b515b4485365003b160e9e">operator*=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplications, with the right-hand-side operands having delayed operations  <a href="a00975.html#gac3bc7f2c61b515b4485365003b160e9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga413568f6312ac864c0ef38a8bc409049">operator%=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise multiplication, with the right-hand-side operands having delayed operations  <a href="a00975.html#ga413568f6312ac864c0ef38a8bc409049"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gac86865b344d26aabc7a6a2724dab1fda">operator/=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix element-wise division, with the right-hand-side operands having delayed operations  <a href="a00975.html#gac86865b344d26aabc7a6a2724dab1fda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga33828260303b98a795d34aa0ade8d795">operator+=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, <a class="el" href="a00266.html">glue_times</a> &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga4bd6acf3ae88cea11768642d2fc56310">operator-=</a> (const <a class="el" href="a00247.html">Glue</a>&lt; T1, T2, <a class="el" href="a00266.html">glue_times</a> &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga584f8411678e16a77d1d28ae36e6d255">Mat</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00137.html">eGlue</a>, i.e. run the previously delayed binary operations  <a href="a00975.html#ga584f8411678e16a77d1d28ae36e6d255"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga1cc990fef2077df856e899627579d309">operator=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00137.html">eGlue</a>, i.e. run the previously delayed binary operations  <a href="a00975.html#ga1cc990fef2077df856e899627579d309"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga61e59cf226662843699ea406ee2eca24">operator+=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix addition, with the right-hand-side operands having delayed operations  <a href="a00975.html#ga61e59cf226662843699ea406ee2eca24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gac3b983205d8aa844f2b7b203f251a7d7">operator-=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix subtraction, with the right-hand-side operands having delayed operations  <a href="a00975.html#gac3b983205d8aa844f2b7b203f251a7d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gae574830dbdd434614e87ba1b6abe8f1c">operator*=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga58ca136e17b604726d52e98d5f1ce32c">operator%=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga08c11d17c142a9ca4fd79a97316a8b92">operator/=</a> (const <a class="el" href="a00137.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga4e6e131df9becd81686b99426e234e20">Mat</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: create a matrix from <a class="el" href="a00393.html">mtGlue</a>, i.e. run the previously delayed binary operations.  <a href="a00975.html#ga4e6e131df9becd81686b99426e234e20"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga3759b7a68c38055a8ac18106fc2c5cca">operator=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: create a matrix from <a class="el" href="a00247.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed binary operations.  <a href="a00975.html#ga3759b7a68c38055a8ac18106fc2c5cca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga485e95f9f9e3ecf7c08d16abb43102e5">operator+=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: in-place matrix addition, with the right-hand-side operands having delayed operations.  <a href="a00975.html#ga485e95f9f9e3ecf7c08d16abb43102e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga7ae0cb0ba9531635958f4a8fb142f9e4">operator-=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: in-place matrix subtraction, with the right-hand-side operands having delayed operations.  <a href="a00975.html#ga7ae0cb0ba9531635958f4a8fb142f9e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gab33e4f8f5ca6f2d5e9d59d6aea31b580">operator*=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: in-place matrix multiplications, with the right-hand-side operands having delayed operations.  <a href="a00975.html#gab33e4f8f5ca6f2d5e9d59d6aea31b580"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga18f3b370256c67ce635f640683a6c93f">operator%=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: in-place matrix element-wise multiplication, with the right-hand-side operands having delayed operations.  <a href="a00975.html#ga18f3b370256c67ce635f640683a6c93f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#ga08f40e67e0af7ac3b789b3a469a9f244">operator/=</a> (const <a class="el" href="a00393.html">mtGlue</a>&lt; eT, T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL: in-place matrix element-wise division, with the right-hand-side operands having delayed operations.  <a href="a00975.html#ga08f40e67e0af7ac3b789b3a469a9f244"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga3965fcd6e27aab50a0f6df11243b33b5">operator[]</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); no bounds check.  <a href="a00975.html#ga3965fcd6e27aab50a0f6df11243b33b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gad6bfbf4295336cded8c896628517744a">operator[]</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); no bounds check  <a href="a00975.html#gad6bfbf4295336cded8c896628517744a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga60192672859e768daea6a66559804ec0">operator()</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00975.html#ga60192672859e768daea6a66559804ec0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaaca8a366e693604cb28b6010e6f1d937">operator()</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">linear element accessor (treats the matrix as a vector); bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00975.html#gaaca8a366e693604cb28b6010e6f1d937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6e3952e7bf8575ff6423340f4ad1807a">at</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="a00975.html#ga6e3952e7bf8575ff6423340f4ad1807a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabc8caa5c7911c7a67378fbac4e3b7be2">at</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; no bounds check  <a href="a00975.html#gabc8caa5c7911c7a67378fbac4e3b7be2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga9f0e97d99bf54549b530e0736a4cda5b">operator()</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00975.html#ga9f0e97d99bf54549b530e0736a4cda5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaadce1499d9a184f1b526f77d1fea615e">operator()</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">element accessor; bounds checking not done when ARMA_NO_DEBUG is defined  <a href="a00975.html#gaadce1499d9a184f1b526f77d1fea615e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaac0f36b3cedf7f6be113582b6edc0fd0">operator++</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix ++  <a href="a00975.html#gaac0f36b3cedf7f6be113582b6edc0fd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabdf95868404d49f468e4cbd03b80e306">operator++</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix ++ (must not return the object by reference)  <a href="a00975.html#gabdf95868404d49f468e4cbd03b80e306"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00389.html">Mat</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga632e79fa65d54ad7381fde813910d987">operator--</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix --  <a href="a00975.html#ga632e79fa65d54ad7381fde813910d987"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga2e8972e43ad726b00fd4fab21ecef9ae">operator--</a> (int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">postfix -- (must not return the object by reference)  <a href="a00975.html#ga2e8972e43ad726b00fd4fab21ecef9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga588483a35cd5e45a01390aab33c7b16b">is_vec</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the object can be interpreted as a column or row vector  <a href="a00975.html#ga588483a35cd5e45a01390aab33c7b16b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaebcde5b059098f2ee43b9ae0a3d3f0b7">is_square</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the object has the same number of non-zero rows and columnns  <a href="a00975.html#gaebcde5b059098f2ee43b9ae0a3d3f0b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga31b2e5a2a3e150cc856642befd83db6a">is_finite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if all of the elements are finite  <a href="a00975.html#ga31b2e5a2a3e150cc856642befd83db6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga9355267e66e1ce202e16b2bc9e486585">colptr</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs for a specified column; no bounds check  <a href="a00975.html#ga9355267e66e1ce202e16b2bc9e486585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga28ff003069bef699eefb649fa2dcdc72">colptr</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs for a specified column; no bounds check  <a href="a00975.html#ga28ff003069bef699eefb649fa2dcdc72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga78bb1eef0619bccb2a13f3dfafee19bf">memptr</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the matrix  <a href="a00975.html#ga78bb1eef0619bccb2a13f3dfafee19bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const eT *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaf5686825798075886487c0223f5821cb">memptr</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to array of eTs used by the matrix  <a href="a00975.html#gaf5686825798075886487c0223f5821cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabc78fefc6ab8f7cf66638978fd9030d5">print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00975.html#gabc78fefc6ab8f7cf66638978fd9030d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac9d0f7c07ef22c8c93a3a5d05b60a8e3">print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00975.html#gac9d0f7c07ef22c8c93a3a5d05b60a8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga50326854dc4f92c014e572444e7c1a5f">print_trans</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix (to the cout stream), optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00975.html#ga50326854dc4f92c014e572444e7c1a5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga9f9808eefb25ca36d9ca064c08d3f3cc">print_trans</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of matrix to a user specified stream, optionally preceding with a user specified line of text. the precision and cell width are modified. on return, the stream's flags are restored to their original values.  <a href="a00975.html#ga9f9808eefb25ca36d9ca064c08d3f3cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga6417a9fa5275b438ac42105f305bb591">raw_print</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified).  <a href="a00975.html#ga6417a9fa5275b438ac42105f305bb591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gad7b2da64f7bcfe3b8a822a0a93d5a141">raw_print</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the matrix to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified).  <a href="a00975.html#gad7b2da64f7bcfe3b8a822a0a93d5a141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gad67b361670e40b871022c20ae63605a9">raw_print_trans</a> (const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix (to the cout stream), optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified (i.e. the precision and cell width are not modified).  <a href="a00975.html#gad67b361670e40b871022c20ae63605a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga21397c90a1de6797d3fbfc3071198008">raw_print_trans</a> (std::ostream &amp;user_stream, const std::string extra_text=&quot;&quot;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print contents of the transposed version of the matrix to a user specified stream, optionally preceding with a user specified line of text. the stream's flags are used as is and are not modified. (i.e. the precision and cell width are not modified).  <a href="a00975.html#ga21397c90a1de6797d3fbfc3071198008"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00975.html#gabeed7f66dc1018fd551a6e760343dee6">copy_size</a> (const <a class="el" href="a00389.html">Mat</a>&lt; eT2 &gt; &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the matrix (without preserving data) to have the same dimensions as the given matrix  <a href="a00975.html#gabeed7f66dc1018fd551a6e760343dee6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac55ef8df37e04e1af416594dfbe25ac6">set_size</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the matrix to have user specified dimensions (data is not preserved)  <a href="a00975.html#gac55ef8df37e04e1af416594dfbe25ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_hot void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga7ef477e5c2d7baf1af31ef06dc248375">fill</a> (const eT val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fill the matrix with the specified value  <a href="a00975.html#ga7ef477e5c2d7baf1af31ef06dc248375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga58ecc7b31c7c7e5efa725afb7d0622ae">zeros</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gae32717b379f37e73ab8222c23d657910">zeros</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga8dfcb949372eef7a74ae8d7f2fc5b328">ones</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gab9e60d50d55b86b849125551d0880b61">ones</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gacc9a04c65d457da77df3dff99dd9494a">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gad29ecbcc752a7a2b2ec5c234bcec31a4">save</a> (const std::string name, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary, const bool print_status=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a file  <a href="a00975.html#gad29ecbcc752a7a2b2ec5c234bcec31a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga89a2e48d0b25a5144e82f649e69d3e00">save</a> (std::ostream &amp;os, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary, const bool print_status=true) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a stream  <a href="a00975.html#ga89a2e48d0b25a5144e82f649e69d3e00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac94864fc30968b245890537e2b2869ac">load</a> (const std::string name, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect, const bool print_status=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a file  <a href="a00975.html#gac94864fc30968b245890537e2b2869ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga2e9998ad3f8ffc4644ac2fd95af9915e">load</a> (std::istream &amp;is, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect, const bool print_status=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a stream  <a href="a00975.html#ga2e9998ad3f8ffc4644ac2fd95af9915e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gad0734046490fe7872fa23632f3233646">quiet_save</a> (const std::string name, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a file, without printing any error messages  <a href="a00975.html#gad0734046490fe7872fa23632f3233646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabf57baafff6c69ce545b38fa57ff94ec">quiet_save</a> (std::ostream &amp;os, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=arma_binary) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">save the matrix to a stream, without printing any error messages  <a href="a00975.html#gabf57baafff6c69ce545b38fa57ff94ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga194054a63594cc97fa2e02433e4c2009">quiet_load</a> (const std::string name, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a file, without printing any error messages  <a href="a00975.html#ga194054a63594cc97fa2e02433e4c2009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga69ea1a91cff25723ffdf1d9401feed97">quiet_load</a> (std::istream &amp;is, const <a class="el" href="a00890.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a stream, without printing any error messages  <a href="a00975.html#ga69ea1a91cff25723ffdf1d9401feed97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a28d8b1a8e68d6d2975dd1072f6904ee0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga5c132b37d9086d813dd6f7f0186dc2dc">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a79aaf5045e97720d8ca9b9115a5c4e77">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga05b71b67b9a286ba267ab8d44db95e38">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a28d8b1a8e68d6d2975dd1072f6904ee0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gac2781601683d71d16ed240323692aa84">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a79aaf5045e97720d8ca9b9115a5c4e77">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga98c8791121d560b752435c7a69b9311d">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a79c4fa96d87168eef289bb2682f10728">col_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gade4afefda5478570c565056e02cd10b5">begin_col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a0e62996616bbebf568309184a171b05b">const_col_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga03a58cde03ea1e3b621bef7718be74d3">begin_col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a79c4fa96d87168eef289bb2682f10728">col_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaa96d986327a74198e1208b762f395c24">end_col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html#a0e62996616bbebf568309184a171b05b">const_col_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga4dbe03b64081d858e2c258926a7fcb95">end_col</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> col_num) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00579.html">row_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaf1093db83bb96fdd5db8bc13d449f129">begin_row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00114.html">const_row_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga21b041bcbe5902a8e10247507c2bd3ed">begin_row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00579.html">row_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga767ffc5c79d1edd5b375d46dddaf11c0">end_row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00114.html">const_row_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gaf25ac8b1340e53761eea00c49b0dd8e3">end_row</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num) const </td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of rows in the matrix (read-only)  <a href="#aaa8c7e5e59361913b15ae55f714ca6c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a163bed70780a1d181594d126295d5a09">n_cols</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of columns in the matrix (read-only)  <a href="#a163bed70780a1d181594d126295d5a09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of elements in the matrix (read-only)  <a href="#ab12257afbbe6338a7af830d9b65f3305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a912b66ceb203eb071b36b9e7d456ae3b">use_aux_mem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if externally managed memory is being used (read-only)  <a href="#a912b66ceb203eb071b36b9e7d456ae3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_aligned const eT *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a14a6badc8098d810e5decb22272a07b0">mem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to the memory used by the matrix (memory is read-only)  <a href="#a14a6badc8098d810e5decb22272a07b0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga03f8a60c95132e2b3774b596fd2207c4">init</a> (const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal matrix construction; if the requested size is small enough, memory from the stack is used. otherwise memory is allocated via 'new'  <a href="a00975.html#ga03f8a60c95132e2b3774b596fd2207c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga0609204fa5e3cc7f5cdb287e80cbb024">init</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal function to create the matrix from a textual description  <a href="a00975.html#ga0609204fa5e3cc7f5cdb287e80cbb024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#gabe7e3bca86c58b8961c8eac06f289ae2">init</a> (const <a class="el" href="a00389.html">Mat</a> &amp;x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a matrix from a given matrix  <a href="a00975.html#gabe7e3bca86c58b8961c8eac06f289ae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00975.html#ga3a5c6e9b6facff2a906f90b43ac94dc8">Mat</a> (const char junk, const eT *aux_mem, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DANGEROUS! Construct a temporary matrix, using auxiliary memory. This constructor is NOT intended for usage by user code. Its sole purpose is to be used by the <a class="el" href="a00123.html" title="Dense cube class.">Cube</a> class.  <a href="a00975.html#ga3a5c6e9b6facff2a906f90b43ac94dc8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_aligned eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#aaef55ac7c591b3d6591a31c5651f2883">mem_local</a> [16]</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a5daaf3e85b382d2bab2de0e6fcff99a1">Cube&lt; eT &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html#a4cf829fc237eb8b96c401850367dcdbf">glue_join</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename eT&gt;<br/>
 class Mat&lt; eT &gt;</h3>

<p>Dense matrix class. </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00023">23</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3b7c1109cca98fb4bf493b8be33c4299"></a><!-- doxytag: member="Mat::elem_type" ref="a3b7c1109cca98fb4bf493b8be33c4299" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a3b7c1109cca98fb4bf493b8be33c4299">elem_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the type of elements stored in the matrix </p>

<p>Reimplemented in <a class="el" href="a00112.html#aa7ec170924ed5ad130545919563c7e3c">Col&lt; eT &gt;</a>, and <a class="el" href="a00578.html#aec0f589b61e71a94e416afe386602275">Row&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00759_source.html#l00027">27</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0fc14012052d730de3388eaac02e540d"></a><!-- doxytag: member="Mat::pod_type" ref="a0fc14012052d730de3388eaac02e540d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00245.html">get_pod_type</a>&lt;eT&gt;::result <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a0fc14012052d730de3388eaac02e540d">pod_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex </p>

<p>Reimplemented in <a class="el" href="a00112.html#a1584d0c1fcd5cc903a31e65af6dae26e">Col&lt; eT &gt;</a>, and <a class="el" href="a00578.html#aec4f0a287b7df7e1618c1b06f5be0c38">Row&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00759_source.html#l00028">28</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28d8b1a8e68d6d2975dd1072f6904ee0"></a><!-- doxytag: member="Mat::iterator" ref="a28d8b1a8e68d6d2975dd1072f6904ee0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT* <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a28d8b1a8e68d6d2975dd1072f6904ee0">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00242">242</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79aaf5045e97720d8ca9b9115a5c4e77"></a><!-- doxytag: member="Mat::const_iterator" ref="a79aaf5045e97720d8ca9b9115a5c4e77" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const eT* <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a79aaf5045e97720d8ca9b9115a5c4e77">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00243">243</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79c4fa96d87168eef289bb2682f10728"></a><!-- doxytag: member="Mat::col_iterator" ref="a79c4fa96d87168eef289bb2682f10728" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT* <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a79c4fa96d87168eef289bb2682f10728">col_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00245">245</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e62996616bbebf568309184a171b05b"></a><!-- doxytag: member="Mat::const_col_iterator" ref="a0e62996616bbebf568309184a171b05b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const eT* <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a0e62996616bbebf568309184a171b05b">const_col_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00246">246</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5daaf3e85b382d2bab2de0e6fcff99a1"></a><!-- doxytag: member="Mat::Cube&lt; eT &gt;" ref="a5daaf3e85b382d2bab2de0e6fcff99a1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00123.html">Cube</a>&lt; eT &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00321">321</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf829fc237eb8b96c401850367dcdbf"></a><!-- doxytag: member="Mat::glue_join" ref="a4cf829fc237eb8b96c401850367dcdbf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="a00252.html">glue_join</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00322">322</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aaa8c7e5e59361913b15ae55f714ca6c6"></a><!-- doxytag: member="Mat::n_rows" ref="aaa8c7e5e59361913b15ae55f714ca6c6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00030">30</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00824_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00822_source.html#l00060">op_trans::apply()</a>, <a class="el" href="a00820_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00818_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00816_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00814_source.html#l00027">op_shuffle::apply()</a>, <a class="el" href="a00812_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00810_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00805_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00795_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00793_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00790_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00788_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00782_source.html#l00025">op_flipud::apply()</a>, <a class="el" href="a00772_source.html#l00025">op_diagmat::apply()</a>, <a class="el" href="a00749_source.html#l00616">glue_times_diag::apply()</a>, <a class="el" href="a00749_source.html#l00372">glue_times::apply()</a>, <a class="el" href="a00747_source.html#l00025">glue_solve::apply()</a>, <a class="el" href="a00737_source.html#l00025">glue_join::apply()</a>, <a class="el" href="a00735_source.html#l00026">glue_cross::apply()</a>, <a class="el" href="a00728_source.html#l00036">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00727_source.html#l00223">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00727_source.html#l00038">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00726_source.html#l00221">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00726_source.html#l00037">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00728_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00726_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00749_source.html#l00137">glue_times::apply_inplace()</a>, <a class="el" href="a00661_source.html#l00387">eop_core&lt; eop_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00650_source.html#l00259">eglue_core&lt; eglue_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00661_source.html#l00294">eop_core&lt; eop_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00650_source.html#l00197">eglue_core&lt; eglue_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00749_source.html#l00189">glue_times::apply_inplace_plus()</a>, <a class="el" href="a00661_source.html#l00248">eop_core&lt; eop_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00650_source.html#l00166">eglue_core&lt; eglue_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00661_source.html#l00340">eop_core&lt; eop_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00650_source.html#l00228">eglue_core&lt; eglue_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00822_source.html#l00026">op_trans::apply_noalias()</a>, <a class="el" href="a00650_source.html#l00130">eglue_core&lt; eglue_type &gt;::apply_unwrap()</a>, <a class="el" href="a00644_source.html#l00571">arma_assert_mul_size()</a>, <a class="el" href="a00644_source.html#l00260">arma_assert_same_size()</a>, <a class="el" href="a00672_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00758_source.html#l02170">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00758_source.html#l03190">Mat&lt; eT &gt;::begin_row()</a>, <a class="el" href="a00631_source.html#l01084">auxlib::chol()</a>, <a class="el" href="a00758_source.html#l02279">Mat&lt; eT &gt;::colptr()</a>, <a class="el" href="a00758_source.html#l01140">Mat&lt; eT &gt;::cols()</a>, <a class="el" href="a00847_source.html#l00746">Row&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00758_source.html#l02513">Mat&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00637_source.html#l00774">Col&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00631_source.html#l00376">auxlib::det()</a>, <a class="el" href="a00758_source.html#l01216">Mat&lt; eT &gt;::diag()</a>, <a class="el" href="a00645_source.html#l00177">diagmat_proxy_check&lt; Mat&lt; eT &gt; &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00645_source.html#l00147">diagmat_proxy_check&lt; T1 &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00766_source.html#l00027">op_cor::direct_cor()</a>, <a class="el" href="a00731_source.html#l00026">glue_cor::direct_cor()</a>, <a class="el" href="a00768_source.html#l00027">op_cov::direct_cov()</a>, <a class="el" href="a00733_source.html#l00026">glue_cov::direct_cov()</a>, <a class="el" href="a00739_source.html#l00028">glue_kron::direct_kron()</a>, <a class="el" href="a00799_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00803_source.html#l00034">op_princomp::direct_princomp()</a>, <a class="el" href="a00778_source.html#l00142">op_dotext::direct_rowvec_diagmat_colvec()</a>, <a class="el" href="a00778_source.html#l00166">op_dotext::direct_rowvec_invdiagmat_colvec()</a>, <a class="el" href="a00778_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, <a class="el" href="a00778_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>, <a class="el" href="a00858_source.html#l00913">subview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00646_source.html#l00235">diagview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00631_source.html#l00913">auxlib::eig_gen()</a>, <a class="el" href="a00631_source.html#l00733">auxlib::eig_sym()</a>, <a class="el" href="a00758_source.html#l03162">Mat&lt; eT &gt;::end_col()</a>, <a class="el" href="a00758_source.html#l03218">Mat&lt; eT &gt;::end_row()</a>, <a class="el" href="a00858_source.html#l00757">subview&lt; eT &gt;::extract()</a>, <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00631_source.html#l00202">auxlib::inv_inplace()</a>, <a class="el" href="a00631_source.html#l00026">auxlib::inv_noalias()</a>, <a class="el" href="a00758_source.html#l02249">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00758_source.html#l02238">Mat&lt; eT &gt;::is_vec()</a>, <a class="el" href="a00648_source.html#l00895">diskio::load_arma_ascii()</a>, <a class="el" href="a00648_source.html#l00785">diskio::load_raw_ascii()</a>, <a class="el" href="a00631_source.html#l00523">auxlib::log_det()</a>, <a class="el" href="a00631_source.html#l00611">auxlib::lu()</a>, <a class="el" href="a00858_source.html#l00859">subview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00646_source.html#l00183">diagview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00749_source.html#l00357">glue_times::mul_storage_cost()</a>, <a class="el" href="a00758_source.html#l02146">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00858_source.html#l00832">subview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00646_source.html#l00157">diagview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00624_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00631_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00758_source.html#l01042">Mat&lt; eT &gt;::row()</a>, <a class="el" href="a00758_source.html#l01102">Mat&lt; eT &gt;::rows()</a>, <a class="el" href="a00648_source.html#l00555">diskio::save_arma_ascii()</a>, <a class="el" href="a00648_source.html#l00639">diskio::save_arma_binary()</a>, <a class="el" href="a00648_source.html#l00694">diskio::save_pgm_binary()</a>, <a class="el" href="a00648_source.html#l02463">diskio::save_ppm_binary()</a>, <a class="el" href="a00648_source.html#l00480">diskio::save_raw_ascii()</a>, <a class="el" href="a00858_source.html#l00886">subview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00646_source.html#l00209">diagview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00631_source.html#l01550">auxlib::solve()</a>, <a class="el" href="a00631_source.html#l01587">auxlib::solve_od()</a>, <a class="el" href="a00631_source.html#l01651">auxlib::solve_ud()</a>, <a class="el" href="a00758_source.html#l01178">Mat&lt; eT &gt;::submat()</a>, <a class="el" href="a00631_source.html#l01220">auxlib::svd()</a>, <a class="el" href="a00758_source.html#l01292">Mat&lt; eT &gt;::swap_cols()</a>, <a class="el" href="a00758_source.html#l01264">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00717_source.html#l00079">trace()</a>, <a class="el" href="a00851_source.html#l00310">running_stat_vec_aux::update_stats()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a163bed70780a1d181594d126295d5a09"></a><!-- doxytag: member="Mat::n_cols" ref="a163bed70780a1d181594d126295d5a09" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a163bed70780a1d181594d126295d5a09">n_cols</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00031">31</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00824_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00822_source.html#l00060">op_trans::apply()</a>, <a class="el" href="a00820_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00818_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00816_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00814_source.html#l00027">op_shuffle::apply()</a>, <a class="el" href="a00812_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00810_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00805_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00795_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00793_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00790_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00788_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00782_source.html#l00059">op_fliplr::apply()</a>, <a class="el" href="a00749_source.html#l00616">glue_times_diag::apply()</a>, <a class="el" href="a00749_source.html#l00372">glue_times::apply()</a>, <a class="el" href="a00747_source.html#l00025">glue_solve::apply()</a>, <a class="el" href="a00742_source.html#l00026">glue_mixed_times::apply()</a>, <a class="el" href="a00737_source.html#l00025">glue_join::apply()</a>, <a class="el" href="a00735_source.html#l00026">glue_cross::apply()</a>, <a class="el" href="a00729_source.html#l00026">glue_conv::apply()</a>, <a class="el" href="a00728_source.html#l00036">gemv_arma&lt; do_trans_A, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00727_source.html#l00223">gemm_mixed_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00727_source.html#l00038">gemm_mixed_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00726_source.html#l00221">gemm_emul_simple&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00726_source.html#l00037">gemm_emul_cache&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00728_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00726_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00749_source.html#l00137">glue_times::apply_inplace()</a>, <a class="el" href="a00661_source.html#l00387">eop_core&lt; eop_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00650_source.html#l00259">eglue_core&lt; eglue_type &gt;::apply_inplace_div()</a>, <a class="el" href="a00661_source.html#l00294">eop_core&lt; eop_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00650_source.html#l00197">eglue_core&lt; eglue_type &gt;::apply_inplace_minus()</a>, <a class="el" href="a00749_source.html#l00189">glue_times::apply_inplace_plus()</a>, <a class="el" href="a00661_source.html#l00248">eop_core&lt; eop_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00650_source.html#l00166">eglue_core&lt; eglue_type &gt;::apply_inplace_plus()</a>, <a class="el" href="a00661_source.html#l00340">eop_core&lt; eop_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00650_source.html#l00228">eglue_core&lt; eglue_type &gt;::apply_inplace_schur()</a>, <a class="el" href="a00822_source.html#l00026">op_trans::apply_noalias()</a>, <a class="el" href="a00650_source.html#l00130">eglue_core&lt; eglue_type &gt;::apply_unwrap()</a>, <a class="el" href="a00644_source.html#l00571">arma_assert_mul_size()</a>, <a class="el" href="a00644_source.html#l00260">arma_assert_same_size()</a>, <a class="el" href="a00672_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00758_source.html#l03134">Mat&lt; eT &gt;::begin_col()</a>, <a class="el" href="a00758_source.html#l01072">Mat&lt; eT &gt;::col()</a>, <a class="el" href="a00758_source.html#l01140">Mat&lt; eT &gt;::cols()</a>, <a class="el" href="a00847_source.html#l00746">Row&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00758_source.html#l02513">Mat&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00637_source.html#l00774">Col&lt; eT &gt;::copy_size()</a>, <a class="el" href="a00631_source.html#l00376">auxlib::det()</a>, <a class="el" href="a00758_source.html#l01216">Mat&lt; eT &gt;::diag()</a>, <a class="el" href="a00645_source.html#l00177">diagmat_proxy_check&lt; Mat&lt; eT &gt; &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00645_source.html#l00147">diagmat_proxy_check&lt; T1 &gt;::diagmat_proxy_check()</a>, <a class="el" href="a00739_source.html#l00028">glue_kron::direct_kron()</a>, <a class="el" href="a00799_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00803_source.html#l00034">op_princomp::direct_princomp()</a>, <a class="el" href="a00778_source.html#l00026">op_dotext::direct_rowvec_mat_colvec()</a>, <a class="el" href="a00778_source.html#l00083">op_dotext::direct_rowvec_transmat_colvec()</a>, <a class="el" href="a00858_source.html#l00913">subview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00646_source.html#l00235">diagview&lt; eT &gt;::div_inplace()</a>, <a class="el" href="a00631_source.html#l00913">auxlib::eig_gen()</a>, <a class="el" href="a00631_source.html#l00733">auxlib::eig_sym()</a>, <a class="el" href="a00758_source.html#l03162">Mat&lt; eT &gt;::end_col()</a>, <a class="el" href="a00858_source.html#l00757">subview&lt; eT &gt;::extract()</a>, <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00631_source.html#l00202">auxlib::inv_inplace()</a>, <a class="el" href="a00631_source.html#l00026">auxlib::inv_noalias()</a>, <a class="el" href="a00758_source.html#l02249">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00758_source.html#l02238">Mat&lt; eT &gt;::is_vec()</a>, <a class="el" href="a00648_source.html#l00895">diskio::load_arma_ascii()</a>, <a class="el" href="a00648_source.html#l00785">diskio::load_raw_ascii()</a>, <a class="el" href="a00631_source.html#l00523">auxlib::log_det()</a>, <a class="el" href="a00631_source.html#l00611">auxlib::lu()</a>, <a class="el" href="a00758_source.html#l00693">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00858_source.html#l00859">subview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00646_source.html#l00183">diagview&lt; eT &gt;::minus_inplace()</a>, <a class="el" href="a00749_source.html#l00357">glue_times::mul_storage_cost()</a>, <a class="el" href="a00758_source.html#l02146">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00858_source.html#l00832">subview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00646_source.html#l00157">diagview&lt; eT &gt;::plus_inplace()</a>, <a class="el" href="a00624_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00631_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00758_source.html#l01102">Mat&lt; eT &gt;::rows()</a>, <a class="el" href="a00648_source.html#l00555">diskio::save_arma_ascii()</a>, <a class="el" href="a00648_source.html#l00639">diskio::save_arma_binary()</a>, <a class="el" href="a00648_source.html#l00694">diskio::save_pgm_binary()</a>, <a class="el" href="a00648_source.html#l02463">diskio::save_ppm_binary()</a>, <a class="el" href="a00648_source.html#l00480">diskio::save_raw_ascii()</a>, <a class="el" href="a00858_source.html#l00886">subview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00646_source.html#l00209">diagview&lt; eT &gt;::schur_inplace()</a>, <a class="el" href="a00631_source.html#l01550">auxlib::solve()</a>, <a class="el" href="a00631_source.html#l01587">auxlib::solve_od()</a>, <a class="el" href="a00631_source.html#l01651">auxlib::solve_ud()</a>, <a class="el" href="a00758_source.html#l01178">Mat&lt; eT &gt;::submat()</a>, <a class="el" href="a00631_source.html#l01220">auxlib::svd()</a>, <a class="el" href="a00758_source.html#l01292">Mat&lt; eT &gt;::swap_cols()</a>, <a class="el" href="a00758_source.html#l01264">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00717_source.html#l00079">trace()</a>, <a class="el" href="a00851_source.html#l00310">running_stat_vec_aux::update_stats()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="ab12257afbbe6338a7af830d9b65f3305"></a><!-- doxytag: member="Mat::n_elem" ref="ab12257afbbe6338a7af830d9b65f3305" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01037.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of elements in the matrix (read-only) </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00032">32</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00824_source.html#l00166">op_var::apply()</a>, <a class="el" href="a00822_source.html#l00161">op_trans2::apply()</a>, <a class="el" href="a00820_source.html#l00027">op_sum::apply()</a>, <a class="el" href="a00818_source.html#l00028">op_stddev::apply()</a>, <a class="el" href="a00816_source.html#l00169">op_sort::apply()</a>, <a class="el" href="a00812_source.html#l00026">op_reshape::apply()</a>, <a class="el" href="a00810_source.html#l00029">op_repmat::apply()</a>, <a class="el" href="a00805_source.html#l00027">op_prod::apply()</a>, <a class="el" href="a00795_source.html#l00101">op_min::apply()</a>, <a class="el" href="a00793_source.html#l00105">op_median::apply()</a>, <a class="el" href="a00790_source.html#l00088">op_mean::apply()</a>, <a class="el" href="a00788_source.html#l00103">op_max::apply()</a>, <a class="el" href="a00772_source.html#l00025">op_diagmat::apply()</a>, <a class="el" href="a00751_source.html#l00026">glue_toeplitz::apply()</a>, <a class="el" href="a00737_source.html#l00025">glue_join::apply()</a>, <a class="el" href="a00735_source.html#l00026">glue_cross::apply()</a>, <a class="el" href="a00729_source.html#l00026">glue_conv::apply()</a>, <a class="el" href="a00727_source.html#l00417">gemm_mixed&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00726_source.html#l00494">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00052">as_scalar_redirect&lt; N &gt;::apply()</a>, <a class="el" href="a00728_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00726_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00822_source.html#l00026">op_trans::apply_noalias()</a>, <a class="el" href="a00776_source.html#l00250">op_norm_dot::apply_unwrap()</a>, <a class="el" href="a00776_source.html#l00175">op_dot::apply_unwrap()</a>, <a class="el" href="a00650_source.html#l00130">eglue_core&lt; eglue_type &gt;::apply_unwrap()</a>, <a class="el" href="a00672_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00673_source.html#l00037">chol()</a>, <a class="el" href="a00731_source.html#l00026">glue_cor::direct_cor()</a>, <a class="el" href="a00733_source.html#l00026">glue_cov::direct_cov()</a>, <a class="el" href="a00799_source.html#l00027">op_pinv::direct_pinv()</a>, <a class="el" href="a00803_source.html#l00308">op_princomp::direct_princomp()</a>, <a class="el" href="a00778_source.html#l00190">op_dotext::direct_rowvec_invdiagvec_colvec()</a>, <a class="el" href="a00758_source.html#l03110">Mat&lt; eT &gt;::end()</a>, <a class="el" href="a00758_source.html#l02527">Mat&lt; eT &gt;::fill()</a>, <a class="el" href="a00675_source.html#l00604">conv_to&lt; Col&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00675_source.html#l00385">conv_to&lt; Row&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00675_source.html#l00176">conv_to&lt; Mat&lt; out_eT &gt; &gt;::from()</a>, <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00758_source.html#l02260">Mat&lt; eT &gt;::is_finite()</a>, <a class="el" href="a00758_source.html#l02249">Mat&lt; eT &gt;::is_square()</a>, <a class="el" href="a00648_source.html#l00962">diskio::load_arma_binary()</a>, <a class="el" href="a00648_source.html#l01048">diskio::load_pgm_binary()</a>, <a class="el" href="a00648_source.html#l02117">diskio::load_ppm_binary()</a>, <a class="el" href="a00758_source.html#l00486">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00692_source.html#l00045">max()</a>, <a class="el" href="a00693_source.html#l00039">mean()</a>, <a class="el" href="a00694_source.html#l00037">median()</a>, <a class="el" href="a00695_source.html#l00044">min()</a>, <a class="el" href="a00758_source.html#l00626">Mat&lt; eT &gt;::operator%=()</a>, <a class="el" href="a00758_source.html#l02101">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00758_source.html#l00376">Mat&lt; eT &gt;::operator*=()</a>, <a class="el" href="a00758_source.html#l00318">Mat&lt; eT &gt;::operator+=()</a>, <a class="el" href="a00758_source.html#l00347">Mat&lt; eT &gt;::operator-=()</a>, <a class="el" href="a00758_source.html#l00405">Mat&lt; eT &gt;::operator/=()</a>, <a class="el" href="a00758_source.html#l03355">Mat_aux::postfix_mm()</a>, <a class="el" href="a00758_source.html#l03283">Mat_aux::postfix_pp()</a>, <a class="el" href="a00758_source.html#l03319">Mat_aux::prefix_mm()</a>, <a class="el" href="a00758_source.html#l03247">Mat_aux::prefix_pp()</a>, <a class="el" href="a00624_source.html#l00198">arma_ostream::print()</a>, <a class="el" href="a00702_source.html#l00046">prod()</a>, <a class="el" href="a00631_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00706_source.html#l00028">rank()</a>, <a class="el" href="a00648_source.html#l00639">diskio::save_arma_binary()</a>, <a class="el" href="a00648_source.html#l00694">diskio::save_pgm_binary()</a>, <a class="el" href="a00648_source.html#l02253">diskio::save_ppm_binary()</a>, <a class="el" href="a00710_source.html#l00051">solve()</a>, <a class="el" href="a00713_source.html#l00049">stddev()</a>, <a class="el" href="a00851_source.html#l00310">running_stat_vec_aux::update_stats()</a>, <a class="el" href="a00722_source.html#l00049">var()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a912b66ceb203eb071b36b9e7d456ae3b"></a><!-- doxytag: member="Mat::use_aux_mem" ref="a912b66ceb203eb071b36b9e7d456ae3b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const bool <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a912b66ceb203eb071b36b9e7d456ae3b">use_aux_mem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>true if externally managed memory is being used (read-only) </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00033">33</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="a14a6badc8098d810e5decb22272a07b0"></a><!-- doxytag: member="Mat::mem" ref="a14a6badc8098d810e5decb22272a07b0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_aligned const eT* const <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#a14a6badc8098d810e5decb22272a07b0">mem</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the memory used by the matrix (memory is read-only) </p>

<p>Definition at line <a class="el" href="a00759_source.html#l00035">35</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00737_source.html#l00025">glue_join::apply()</a>, <a class="el" href="a00672_source.html#l00104">as_scalar_redirect&lt; 3 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00071">as_scalar_redirect&lt; 2 &gt;::apply()</a>, <a class="el" href="a00672_source.html#l00052">as_scalar_redirect&lt; N &gt;::apply()</a>, <a class="el" href="a00728_source.html#l00131">gemv&lt; do_trans_A, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00726_source.html#l00409">gemm&lt; do_trans_A, do_trans_B, use_alpha, use_beta &gt;::apply_blas_type()</a>, <a class="el" href="a00822_source.html#l00026">op_trans::apply_noalias()</a>, <a class="el" href="a00776_source.html#l00175">op_dot::apply_unwrap()</a>, <a class="el" href="a00672_source.html#l00260">as_scalar_diag()</a>, <a class="el" href="a00758_source.html#l02170">Mat&lt; eT &gt;::at()</a>, <a class="el" href="a00758_source.html#l02279">Mat&lt; eT &gt;::colptr()</a>, <a class="el" href="a00778_source.html#l00190">op_dotext::direct_rowvec_invdiagvec_colvec()</a>, <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, <a class="el" href="a00758_source.html#l02260">Mat&lt; eT &gt;::is_finite()</a>, <a class="el" href="a00758_source.html#l00693">Mat&lt; eT &gt;::Mat()</a>, <a class="el" href="a00692_source.html#l00045">max()</a>, <a class="el" href="a00693_source.html#l00039">mean()</a>, <a class="el" href="a00694_source.html#l00037">median()</a>, <a class="el" href="a00758_source.html#l02301">Mat&lt; eT &gt;::memptr()</a>, <a class="el" href="a00695_source.html#l00044">min()</a>, <a class="el" href="a00758_source.html#l02101">Mat&lt; eT &gt;::operator()()</a>, <a class="el" href="a00758_source.html#l00303">Mat&lt; eT &gt;::operator=()</a>, <a class="el" href="a00758_source.html#l02124">Mat&lt; eT &gt;::operator[]()</a>, <a class="el" href="a00631_source.html#l01122">auxlib::qr()</a>, <a class="el" href="a00648_source.html#l00639">diskio::save_arma_binary()</a>, <a class="el" href="a00713_source.html#l00049">stddev()</a>, <a class="el" href="a00758_source.html#l01264">Mat&lt; eT &gt;::swap_rows()</a>, <a class="el" href="a00722_source.html#l00049">var()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
<a class="anchor" id="aaef55ac7c591b3d6591a31c5651f2883"></a><!-- doxytag: member="Mat::mem_local" ref="aaef55ac7c591b3d6591a31c5651f2883" args="[16]" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arma_aligned eT <a class="el" href="a00389.html">Mat</a>&lt; eT &gt;::<a class="el" href="a00389.html#aaef55ac7c591b3d6591a31c5651f2883">mem_local</a>[16]<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00759_source.html#l00038">38</a> of file <a class="el" href="a00759_source.html">Mat_proto.hpp</a>.</p>

<p>Referenced by <a class="el" href="a00737_source.html#l00025">glue_join::apply()</a>, <a class="el" href="a00758_source.html#l00085">Mat&lt; eT &gt;::init()</a>, and <a class="el" href="a00758_source.html#l00023">Mat&lt; eT &gt;::~Mat()</a>.</p>

</div>
</div>
</div>
</BODY>
</HTML>
