<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Armadillo Technical: Col&lt; eT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Col&lt; eT &gt; Class Template Reference<br/>
<small>
[<a class="el" href="a00735.html">Col</a>]</small>
</h1><!-- doxytag: class="Col" --><!-- doxytag: inherits="Mat,BaseVec&lt; eT, Col&lt; eT &gt; &gt;" -->
<p>Class for column vectors (matrices with only column).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00520_source.html">Col_proto.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Col&lt; eT &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="a00058.gif" usemap="#Col&lt; eT &gt;_map" alt=""/>
  <map id="Col&lt; eT &gt;_map" name="Col&lt; eT &gt;_map">
<area href="a00305.html" alt="Mat&lt; eT &gt;" shape="rect" coords="0,56,167,80"/>
<area href="a00056.html" alt="BaseVec&lt; eT, Col&lt; eT &gt; &gt;" shape="rect" coords="177,56,344,80"/>
<area href="a00054.html" alt="Base&lt; eT, Mat&lt; eT &gt; &gt;" shape="rect" coords="0,0,167,24"/>
</map>
 </div>
</div>

<p><a href="a00926.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html#aa7ec170924ed5ad130545919563c7e3c">elem_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of elements stored in the matrix  <a href="#aa7ec170924ed5ad130545919563c7e3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00187.html">get_pod_type</a>&lt; eT &gt;::result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html#a1584d0c1fcd5cc903a31e65af6dae26e">pod_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex  <a href="#a1584d0c1fcd5cc903a31e65af6dae26e"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga3cbca6262a577f8823e4d2ac1b75a558">Col</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct an empty column vector  <a href="a00735.html#ga3cbca6262a577f8823e4d2ac1b75a558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga84642de9e8489897f8366bdc21ebc15c">Col</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector with the specified number of n_elem  <a href="a00735.html#ga84642de9e8489897f8366bdc21ebc15c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gacf069f75fc481cda35400cd432ce4da3">Col</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_rows, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gaf2eff14c29141ab79f5e8bf713c57c88">Col</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from specified text  <a href="a00735.html#gaf2eff14c29141ab79f5e8bf713c57c88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga927bc9d1ad87f42a351b90df2c7d9e2c">operator=</a> (const char *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from specified text  <a href="a00735.html#ga927bc9d1ad87f42a351b90df2c7d9e2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga28cab8d186bee9d3f4477ca3431a25aa">Col</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from specified text  <a href="a00735.html#ga28cab8d186bee9d3f4477ca3431a25aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gaea3d0b39d9f7b7660e66d8fb5ed97819">operator=</a> (const std::string &amp;text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from specified text  <a href="a00735.html#gaea3d0b39d9f7b7660e66d8fb5ed97819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga999f2ba62e02069d4ef259825966e3e3">Col</a> (const <a class="el" href="a00058.html">Col</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given column vector  <a href="a00735.html#ga999f2ba62e02069d4ef259825966e3e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gad0227846251100914c5f05e5bd81b18e">operator=</a> (const <a class="el" href="a00058.html">Col</a> &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given column vector  <a href="a00735.html#gad0227846251100914c5f05e5bd81b18e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga30b0630786507c517c4a4bb09da5b46b">Col</a> (const <a class="el" href="a00305.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given matrix; the matrix must have exactly one column  <a href="a00735.html#ga30b0630786507c517c4a4bb09da5b46b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga37a5036115b4482020be2a2e52bc200b">operator=</a> (const <a class="el" href="a00305.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given matrix; the matrix must have exactly one column  <a href="a00735.html#ga37a5036115b4482020be2a2e52bc200b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga3cf9701fdb61491794a91c6929639db3">operator*=</a> (const <a class="el" href="a00305.html">Mat</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gab726e44e7fd1e206bbe1a8beaab96aae">Col</a> (eT *aux_mem, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols, const bool copy_aux_mem=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given auxiliary array of eTs  <a href="a00735.html#gab726e44e7fd1e206bbe1a8beaab96aae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga795ff819f21c0df24965e110ad39e7d0">Col</a> (const eT *aux_mem, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_rows, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_n_cols)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given auxiliary array of eTs  <a href="a00735.html#ga795ff819f21c0df24965e110ad39e7d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga423bc3b79ce21bc36145d73c85b13eff">Col</a> (eT *aux_mem, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_length, const bool copy_aux_mem=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given auxiliary array of eTs  <a href="a00735.html#ga423bc3b79ce21bc36145d73c85b13eff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga1b6b29cd38bedceeeb0707674cd1f5c0">Col</a> (const eT *aux_mem, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> aux_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from a given auxiliary array of eTs  <a href="a00735.html#ga1b6b29cd38bedceeeb0707674cd1f5c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#gadf3bfee33d18231bcd0b86e6097d8de8">Col</a> (const <a class="el" href="a00054.html">Base</a>&lt; <a class="el" href="a00058.html#a1584d0c1fcd5cc903a31e65af6dae26e">pod_type</a>, T1 &gt; &amp;A, const <a class="el" href="a00054.html">Base</a>&lt; <a class="el" href="a00058.html#a1584d0c1fcd5cc903a31e65af6dae26e">pod_type</a>, T2 &gt; &amp;B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga400540a27ade3cbb258f8a1cb9b81788">Col</a> (const <a class="el" href="a00477.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a submatrix; the submatrix must have exactly one column  <a href="a00735.html#ga400540a27ade3cbb258f8a1cb9b81788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga411543fbd0dc069677f84c5b97cc7982">operator=</a> (const <a class="el" href="a00477.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a submatrix; the submatrix must have exactly one column  <a href="a00735.html#ga411543fbd0dc069677f84c5b97cc7982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga9cdfb938cf5bbf90fd0bbe7eae4a9c7f">operator*=</a> (const <a class="el" href="a00477.html">subview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a submatrix on the right-hand-side)  <a href="a00735.html#ga9cdfb938cf5bbf90fd0bbe7eae4a9c7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga33c2bfc37796aeac468fb5f256402942">Col</a> (const <a class="el" href="a00479.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a subcube; the subcube must have exactly one column  <a href="a00735.html#ga33c2bfc37796aeac468fb5f256402942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga83b1c5ca09fbaccc56481b369e11f624">operator=</a> (const <a class="el" href="a00479.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a subcube; the subcube must have exactly one column  <a href="a00735.html#ga83b1c5ca09fbaccc56481b369e11f624"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga9f5b112413a22e5b8aafab86b10e4411">operator*=</a> (const <a class="el" href="a00479.html">subview_cube</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a single-slice subcube on the right-hand-side)  <a href="a00735.html#ga9f5b112413a22e5b8aafab86b10e4411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga41f8220c06864da292784342f51bf69f">Col</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>  <a href="a00735.html#ga41f8220c06864da292784342f51bf69f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga73e17cff4fadb06f4e5354c8a05bc2a8">operator=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from given a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a>  <a href="a00735.html#ga73e17cff4fadb06f4e5354c8a05bc2a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gaef25846616f2ab89a7a89610b2650fd8">operator*=</a> (const <a class="el" href="a00078.html">diagview</a>&lt; eT &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix mutiplication (using a <a class="el" href="a00078.html" title="Class for storing data required to extract and set the diagonals of a matrix.">diagview</a> on the right-hand-side)  <a href="a00735.html#gaef25846616f2ab89a7a89610b2650fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga3e1f94edf559899b82848eca5f08c677">row</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00477.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00735.html#ga3e1f94edf559899b82848eca5f08c677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline eT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga72d6a49b04cf87b20a1b0aaa25afde90">row</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> row_num) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00477.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (row vector)  <a href="a00735.html#ga72d6a49b04cf87b20a1b0aaa25afde90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline <a class="el" href="a00478.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gac0b236520cf501b77b27065776b44230">rows</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00477.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00735.html#gac0b236520cf501b77b27065776b44230"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">arma_inline const <a class="el" href="a00478.html">subview_col</a>&lt; eT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga63425b9d51b92ca485170dca2507bed4">rows</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row1, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> in_row2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creation of <a class="el" href="a00477.html" title="Class for storing data required to construct or apply operations to a submatrix (i...">subview</a> (submatrix comprised of specified row vectors)  <a href="a00735.html#ga63425b9d51b92ca485170dca2507bed4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga35983aba6fc9affc61f64ba9dfd423d8">Col</a> (const <a class="el" href="a00308.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from <a class="el" href="a00308.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed operations; the result of the operations must have exactly one column  <a href="a00735.html#ga35983aba6fc9affc61f64ba9dfd423d8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga027c9ff27e5a4067907ea993616a408e">operator=</a> (const <a class="el" href="a00308.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from <a class="el" href="a00308.html" title="Class for storing data required for delayed unary operations, such as the operand...">Op</a>, i.e. run the previously delayed operations; the result of the operations must have exactly one column  <a href="a00735.html#ga027c9ff27e5a4067907ea993616a408e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename op_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#gaba54515b874cf50d5347779c1be010d3">operator*=</a> (const <a class="el" href="a00308.html">Op</a>&lt; T1, op_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplication, with the right-hand-side operand having delayed operations  <a href="a00735.html#gaba54515b874cf50d5347779c1be010d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga6c55bbb6467c26690a69f82e46a610b0">Col</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga6b9e57e2613ea10105f4fb29edda7d56">operator=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00092.html">eOp</a>, i.e. run the previously delayed unary operations  <a href="a00735.html#ga6b9e57e2613ea10105f4fb29edda7d56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename eop_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga621924bbd8d065ee5d75839eed758f9d">operator*=</a> (const <a class="el" href="a00092.html">eOp</a>&lt; T1, eop_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga24fc5ce5b48384fff2959fd19029205a">Col</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from <a class="el" href="a00189.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed operations; the result of the operations must have exactly one column  <a href="a00735.html#ga24fc5ce5b48384fff2959fd19029205a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga63bb967b91a689f0f469feda60095ae6">operator=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">construct a column vector from <a class="el" href="a00189.html" title="Class for storing data required for delayed binary operations, such as the operands...">Glue</a>, i.e. run the previously delayed operations; the result of the operations must have exactly one column  <a href="a00735.html#ga63bb967b91a689f0f469feda60095ae6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename glue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga3383419f4420261aab0192d4ff8fe7d3">operator*=</a> (const <a class="el" href="a00189.html">Glue</a>&lt; T1, T2, glue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">in-place matrix multiplications, with the right-hand-side operands having delayed operations  <a href="a00735.html#ga3383419f4420261aab0192d4ff8fe7d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#gac1f0b88032638ca98cf6fdde0a19b724">Col</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#ga2858b39ed158bcf14efcc47a227a0749">operator=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a matrix from <a class="el" href="a00080.html">eGlue</a>, i.e. run the previously delayed binary operations  <a href="a00735.html#ga2858b39ed158bcf14efcc47a227a0749"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename eglue_type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="a00058.html">Col</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#gac1c2ac225b095e4f3e4df83153e00cda">operator*=</a> (const <a class="el" href="a00080.html">eGlue</a>&lt; T1, T2, eglue_type &gt; &amp;X)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gafe0582791c7dbb1022f0edcc9ec27ee2">set_size</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the number of rows  <a href="a00735.html#gafe0582791c7dbb1022f0edcc9ec27ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga03821cea5dd645aad2c08c2aa4e91a8b">set_size</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a>, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#a163bed70780a1d181594d126295d5a09">n_cols</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the number of n_rows (this function re-implements <a class="el" href="a00815.html#gac55ef8df37e04e1af416594dfbe25ac6" title="change the matrix to have user specified dimensions (data is not preserved)">mat::set_size()</a> in order to check the number of columns)  <a href="a00735.html#ga03821cea5dd645aad2c08c2aa4e91a8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename eT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00735.html#gafca5e729281ec03cf80c7fc0e0f273cb">copy_size</a> (const <a class="el" href="a00305.html">Mat</a>&lt; eT2 &gt; &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the number of n_rows (this function re-implements <a class="el" href="a00815.html#gabeed7f66dc1018fd551a6e760343dee6" title="change the matrix (without preserving data) to have the same dimensions as the given...">mat::copy_size()</a> in order to check the number of columns)  <a href="a00735.html#gafca5e729281ec03cf80c7fc0e0f273cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga73b7ccda6c50b3c99eb6e2cbe2e1d887">zeros</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gab313947e5c68c10642492d669e8da664">zeros</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gaaf5eed59240c87e67eca13e5af0f5865">zeros</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a>, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#a163bed70780a1d181594d126295d5a09">n_cols</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gae690edf5923f03ee1e92b425307257df">ones</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga61a2318925fb99e4733b4e967b105471">ones</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#ab12257afbbe6338a7af830d9b65f3305">n_elem</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#gaaaf1a037851e25b368b40f26bd0002a9">ones</a> (const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#aaa8c7e5e59361913b15ae55f714ca6c6">n_rows</a>, const <a class="el" href="a00871.html#ga2caf5cd7bcdbe1eefa727f44ffb10bac">u32</a> <a class="el" href="a00305.html#a163bed70780a1d181594d126295d5a09">n_cols</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga5b97e2bc267f0c905e717dc8d5cde297">load</a> (const std::string name, const <a class="el" href="a00741.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a file  <a href="a00735.html#ga5b97e2bc267f0c905e717dc8d5cde297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00735.html#ga37376e758c35bd8470d077579c1f57b5">load</a> (std::istream &amp;is, const <a class="el" href="a00741.html#gaaf047b6ce458f7c55fd215920656d128">file_type</a> type=auto_detect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">load a matrix from a stream  <a href="a00735.html#ga37376e758c35bd8470d077579c1f57b5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename eT&gt;<br/>
 class Col&lt; eT &gt;</h3>

<p>Class for column vectors (matrices with only column). </p>

<p>Definition at line <a class="el" href="a00520_source.html#l00023">23</a> of file <a class="el" href="a00520_source.html">Col_proto.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa7ec170924ed5ad130545919563c7e3c"></a><!-- doxytag: member="Col::elem_type" ref="aa7ec170924ed5ad130545919563c7e3c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef eT <a class="el" href="a00058.html">Col</a>&lt; eT &gt;::<a class="el" href="a00058.html#aa7ec170924ed5ad130545919563c7e3c">elem_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the type of elements stored in the matrix </p>

<p>Reimplemented from <a class="el" href="a00305.html#a3b7c1109cca98fb4bf493b8be33c4299">Mat&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00520_source.html#l00027">27</a> of file <a class="el" href="a00520_source.html">Col_proto.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1584d0c1fcd5cc903a31e65af6dae26e"></a><!-- doxytag: member="Col::pod_type" ref="a1584d0c1fcd5cc903a31e65af6dae26e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00187.html">get_pod_type</a>&lt;eT&gt;::result <a class="el" href="a00058.html">Col</a>&lt; eT &gt;::<a class="el" href="a00058.html#a1584d0c1fcd5cc903a31e65af6dae26e">pod_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>if eT is non-complex, pod_type is same as eT. otherwise, pod_type is the underlying type used by std::complex </p>

<p>Reimplemented from <a class="el" href="a00305.html#a364ff14c17bd94689ca7284aea2af5c9">Mat&lt; eT &gt;</a>.</p>

<p>Definition at line <a class="el" href="a00520_source.html#l00028">28</a> of file <a class="el" href="a00520_source.html">Col_proto.hpp</a>.</p>

</div>
</div>
</div>
</BODY>
</HTML>
